<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[2019年终总结]]></title>
    <url>%2F2019%2F12%2F31%2F2019report%2F</url>
    <content type="text"><![CDATA[我的2019年终总结，从今年开始，每年进行复盘。 1、离开职场，步入创业，几个青年怀着满腔热血，投入了高考志愿填报行业，为此其实已准备了许久。经过年中市场的考验，还好，不至于太惨，公司勉强活了下来。 2、创业的想法其实早就存在，年初几个人想法成熟，一拍即合，遂着手产品研发，好在都有程序员背景，做起来不是难事。2月初陆续会合与北京，一个小团队就这样形成了。 3、北京只呆了三个月。在这个寸土寸金的地方，办公地的租赁，伙食，住宿不是这个小团队能长期承受的。期间这几个小伙子挤在一间狭窄的屋子，解决睡觉问题；自己买菜做饭解决温饱，偶尔吃个肉，都开心坏了；上午出发星巴克办公，店家打烊而归。然，终不是长久之计，遂南下江苏。为什么去江苏呢？那里有免费的办公场地，是的，我们妥协了。 4、在北京都做了什么呢？产品研发完成上线，它的名字是【报考管家】，那天是4.15号；解决了产品流量来源的问题，喊了朋友们业余帮我们运作，这里真的要谢谢这些朋友了，比心；产品运营体系初步规划完成，剩下的就是严格执行了。 5、时间到了6月，天气也热了起来，几个人空调也没舍得装，一边擦汗一边工作，忙碌且充实。业务高峰它就要来了，懈怠不得。当第一笔订单播报的那一刻，那几张流淌着汗水的脸，笑得像个傻子。虽只有几百块，比不上昔日职场中的高薪，但只有我们明白这意味着什么。 6、第一波团战，我们活了下来，虽然伤痕累累，但每个人都学到了许多，知道了一波团该如何更好的运作，也该为下一波准备了。 7、8月份，更多的小伙伴加入了，团队扩大了也更强了。 8、9月份第二款产品上线了，其实已经为此摸索了两个月。高考毕竟有业务停滞期，但公司得活下去。这次瞄准了校园电商，初次进入高校，效果还算不错。它的名字是【淘运熊】 9、10月份第一轮融资结束 10、至此两款产品一直在运营着，快速的迭代着。产品现在还有很多不足，如果您在使用过程中有改进意见，欢迎交流 11、创业不是一簇而就，我们还在路上，团队也在慢慢的变强大，一切也渐渐的走上了轨道。未来我们不知道，也无法预测，我们能做的就是奔着我们的目标，朝着那个方向，前进。 12、万物之中，希望至美。巨和团队加油！]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业小记]]></title>
    <url>%2F2019%2F12%2F23%2Fworknote01%2F</url>
    <content type="text"><![CDATA[创业一年了，谈一下我对创业的认识。 1、创业就像游戏刷副本，会遇到各种boos（市场形势、对手），有时被揍的血条见底（竞争激烈、市场经济下滑），有时得到补给血条回升（融资、盈利），有时作战的队友一个个倒下（人才流失），有时新的帮手加入作战（人才引入），最后要么团灭（倒闭），要么干掉boos爆装备升级（盈利，扩张）。 2、刷副本的核心是什么？选择要爆的boos，挑选角色组建队伍，听队伍首领，指哪打哪，齐心协力灭boos，收装备。 之于创业？一样选择熟悉的领域，挑选人才组建团队，研发产品，听老板指挥，各司其职，团结一致干掉对手，占领市场。 3、当然，游戏毕竟是游戏，团灭了可以再来一把。创业是残酷的，鲜有机会可以重新来过。 4、创业不是个时髦的名词，就像农民种地那般，夹杂着辛劳和汗水，有时回报以丰收的喜悦；有时遭遇旱涝，颗粒无收。 亦如此，但创业者坚信：“万物之中，希望至美。” 5、顺便说下我们团队目前做的东西吧！ 【淘运熊】一款可以领淘宝、京东、拼多多商品隐藏优惠券的APP，帮助大家购物省钱。大学生使用，还可以免费代取快递到宿舍哦～ 微信扫一扫，立即使用 ⬇️ 【报考管家】高考志愿填报必备利器，便捷查询高校历年招录数据，智能预测分数能上的学校。让志愿填报不再是难事。 微信扫一扫，立即使用 ⬇️]]></content>
      <categories>
        <category>创业笔记</category>
      </categories>
      <tags>
        <tag>创业笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《影响力》摘录]]></title>
    <url>%2F2018%2F10%2F29%2Fbook03%2F</url>
    <content type="text"><![CDATA[这本书主要介绍了6种人类的心理行为模式，解释了为什么有些人特别具有说服力，在不知不觉之中就能影响他人。 读完以后，一方面可以学会一些说服他人的技巧，另一方面可以减少一些被他人影响的风险。 下面是其中的一些有趣的心理学实验。 实验一：插队 一个心理学家跑到图书馆，请排队等候复印的人帮她一个小忙。 “对不起，我有5页纸要复印，能不能让我先复印呢？”当她这样说时，60%的人答应了。 然后，她换了一种说法：“对不起，能不能让我先复印呢？因为我要复印几页纸。”她只多加了两个字“因为”，但同意的人居然增加到了93%。 虽然心理学家早就知道，当我们请别人帮忙时，如果能够讲出一个理由，得到帮助的可能性就更大。但是这个实验证明，只是听到“因为”两个字，人们就会认为她是有理由的，从而给予帮助。这证明了人类存在心理定势，会不自觉地受到影响。 实验二：捐款信 美国伤残军人协会每年发出很多募捐信，经过统计，18%的收信人会捐款。 有一年，该协会主动在信中放了一个小礼物（比如背面涂了不干胶的标签），结果捐款率几乎翻了一倍，35%的收信人捐款了。 这说明人们存在“互惠心理”，接受别人的礼物后会有一种负债感，觉得自己应该回报。所以，先给予别人一点小恩小惠，然后再提出请求，将会大大提高对方答应请求的可能性。 实验三：陪同参观 心理学家来到大学校园，询问大学生们是否愿意陪一群少年犯去参观动物园，只有17%学生表示愿意。 心理学家换了一种说法，先问你是否愿意每周为少年犯提供2小时的咨询服务，至少坚持两年？所有人都表示不愿意。心理学家又问，那么你是否愿意陪他们去参观一次动物园呢？这一次，50%的学生表示愿意。 可以看到，让对方先拒绝一个更大的请求，会使得另一个较小的请求被接受的可能性上升三倍。心理学的解释是，人们不喜欢有负债感，当你拒绝对方的时候就会形成潜在的负债感，即使你实际上没有欠对方任何东西。为了做到不亏欠，人们往往会同意第二个较小的请求。另一方面，这里还涉及心理学的对比原理，因为两个请求形成对比，使得第二个请求看上去不那么过份，所以更有可能得到同意。 这种情况在实际生活中的应用是，如果你要向别人推销，就要先展示质次价高的商品；如果你要向别人借钱，就要先开口借一个很高的金额。这样会增加第二个请求被接受的可能性。 实验四：看管物品 心理学家在海滩上随便找一个人作为实验对象，在离他1米的地方，放下浴巾，很放松地躺在上面，听着便携式收音机传出来的音乐。几分钟之后，心理学家从浴巾上爬起来，向大海走去。 过了一会，一个假扮的小偷来了，拿起收音机就走。通常情况下，实验对象都不愿冒险去阻拦那个小偷。在20次的实验中，只有4个人挺身而出。 心理学家改变做法，在下海游泳时，口头请求实验对象帮忙照看一下东西，所有实验对象都答应了。当小偷再来拿收音机时，20个实验对象中有19个人挺身而出。他们追赶着小偷，叫他停下来，要求他对自己的行为做出解释，而且大多数人都会冲上去拉住他，或者干脆把收音机从他手里夺过来。 这是因为人们希望能够遵守承诺。人们在心理上有一种要与过去的所作所为保持一致的愿望。一旦做出了某个决定，或选择了某种立场，就有一种压力要与它保持一致，证明之前所做的决策。 实验五：公益广告牌 心理学家假扮成义工，在加州的一个居民区内，挨家挨户地向居民们提出请求，希望允许在社区草地上树立一块超大的公益广告牌。 为了让居民了解广告牌竖起来之后的样子，他们展示了一张照片：一栋漂亮的房子几乎被广告牌遮得严严实实，广告牌上面歪歪扭扭地写着几个字“小心驾驶”。83%的居民理所当然地拒绝了这个要求。 心理学家又换了一个社区，先向居民询问，是否同意树立一块宣传安全驾驶的小牌子。这个请求不算什么，几乎所有人都答应了。两个星期后，心理学家拿着同一张大广告牌的照片，再来征求居民同意，这次只有24%的居民拒绝这个要求。 人们之所以对同一张广告牌，产生不同的态度。原因就是一旦人们之前同意了某个请求，后面的态度就会发生改变，他会答应陌生人的请求，努力与自己过去的承诺保持一致。 一般来说，当一个人公开选择了某种立场之后，马上就产生一种维持这个立场的压力，因为他想在别人眼里显得前后一致。而且，知道你的立场的人越多，你就越不愿意去改变它。所以，让对方信守承诺的最好方法，就是让他把承诺写下来，再尽量多地向他人展示。 实验六：怕狗的小朋友 心理学家挑选了一些怕狗的幼儿园小朋友，让他们每天花20分钟观看一个小男孩高兴地与狗玩耍。结果，这一做法使得怕狗的儿童发生了明显变化。 仅仅在4天之后，就有67%的儿童愿意钻进圈着小狗的围栏里，与小狗玩耍。而且当其他人离开后，他们仍旧待在那里，亲热地拍打或抚摸小狗。 这说明周围人的做法对我们决定自己的行动，具有很重要的指导作用。 实验七：旁观者 心理学家让一个纽约大学的学生，在马路上假装癫痫病发作。 当只有一个旁观者在场的时候， 85%的情况他会选择去帮助发病的大学生。当有5个旁观者在场的时候，大学生得到帮助的概率只有31%。 既然绝大部分单独经过的人，都会伸出援手，我们就很难说这是一个“冷漠的社会”。但是，与一般的看法相反，旁观者越多，实际上得到帮助的可能性反而变小了，这是为什么？ 心理学家认为，原因至少有两个。第一个原因是，当有多个旁观者时，每个人的责任感都会下降，“也许其他人会帮忙的，也许有人已经这样做了。”结果，没有一个人帮忙。第二个原因是，每个人看到其他人都没有行动，就认为既然大家都不担心，说明一切正常。而且，我们都不喜欢在别人面前显得慌乱。 重要的是认识到，旁观者没有采取行动并不是因为冷漠无情或缺乏善意，而是因为他们不知道是否有紧急事件发生，也不知道自己是否有责任去采取行动。如果他们明确地知道自己负有责任，他们的反应是非常迅速的。 当你遇到危险，正确的做法是从人群中挑出一个人来，盯着他，指着他，直接对他说：“你，穿蓝夹克的先生，我需要帮助，请叫一辆救护车来。”通过这么简单的一句话，你可以让周围的人了解你的处境、明确他们的责任、消除所有可能妨碍或延误救助的不确定性。 实验八：足球队的称呼 在期末考试结束以后，心理学家对亚利桑那州立大学的学生做电话调查，询问他们该校足球队上一场比赛的输赢。 如果上一场比赛输了，只有17%的学生会说“我们的球队”；如果上一场比赛赢了，用到“我们”这个词的学生就会增加到41%。 这种差异的原因是，人们对与自己相似的人会产生好感。因为没人喜欢当失败者，所以人们更愿意与失败者保持距离或差异。 实验九：估计身高 心理学家将一位来自英国剑桥大学的访问者，依次介绍给澳大利亚某所大学五个班级的学生。但在每一个班上介绍他时，他的身份都不相同。 在第一个班上，他被介绍为学生；在第二个班上，他被介绍为实验员；在第三个班上，他被介绍为讲师；在第四个班上，他被介绍为高级讲师；而在第五个班上，他被介绍为教授。 当他离开之后，心理学家要学生们估计那位访问者的身高。结果发现，随着地位每一次升高，学生们估计的身高平均会增加1.5厘米。所以，当访问者是“教授”时比他是“学生”时，身高要高出6厘米。 这说明头衔对人们有很大的影响力，一个人的头衔越显赫，人们对这个人的身高就估计得越高。这反映了人们仰视权威的心理。 实验十：闯红灯 心理学家让一名31岁的男子在好几个不同的地方，闯红灯横穿马路。 有一半时间，他穿着一套烫得很平整的高级西服，系着领带；而另一半时间，他穿着普通的工作服。后一种情况时，并没有多少人跟着他一起闯红灯；而前一种情况时，跟着他的人简直是成群结队。 这说明，人们很容易从服装去判断权威。如果对方穿着一套权威的衣服，大多数人会选择服从。 实验十一：按喇叭 心理学家在旧金山的繁忙路口做了一项调查。 当绿灯亮起的时候，如果前面停着一辆普通的经济型轿车，久久不开，几乎后面所有的司机都按了喇叭，而且大多数人按了不止一次。但是，如果前面停的是一辆豪华的高级轿车，只有50%的司机会按喇叭，其他人老老实实在后面等着，直到它开动为止。 这说明，人们会从车辆判断车主的地位，尊敬拥有名车的人。 实验十二：品尝饼干 心理学家让一些消费者品尝同样的饼干。 有一半人的罐子里有10块饼干，而另一半人的罐子里只有2块饼干。结果可想而知，后一半人对饼干的评价更高。 这说明人们对稀缺的东西，会做出更高的评价。因此，与其告诉人们将会得到什么，不如告诉他们将会失去什么，这样更容易对他人产生影响。]]></content>
      <categories>
        <category>书籍摘录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[react 仿简书知识点总结]]></title>
    <url>%2F2018%2F10%2F28%2Freact-jianshu%2F</url>
    <content type="text"><![CDATA[这里是一篇对 react 仿简书视频教程的总结。 react官网 项目代码地址 react 初探 简介 开发环境 cdn create-react-app 工程目录 组件 JSX语法 react 基础 响应式设计思想 setState() 事件绑定 bind() or 箭头函数 // 输入框中输入 html 标签时，加此属性不自动转义&lt;li dangerouslySetInnerHTML=&#123;&#123;__html: item&#125;&#125;&gt;&lt;/li&gt;this.setState((prevState) =&gt; (&#123; list: [...prevState.list, prevState.inputValue]&#125;))constructor(props) &#123; super(props) this.handleClick = this.handleClick.bind(this)&#125; 父组件通过属性向子组件传递方法时，父组件方法需要 bind(this)。 react 的一些思考： react：声明式开发 jquery：命令式编程 可以与其它框架共存：#root标签之外的 DOM 不受 react 管理 单向数据流：react 不提倡子组件更改父组件数据 视图层框架 函数式编程 react 进阶第一点： PropTypes Default Props 参考地址 第二点： props state render函数 当组件 state or props 改变，render 函数重新执行。 当父组件的 render 函数被运行时，它的子组件的 render 都将被运行一次 第三点：虚拟 DOM 就是个 JS 对象 参考文章 虚拟 DOM 使得跨端应用得以实现 第四点：diff 算法 同层比对 循环中的 key 值不要使用 index 第五点：ref &lt;span ref="&#123;(el) =&gt; &#123;this.span = el&#125;&#125;"&gt;&lt;/span&gt; // this.span 就是 span 标签this.setState(()=&gt;&#123;&#125;,()=&gt;&#123;&#125;) // 在第二个参数获取 DOM 才正确 尽量不使用 ref，毕竟应该数据驱动视图 第六点：生命周期函数 某一个时刻执行的函数。 init：props and state mounting componentWillMount render componentDidMount updation unmounting 第七点：生命周期函数使用场景 避免子组件做无畏的渲染： shouldComponentUpdate(nextProps, nextState) &#123; if (nextProps.content !== this.props.content) &#123; return true &#125; else &#123; return false &#125;&#125; 第八点：发送ajax请求 在 componentDidMount() 生命周期函数内调用，使用 axios 库。 第九点：使用 charles 实现本地数据 下载 charles 新建 json 数据文件，在 charles 中创建相应代理。 第十点：react 实现 css 过渡动画 让一个 DOM 在显示 隐藏中切换（opacity），借助 CSS3 的 transition 属性即可实现。 第十一点：使用 css 动画效果 使用 @keyframes 方法就是添加类 第十二点：使用 react -transition-group 使用方法 // in 就是根据true false 判断 入场或出场动画// unmountOnExit 出场后 移除DOM// appear 页面显示 展示入场动画&lt;CSSTransition in=&#123;focused&#125; timeout=&#123;200&#125; classNames="slide" unmountOnExit onEntered=&#123;(el) =&gt; &#123;el.style.color="blue"&#125;&#125; appear=&#123;true&#125;&gt; &lt;div className="slide-enter"&gt;123&lt;/div&gt;&lt;/CSSTransition&gt; slide-enter slide-appear slide-enter-active fade-appear-active slide-exit slide-exit-active 如何实现列表中每插入一项都添加动画，方法可见上面链接的文档。 redux参考文章 store 是唯一 只有 store 能改变自己的内容 reducer 是纯函数：只要函数体有 Date、ajax、定时器等都不是纯函数 一些 API： createStore() store.dispatch() store.getState() store.subscribe() UI组件和容器组件： UI：页面渲染 容器：业务逻辑 容器组件编写业务逻辑，向 UI 组件通过属性传入所需数据，即 UI 只提供显示。 无状态组件： 就是个函数。 const Demo = (pros) =&gt; &#123; return ( &lt;div&gt;123&#123;props.content&#125;&lt;/div&gt; )&#125; 处理异步的 redux 中间件: redux-thunk：使用方法 与 redux-devtools 结合使用：查看地址 redux 中间件就是在 dispatch(action) 时，发现 action 是函数的话，会进行处理，然后再回到 dispatch(action)，当 action 对象时，store 接管，给 reducer 处理。 另一个异步中间件 redux-saga：使用方法 react-redux Provider：传递 store connect：组件中拿 store // state 挂载到 props 上const mapStateTOProps = (state) =&gt; &#123; return &#123; test: state.test &#125;&#125;// store.dispatch 挂载到 props 上const mapDispatchToProps = (dispatch) =&gt; &#123; return &#123; handleLogin() &#123; &#125; &#125;&#125;export default connect(mapStateTOProps, mapDispatchToProps)(DemoComponent) 实战1、 使用 style-components 对每个组件样式进行管理： yarn add style-components 在 index.js 文件中引入 style.js 文件 2、 immutable.js：使用方法 // 子 reducer.jsimport &#123; fromJS &#125; from 'immutable';const defaultState = fromJS(&#123; focused: false, mouseIn: false, list: [], page: 1, totalPage: 1&#125;);export default (state = defaultState, action) =&gt; &#123; switch(action.type) &#123; case constants.SEARCH_FOCUS: return state.set('focused', true); case constants.SEARCH_BLUR: return state.set('focused', false); case constants.CHANGE_LIST: return state.merge(&#123; list: action.data, totalPage: action.totalPage &#125;); case constants.MOUSE_ENTER: return state.set('mouseIn', true); case constants.MOUSE_LEAVE: return state.set('mouseIn', false); case constants.CHANGE_PAGE: return state.set('page', action.page); default: return state; &#125;&#125;// 总 reducer.jsimport &#123; combineReducers &#125; from 'redux-immutable';// index.jsconst mapStateToProps = (state) =&gt; &#123; return &#123; focused: state.getIn(['header', 'focused']), list: state.getIn(['header', 'list']), page: state.getIn(['header', 'page']), totalPage: state.getIn(['header', 'totalPage']), mouseIn: state.getIn(['header', 'mouseIn']), login: state.getIn(['login', 'login']) &#125;&#125; 3、 避免无意义请求发送： 根据每次触发事件时的参数来判断这个请求是否需要再次发送。 4、 每次开发，先分析页面布局，能抽的组件抽一下，然后编写样式，使用 redux 编写一些静态数据看效果，然后设置action，异步请求数据。 5、 获取 url 中的参数： 动态路由：/detail/:id(通过 this.props.match.params.id 获取) query 形式传递：this.props.location.search 6、 异步组件：react-loadable 7、 不是 &lt;Route path=&#39;/detail/:id&#39; exact component={Detail}&gt;&lt;/Route&gt; 里面的组件，想要获取路由信息，需要这样： import &#123; withRouter &#125; from 'react-router-dom'@withRouter@connect( null, &#123; loadData &#125;) 8、 项目部署服务器]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VScode个人常用扩展及设置]]></title>
    <url>%2F2018%2F10%2F26%2Fvscode%2F</url>
    <content type="text"><![CDATA[这一篇记录一下，VScode 中 个人常用的扩展及设置。 扩展 ESLint One Dark Theme Seti-theme Sublime Text Keymap vetur Prettier Bracket Pair Colorizer px2rem auto close tag auto rename tag beautify git history JavaScript (ES6) snippets Markdown Preview Enhanced markdown preview github markdown all in one Terminal Path Intellisense Open in Browser react/redux/react-router editorconfig for vscode 个人设置// 将设置放入此文件中以覆盖默认设置&#123; "window.zoomLevel": -1, "editor.tabSize": 2, "workbench.colorTheme": "One Dark Theme", "editor.snippetSuggestions": "top", "explorer.confirmDragAndDrop": false, // "editor.formatOnSave": true, // 控制字体系列。 "editor.fontFamily": "Consolas, 'Courier New', monospace, Dengxian", "editor.multiCursorModifier": "ctrlCmd", "files.associations": &#123; "*.inc": "html", "*.ejs": "html", "*.wxss": "css", "*.wpy": "vue" &#125;, "explorer.confirmDelete": false, "vsicons.dontShowNewVersionMessage": true, "prettier.singleQuote": true, "prettier.semi": false, "vetur.format.defaultFormatter.html": "js-beautify-html", "vetur.format.defaultFormatterOptions": &#123; "wrap_attributes": "force-aligned" &#125;, "emmet.syntaxProfiles": &#123; "vue-html": "html", "vue": "html", "wpy": "html" &#125;, "eslint.validate": [ "javascript", "javascriptreact", "html", &#123; "language": "vue", "autoFix": true &#125; ], "eslint.autoFixOnSave": true, "beautify.language": &#123; "js": &#123; "type": [ "javascript", "json" ], "filename": [ ".jshintrc", ".jsbeautify" ] &#125;, "css": [ "css", "less", "scss" ], "html": [ "htm", "html" ] &#125;, "git.autofetch": true, "git.enableSmartCommit": true, "javascript.implicitProjectConfig.experimentalDecorators": true, "emmet.includeLanguages": &#123; "wxml": "html" &#125;, "minapp-vscode.disableAutoConfig": true&#125;]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《十亿消费者》摘录]]></title>
    <url>%2F2018%2F10%2F24%2Fbook02%2F</url>
    <content type="text"><![CDATA[想在中国经商的人，这本书是必读的。尤其是如何处理与中国政府的商业关系，大概很难找到比它更好的读物了。 1、中国文化 贤明君主自上而下的管理，是中国数千年社会秩序的基础。直到今天，也是中国普遍流行的商业管理模式。 中国文化的核心，就是追求和谐，哪怕这种和谐是表面的。 中国文化提倡，个人追求恭顺和礼仪，接受来自上层的命令和决策。 中国儿童在生活中学到的第一课就是纪律，家长教育孩子遵守纪律。 中国文化提倡克制、克制、再克制。 中国人习惯服从领导。领导人可以对所有问题下命令，甚至包括下属的家庭矛盾。 由于推崇稳定和强调服从，中国人对那些充满魅力、照顾属下、发号施令的领袖惟命是从。 中国人的这种服从性格，在制造业中颇有成效。但是一旦走出国门，或者进入需要更具创造力的领域如研发，中国模式的缺点就暴露无遗。 什么是中国公司中最常见的四个字？“听领导的！” 2、重视稳定和秩序 中国政府最重视的，就是稳定和秩序。 想在中国生存，你不能让这个体制感到为难。你要说明你公司的业务是如何有利于中国。 如果想要打击对手，你可以把对手描绘成破坏体制的人。 为了维持表面上的秩序，中国人的行为准则，不是有没有内疚，而是会不会被揭露。 中国的法律假设，一切皆在政府控制之下，除非法律明文允许，否则你做的事情都是不合法的。而美国法律假设，政府不得干涉人民自由，除非法律明文禁止，否则你可以做任何事情。 为什么中国的交通很乱？因为各种政治压制和社会控制的存在，中国人把油门和方向盘当作发泄工具。 3、教育 中国教育体制培养出来的人是被领导的，而不是领导别人。这种教育体制的结果，就是强大但却缺乏主动的劳动力大军，而创新性的商业领袖和各种经理人非常之少。 教育在中国是最大的优势，也是最大的劣势。 中国人记忆超群，精于数学，安于枯燥冗长工作。但是死记硬背的教育体系大大削弱了人们的分析和领导能力。 4、重视金钱利益 快速的形势变化，又没有社会保障，一切让中国人惴惴不安。大家都觉得，获得安全感的唯一方法，就是快速获得财富。很多中国人只信任钱。 在葬礼上，一个核心环节就是烧纸钱，给死人送去资产。 在婚礼上，来宾们在公然注视下，排队送礼金，每个人的信封被撕开、清点、并纪录下来。 由于急于致富，除非被迫，否则没有人会排队。每个人都拼命往前挤。这也是商业的运作模式。 快速致富的必然推论是“谁也不要相信”。中国人对体制、对陌生人有着深深的不信任。结果就是商业环境中到处是不诚实。中国人之间毫无信任可言。在中国做买卖，人们的预期就是对方会骗自己。 中国社会是自私的。中国人竞争能力很强，合作能力很弱。中国人是全世界最自我、最自私的民族之一。 单个来说，中国人是凶猛可怕的商人。但是，中国人很难组建大型组织，这样的组织需要人们分享观点、平等共处。 在中国，你要么有钱，要么听话。 5、人际关系与法律 人际关系在中国社会的重要性，远大于西方。法律和合同的规定，不如人际关系重要。机会来自和有权有势的人的交往。 在中国做生意，不要完全依赖于法律，你会输的。法律只是你商业行为的一种论据。在一个缺乏公平和公正的法律体系中，你的人际网络能确保你的安全。 中国人事部门主管的权力远高过西方，因为那些被录用的人往往对他们心怀感激。 在这个需要和层层官僚及个人利益打交道的国家，单靠个人能力是无法成事的。 商业公司如果不把政府关系当作业务最关键的一部分，那么它的业务就会出现问题。 亲吻干部，拥抱客户。]]></content>
      <categories>
        <category>书籍摘录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[周记06]]></title>
    <url>%2F2018%2F10%2F21%2Fweekly-report06%2F</url>
    <content type="text"><![CDATA[每周记录第六篇 系统出了问题，由于没有及时发布文章，造成第四篇、第五篇周记丢失，无法追回。 由此，才开始重视云办公的重要性。现在使用坚果云保存每天的笔记，只要本地保存就会自动同步云端，另外，整个博客源码也在 github，博客文章写完之后，就立马提交和发布。如此以来笔记丢失的概率就降低了。 为什么不用云笔记呢？因为我还是喜欢本地简单的 markdown 编辑器，干扰因素少，沉浸式写作。 1、 工作时间久了，面对工作中重复的任务，其实已无多少技术含量，无非就是在耗费体力。这也没有办法，毕竟是公司机制决定的。 想提升自己的技术水平，必须抓住工作之外的时间，去钻研、实践、总结，每天进步一点，离梦想就会更近一步。 2、 这周空余时间，把 Vue 和 React 重新回顾了一下， 这是两个 demo： vueTravel demo react-jianshu demo 在编码过程中，对前端项目开发有了一些更深刻的认识。 开发一个项目无非就是执行这三点： （1）工程架构。根据技术选型（vue | react | angular | 多页应用）搭建开发环境，自动化编译代码、打包、更新页面；针对各种环境创建配置，自动化构建；使用 ESLint 规范代码质量，保证项目质量； （2）项目架构。根据技术方案创建清晰的项目目录结构，每个目录放置什么内容规定好；项目数据解决方案，比如 react-redux or vue-vuex；项目整体代码风格，比如哪些数据应该放在 redux or vuex，组件中的逻辑应该放在自己内部还是通过属性写在被引入的页面里（根据组件性质决定，如果是做开源组件，那必须和项目解耦，有更强的扩展性。如果组件只是在本项目使用，那么可以直接在组件中写逻辑代码）；项目的全局配置（接口地址、常量等）；基本的工具方法（ajax 封装、字典、常用的正则校验）、字体图标（iconfont）；文件、变量命名，注释规范制定。 （3）业务编码。拿到原型，梳理页面结构、功能，拆分出组件，根据制定的代码风格和规范编写对应组件并与后台对接接口，然后把相应组件组合成所需页面（组件化编程） 不管是单页应用或者多页应用，编程思想是相似的。一个应用程序是庞大的，我们可以将其拆分成一个个单元，每个部分保持独立，拆分的原则就是 单一职责原则（一个程序只做好一件事），这也符合 UNIX 的设计哲学：小即是美。 3、 《你只是看起来很努力》，这本书买了很久了，一直没认真翻阅。 我回顾自己每天的生活，早起早睡，每天都有计划的事情做，看似很充实。久而久之发现，其实没有多大的进步。心中不免产生疑问，刚好抬头看到了这本遗忘了很久的书，索性去一探究竟。 在书中，作者把一个个自己或他人的经历，编写成鲜活的故事，总有那么几个事情让自己特别有代入感，引人深思。为什么你努力了那么久，还是几乎在原地踏步，因为 你只是看起来很努力。在努力的背后，你真正的在做什么？你的方法对了吗？书中通过鲜明的经历告诉你真实的答案。 4、 无意中发现了一本书《我不惧怕成为这样强硬的姑娘》，作者用自身经历演绎了什么叫寒门贵子。 书中对于如何克服拖延这个坏习惯，举了一些对策，我觉得很有用。 第一，一定要找到实现目标的明确途径，清楚每一个行动的作用和效果，这样才会愿意行动起来。准备研究生考试时，我就曾试图把达成目标的任务都明确下来。在复习前先设定理想分数，把需要掌握的知识点列出来，后面标明它们在过去被考的概率，然后像小坦克碾轧一样，一批一批地消灭掉，这过程居然还有点爽呢。找出这个人，然后看一下成为他、取代他需要做哪几件事，包括需要学习哪些东西，需要掌握什么资源，需要升几级，怎么做会更快，把过程清晰地写出来。 第二，从想做的事情开始做。每次要开始做一件我非常不想做的事情时，就从一件比较想做的事情开始，或者从那件事情中比较简单的一部分开始。 第三，如果能及时看到行动的反馈，坚持起来就会更容易。好胜心会让你在听到差评的时候更努力，成就感会让你在听到好评的时候去继续努力。 第四，周期性坚持。为了避免周一进入学习状态时不适应或者太痛苦，周日晚上就坐在桌子前去熟悉一下周一的事情，稍微做一点简单的任务或者做一个规划。 第五，别去做任何一个你根本做不到的计划。一定要结合自己现在的水平和实际情况去做一个“一定可以完成”的计划，在时间上留一点余地。 第六，找到那些做出错误决定的瞬间。记录自己失控的那些瞬间，找到自己失控的原因。 郭金超于浙江杭州2018-10-21]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议笔记]]></title>
    <url>%2F2018%2F10%2F18%2Fhttp%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[HTTP 协议笔记。 http基础 物理层主要作用是定义物理设备如何传输数据 数据链路层在通信的实体间建立数据链路连接 网络层为数据在结点之间传输创建逻辑链路 http 请求和 TCP 连接不是一个概念，HTTP1.1 以前，当服务器响应完请求之后，就关闭了 TCP 连接。HTTP1.1 之后，一个 TCP 连接可以发送多个 HTTP 请求。 HTTP1.1：持久连接、pipeline、增加 host 和其他一些命令。 HTTP2：所有数据以二进制传输、同一个连接里面发送多个请求不再需要按照顺序来、头信息压缩以及推送等提高效率的功能。 url http 客户端 浏览器 curl 命令：curl -v www.baidu.com CORS跨域请求的限制与解决 跨域请求其实已经发送了，并且结果也返回了，只不过浏览器在拿到响应头时，发现没有对应头信息处理跨域，就把结果忽略了，并且在控制台报错。 简单请求： 请求方法为：HEAD or GET or POST 头信息 Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值：application/x-www-form-urlencoded or multipart/form-data or text/plain 凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。 cors 的 http 响应：Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，不发送该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个服务器返回的基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 非简单请求： 非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器大量收到DELETE和PUT请求，这些传统的表单不可能跨域发出的请求。 Cache-Control public：http请求 经过的任何地方都可以缓存 private：只有浏览器才可以缓存 no-cache：会先服务器验证 max-age=&lt;seconds&gt;：多长时间缓存过期 s-maxage=&lt;seconds&gt;：用于代理服务器缓存 max-stale=&lt;seconds&gt;：即便缓存过期，只要没有超过这里设置的如期，仍可去缓存取 must-revalidate：重新验证 proxy-revalidate no-store：所有地方缓存都不生效，每次都要服务器拿 no-trnsform 缓存验证：Last-Modified 上次修改时间 配合 If-Modified-Since 或者 If-Unmodified-Since 使用 对比上次修改时间以验证资源是否需要更新 缓存验证：Etag 数据签名 配合 If-Match 或者 If-Non-match 使用 对比资源的签名判断是否使用缓存 Cookie 通过 Set-Cookie 设置 下次请求会带上 键值对，可以多个 max-age 和 expires 设置过期时间 Secure 只在 https 的时候发送 HttpOnly 无法通过 document.cookie 访问 HTTP 长连接 Connection: keep-Alive / close 浏览器并发连接数有限制：chrome 6个 数据协商 request Accept Accept-Encoding Accept-Language User-Agent response Content-type Content-Encoding Content-Language # requestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.80 Safari/537.36Accept: */*Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9# responseX-Content-Type-Options: nosniffContent-Type: text/html; charset=utf-8Content-Encoding: gzip 跳转 Redirect 参考代码 301 永久跳转时，浏览器再次访问对应路径，会自动变为需要跳转的路径，不经过服务器，这样操作后，浏览器会缓存之前设置的路径，就算服务端的跳转代码进行修改，也不会生效，除非清楚浏览器缓存。302 临时跳转，每次都要经过服务器。 content-security-policy 限制资源获取 Nginx 下载地址：http://nginx.org/en/download.html Nginx代理配置和代理缓存 安装目录下的conf&gt;nginx.conf文件： # 自定义配置文件# nginx.conf 中添加此内容include servers/*.conf;# test.conf文件内容如下：proxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; # 代理缓存配置# server &#123;# listen 80;# server_name test.com; # 代理 test.com 到 http://127.0.0.1:8888# location / &#123;# proxy_cache my_cache; # 设置代理缓存，如果设置了浏览器缓存，那么代理也会实施缓存，那么使用其他浏览器访问，就会从代理缓存取数据（或者其他用户进行访问）# proxy_pass http://127.0.0.1:8888;# proxy_set_header Host $host; # 代理头 设置host为test.com# &#125;# &#125;server &#123; listen 80 default_server; # 自动跳转 https listen [::]:80 default_server; server_name test.com; return 302 https://$server_name$request_uri;&#125;server &#123; # listen 443; # 配置https listen 443 http2; # 配置http2 server_name test.com; http2_push_preload on; # http2配置 服务端推送 ssl on; ssl_certificate_key ../certs/localhost-privkey.pem; # 那个命令生成的两个文件的地址 ssl_certificate ../certs/localhost-cert.pem; location / &#123; proxy_cache my_cache; proxy_pass http://127.0.0.1:8888; proxy_set_header Host $host; &#125;&#125; 代理服务器可以很容易修改http请求的请求和响应内容，因为 http 请求是明文传输，可以解析得到，https 是不可以的，因为 https 进行了加密 HTTPS解析 http明文传输，可以拦截取到 私钥、公钥 Nginx部署HTTPS 本地生成 公钥私钥# git bash 执行命令 生成两个文件openssl req -x509 -newkey rsa:2048 -nodes -sha256 -keyout localhost-privkey.pem -out localhost-cert.pem http2 浏览器并发 TCP连接数 限制 优势 信道复用（一个 TCP 链接就行） 分帧传输 server push(服务端主动推送内容) ALPN nginx 兼容处理 http2:# 测试curl -v -k https://test.comcurl -v -k --http1.1 https://test.com # 使用http1.1]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人性的弱点》摘录]]></title>
    <url>%2F2018%2F10%2F15%2Fbook01%2F</url>
    <content type="text"><![CDATA[如何处理人际关系，如何得到一种较理想的人生，这本书给出了非常好的建议。 1、人际关系的基本技巧 不要批评、谴责、抱怨。 真诚地欣赏他人。 激发他人的渴望。 2、获得他人好感的六种方法 对他人真的感兴趣。 微笑。 所有语言中最甜蜜、最重要的声音，就是当一个人听到自己的名字。 做一个优秀的听众，鼓励对方谈论他自己。 谈对方感兴趣的话题。 让对方感觉自己很重要，并且你是真诚地这样做。 3、如何得到他人的支持 彻底赢得争议的唯一方法，就是避免争议。 尊重他人的意见，绝不说”你错了“。 一旦发现自己不对，立刻无保留地承认。 以一种友好的方式开场。 尽快让对方说”是这样的“。 让他人多多发言。 让他人感觉，你说的是他的想法。 诚恳地站在他人的角度，看待问题。 对他人的想法和主张，抱有理解和同情。 诉诸更高尚的动机。 把你的想法，用故事表达。 激起对方的好胜心。 4、如何做领导者 以表扬和真诚的欣赏开场。 婉转地指出他人的错误。 批评他人之前，先谈自己的错误。 设问，而不是下达命令。 让他人有面子。 赞扬每一个细微的进步，衷心地表达你的认可，慷慨地给出赞美之词。 给他人应有的荣誉。 不断地鼓励，让犯错看上去是一件小事。 他人做你建议的事情时，让他们心情愉快。]]></content>
      <categories>
        <category>书籍摘录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JS 设计模式]]></title>
    <url>%2F2018%2F10%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[JS 设计模式笔记。 面向对象搭建开发环境npm / webapck / webpack-dev-server / babelbabel-core babel-loader babel-polyfill babel-preset-env 什么是面向对象概念 类（对象的模板）、对象（实例） class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; console.log(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`) &#125;&#125;let zhang = new People('zhang', 20)zhang.eat()zhang.speak()let wang = new People('wang', 21)wang.eat()wang.speak() 三要素：继承封装多态 继承：子类继承父类 继承是父类，公共的，不仅仅服务于 Student 继承可将公共方法抽离出来，提高复用，减少冗余 封装：数据的权限和保密 public 完全开放 protected 对子类开放 private 对自己开放 ES6不支持，可以用 typescript 演示 减少耦合，不该外露的不外露 利于数据、接口权限的管理 ES6 目前不支持，一般认为_开头的属性是私有的 多态：同一接口不同实现 JS 应用少 保持子类的开放性和灵活性 面向接口编程 // 继承class People &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat something`) &#125; speak() &#123; console.log(`My name is $&#123;this.name&#125;, age $&#123;this.age&#125;`) &#125;&#125;class Student extends People &#123; constructor(name, age, number) &#123; super(name, age) this.number = number &#125; study() &#123; console.log(`$&#123;this.name&#125; study`) &#125;&#125;let xiaoming = new Student('xiaoming', 10, 'A1')xiaoming.study()console.log(xiaoming.number)let xiaohong = new Student('xiaohong', 11, 'A2')xiaohong.study()// 多态class People &#123; constructor(name) &#123; this.name = name &#125; saySomething() &#123; &#125;&#125;class A extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; console.log('I am A') &#125;&#125;class B extends People &#123; constructor(name) &#123; super(name) &#125; saySomething() &#123; console.log('I am B') &#125;&#125;let a = new A('a')a.saySomething()let b = new B('b')b.saySomething() JS 应用举例 class jQuery &#123; constructor(selector) &#123; let slice = Array.prototype.slice let dom = slice.call(document.querySelectorAll(selector)) let len = dom ? dom.length : 0 for (let i = 0; i &lt; len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || '' &#125; append(node) &#123; &#125; addClass(name) &#123; &#125; html(data) &#123; &#125; // 此处省略若干 API&#125;window.$ = function(selector) &#123; return new jQuery(selector)&#125; 面向对象的意义 程序执行：顺序、判断、循环——结构化 面向对象：数据结构化 对于计算机，结构化的才是最简单的 编程应该 简单 &amp; 抽象 UML类图统一建模语言。 类图：UML 包含很多种图，本次相关的是类图 关系：主要讲解泛化和关联 泛化表示继承，关联表示引用 类图： 关系： 设计原则 什么是设计 即按照哪一种思路或者标准来实现功能 功能相同，可以有不同设计方案来实现 伴随着需求增加，设计的作用才能体现出来 UNIX / LINUX 设计哲学 准则1：小即是美 准则2：让每个程序只做好一件事 准则3：快速建立原型 准则4：舍弃高效率而取可移植性 准则5：采用纯文本来存储数据 准则6：软件复用 准则7：使用 shell 脚本来提高杠杆效应和可移植性 准则8：避免强制性的用户界面 准则9：让每个程序都称为过滤器 小准则：允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写并尽量简短 沉默是金 SOLID五大设计原则 S 单一职责一个程序只做好一件事如果功能过于复杂就拆分开，每个部分保持独立 O 开放封闭对扩展开放，对修改封闭增加需求，扩展新代码，而非修改已有代码这是软件设计的终极目标 L 李氏置换子类能覆盖父类父类能出现的地方子类就能出现JS 中使用较少（弱类型&amp;继承使用较少） I 接口独立保持接口的单一独立，避免出现“胖接口”JS 中没有接口（typescript 例外），使用较少类似于单一职责原则，这里更关注接口 D 依赖倒置面向接口编程，依赖于抽象而不依赖于具体使用方只关注接口而不关注具体类实现JS 中使用较少（没有接口&amp;弱类型） 设计模式从设计到模式 创建型 工厂模式 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 迭代器模式 模板方法模式 职责连模式 观察者模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 明白每个设计的道理和用意 通过经典应用体会它的真正使用场景 自己编码时多思考，尽量模仿 两个面试题 01 class Car &#123; constructor(number, name) &#123; this.number = number this.name = name &#125;&#125;class Kuaiche extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 1 &#125;&#125;class Zhuanche extends Car &#123; constructor(number, name) &#123; super(number, name) this.price = 2 &#125;&#125;class Trip &#123; constructor(car) &#123; this.car = car &#125; start() &#123; console.log(`行程开始，名称: $&#123;this.car.name&#125;, 车牌号: $&#123;this.car.price&#125;`) &#125; end() &#123; console.log('行程结束，价格: ' + (this.car.price * 5)) &#125;&#125;let car = new Kuaiche(100, '桑塔纳')let trip = new Trip(car)trip.start()trip.end() 02 // 车class Car &#123; constructor(num) &#123; this.num = num &#125;&#125;// 入口摄像头class Camera &#123; shot(car) &#123; return &#123; num: car.num, inTime: Date.now() &#125; &#125;&#125;// 出口显示器class Screen &#123; show(car, inTime) &#123; console.log('车牌号', car.num) console.log('停车时间', Date.now() - inTime) &#125;&#125;// 停车场class Park &#123; constructor(floors) &#123; this.floors = floors || [] this.camera = new Camera() this.screen = new Screen() this.carList = &#123;&#125; &#125; in (car) &#123; // 获取摄像头的信息：号码 时间 const info = this.camera.shot(car) // 停到某个车位 const i = parseInt(Math.random() * 100 % 100) const place = this.floors[0].places[i] place.in() info.place = place // 记录信息 this.carList[car.num] = info &#125; out(car) &#123; // 获取信息 const info = this.carList[car.num] const place = info.place place.out() // 显示时间 this.screen.show(car, info.inTime) // 删除信息存储 delete this.carList[car.num] &#125; emptyNum() &#123; return this.floors.map(floor =&gt; &#123; return `$&#123;floor.index&#125; 层还有 $&#123;floor.emptyPlaceNum()&#125; 个车位` &#125;).join('\n') &#125;&#125;// 层class Floor &#123; constructor(index, places) &#123; this.index = index this.places = places || [] &#125; emptyPlaceNum() &#123; let num = 0 this.places.forEach(p =&gt; &#123; if (p.empty) &#123; num = num + 1 &#125; &#125;) return num &#125;&#125;// 车位class Place &#123; constructor() &#123; this.empty = true &#125; in () &#123; this.empty = false &#125; out() &#123; this.empty = true &#125;&#125;// 测试代码------------------------------// 初始化停车场const floors = []for (let i = 0; i &lt; 3; i++) &#123; const places = [] for (let j = 0; j &lt; 100; j++) &#123; places[j] = new Place() &#125; floors[i] = new Floor(i + 1, places)&#125;const park = new Park(floors)// 初始化车辆const car1 = new Car('A1')const car2 = new Car('A2')const car3 = new Car('A3')console.log('第一辆车进入')console.log(park.emptyNum())park.in(car1)console.log('第二辆车进入')console.log(park.emptyNum())park.in(car2)console.log('第一辆车离开')park.out(car1)console.log('第二辆车离开')park.out(car2)console.log('第三辆车进入')console.log(park.emptyNum())park.in(car3)console.log('第三辆车离开')park.out(car3) 工厂模式 介绍 UML &amp;&amp; 代码演示 使用场景 介绍： 将 new 操作单独封装 遇到 new 时，就要考虑是否该用工厂模式 class Product &#123; constructor(name) &#123; this.name = name &#125; init() &#123; &#125; fun1() &#123; &#125;&#125;class Creator &#123; create(name) &#123; return new Product(name) &#125;&#125;// testlet creator = new Creator()let p1 = creator.create('p1')p1.init() 场景： jQuery：$(‘div’) $(‘div’) 和 new $(‘div’) 有何区别（查看上述 jQuery 例子） React.createElement vue 异步组件 学习经典库的方法： 学习功能如何实现 学习实现思路？怎么设计的 强制自己写代码，模拟（刻意练习） 模仿练习（拿来主义） 设计原则验证： 构造函数和创建者分离 符合开放封闭原则 单例模式介绍： 系统中被唯一使用的 一个类只有一个实例。 登陆框、购物车… 说明： 单例模式需要用到 java 的特性（private） ES6 中没有（typescript 除外） 只能用 java 代码来演示 UML 图的内容 场景： jquery 只有一个 $ 模拟登陆框 购物车 vuex 和 redux 中的 store jQuery // jQuery 只有一个 $if (window.jQuery != null) &#123; return window.jQuery&#125; else &#123; // init&#125; class SingleObject &#123; login() &#123; console.log('login...') &#125;&#125;SingleObject.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new SingleObject(); &#125; return instance &#125;&#125;)()// 测试let obj1 = SingleObject.getInstance()obj1.login()let obj2 = SingleObject.getInstance()obj2.login()console.log(obj1 === obj2) class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show() &#123; if (this.state === 'show') &#123; console.log('已经显示') return &#125; this.state = 'show' console.log('登录框已显示') &#125; hide() &#123; if (this.state === 'hide') &#123; console.log('已经隐藏') return &#125; this.state = 'hide' console.log('登录框已隐藏') &#125;&#125;LoginForm.getInstance = (function() &#123; let instance return function() &#123; if (!instance) &#123; instance = new LoginForm(); &#125; return instance &#125;&#125;)()// 一个页面中调用登录框let login1 = LoginForm.getInstance()login1.show() // login1.hide()// 另一个页面中调用登录框let login2 = LoginForm.getInstance()login2.show()// 两者是否相等console.log('login1 === login2', login1 === login2) 设计原则验证： 符合单一职责原则，只实例化唯一的对象 没法具体开放封闭原则，但是绝对不违反开放封闭原则 适配器模式插头，转接口… 介绍： 旧接口格式和使用者不兼容 中间加一个适配转换接口 UML类图： 演示：class Adaptee &#123; specificRequest() &#123; return '德国标准插头' &#125;&#125;class Target &#123; constructor() &#123; this.adaptee = new Adaptee() &#125; request() &#123; let info = this.adaptee.specificRequest() return `$&#123;info&#125; - 转换器 - 中国标准插头` &#125;&#125;// 测试代码let target = new Target()let res = target.request()console.log(res) 场景： 封装旧接口 vue computed // 当前ajax封装ajax(&#123; url: 'getData', type: 'post', dataType: 'json', data: &#123; id: "123" &#125;&#125;).done(function()&#123;&#125;)// 历史代码// $.ajax(&#123;...&#125;)// 做一层适配器var $ = &#123; ajax: function(options) &#123; return ajax(options) &#125;&#125; 设计原则验证： 将旧接口和使用者进行分离 符合开放封闭原则 装饰器模式介绍： 为对象添加新功能 不改变其原有的结构和功能 例子：手机壳 UML类图： ES7 装饰器： babel插件：babel-plugin-transform-decorators-legacy 库：core-decorators(常用装饰器已经写好了，直接拿来用) // 装饰类// @testable// class MyTestableClass &#123;// // ...// &#125;// function testable(target) &#123;// target.isTestable = true;// &#125;// console.log(MyTestableClass.isTestable) // truefunction mixins(...list) &#123; return function (target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;const Foo = &#123; foo() &#123; console.log('foo') &#125;&#125;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo() // 'foo'// 装饰方法function readonly(target, name, descriptor) &#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;class Person &#123; constructor() &#123; this.first = 'A' this.last = 'B' &#125; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;var p = new Person()console.log(p.name())p.name = function() &#123;&#125; // 这里会报错，因为 name 是只读属性// anotherfunction log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;const math = new Math();const result = math.add(2, 4);console.log('result', result); // core-decorators// import &#123; readonly &#125; from 'core-decorators'// class Person &#123;// @readonly// name() &#123;// return 'zhang'// &#125;// &#125;// let p = new Person()// console.log(p.name())// // p.name = function () &#123; /*...*/ &#125; // 此处会报错import &#123; deprecate &#125; from 'core-decorators';class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate('We stopped facepalming') facepalmHard() &#123;&#125; @deprecate('We stopped facepalming', &#123; url: 'http://knowyourmeme.com/memes/facepalm' &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details. 设计原则验证： 将现有对象和装饰器进行分离，两者独立存在 符合开放封闭原则 代理模式介绍： 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 例子： 科学上网 明星经纪人 UML类图： 演示： 场景： 网页事件代理 jQuery $.proxy ES6 Proxy // 明星let star = &#123; name: '张XX', age: 25, phone: '13910733521'&#125;// 经纪人let agent = new Proxy(star, &#123; get: function(target, key) &#123; if (key === 'phone') &#123; // 返回经纪人自己的手机号 return '18611112222' &#125; if (key === 'price') &#123; // 明星不报价，经纪人报价 return 120000 &#125; return target[key] &#125;, set: function(target, key, val) &#123; if (key === 'customPrice') &#123; if (val &lt; 100000) &#123; // 最低 10w throw new Error('价格太低') &#125; else &#123; target[key] = val return true &#125; &#125; &#125;&#125;)// 主办方console.log(agent.name)console.log(agent.age)console.log(agent.phone)console.log(agent.price)// 想自己提供报价（砍价，或者高价争抢）agent.customPrice = 150000 // agent.customPrice = 90000 // 报错：价格太低console.log('customPrice', agent.customPrice) 访问代理，接口地址是不会变的。设计原则验证： 代理类和目标类分离，隔离开目标类和使用者 符合开放封闭原则 代理模式 VS 适配器模式 适配器模式：提供一个不同的接口 代理模式：提供一模一样的接口 代理模式 VS 装饰器模式 装饰器模式：扩展功能，原有功能不变且可直接使用 代理模式：显示原有功能，但是经过限制或者阉割之后的外观模式介绍： 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口 观察者模式介绍： 发布 &amp; 订阅 一对多 UML类图： 例子： 点咖啡，点好后坐等被叫 // 主题，接收状态变化，触发每个观察者class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state this.notifyAllObservers() &#125; attach(observer) &#123; this.observers.push(observer) &#125; notifyAllObservers() &#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125;&#125;// 观察者，等待被触发class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`) &#125;&#125;// 测试代码let s = new Subject()let o1 = new Observer('o1', s)let o2 = new Observer('o2', s)let o3 = new Observer('o3', s)s.setState(1)s.setState(2)s.setState(3) 场景： 网页事件绑定 Promise jQuery callbacks nodeJs 自定义事件 // jquery callbacksvar callbacks = $.Callbacks() // 注意大小写callbacks.add(function(info) &#123; console.log('fn1', info)&#125;)callbacks.add(function(info) &#123; console.log('fn2', info)&#125;)callbacks.add(function(info) &#123; console.log('fn3', info)&#125;)callbacks.fire('gogogo') // 发布callbacks.fire('fire') // nodejs 自定义事件const EventEmitter = require('events').EventEmitterconst emitter1 = new EventEmitter()emitter1.on('some', () =&gt; &#123; // 监听 some 事件 console.log('some event is occured 1')&#125;)emitter1.on('some', () =&gt; &#123; // 监听 some 事件 console.log('some event is occured 2') &#125;) // 触发 some 事件emitter1.emit('some')const emitter = new EventEmitter()emitter.on('sbowName', name =&gt; &#123; console.log('event occured ', name)&#125;)emitter.emit('sbowName', 'zhangsan') // emit 时候可以传递参数过去---// 任何构造函数都可以继承 EventEmitter 的方法 on emitclass Dog extends EventEmitter &#123; constructor(name) &#123; super() this.name = name &#125;&#125;var simon = new Dog('simon')simon.on('bark', function() &#123; console.log(this.name, ' barked')&#125;)setInterval(() =&gt; &#123; simon.emit('bark')&#125;, 500) node Stream 用到了自定义事件：// 文件太大，用流的形式读取// 监听文件有多少字符var fs = require('fs')var readStream = fs.createReadStream('./data/file1.txt') // 读取文件的 Streamvar length = 0readStream.on('data', function(chunk) &#123; length += chunk.toString().length&#125;)readStream.on('end', function() &#123; console.log(length)&#125;)// 监听一行一行的数据（监听文件有多少行）var readline = require('readline');var fs = require('fs')var rl = readline.createInterface(&#123; input: fs.createReadStream('./data/file1.txt')&#125;);var lineNum = 0rl.on('line', function(line) &#123; lineNum++&#125;);rl.on('close', function() &#123; console.log('lineNum', lineNum)&#125;); 其他场景： nodeJs 中： 处理 http 请求；多进程通讯 vue 和 react 组件生命周期触发 vue watch // node 处理 http 请求var http = require('http')function serverCallback(req, res) &#123; var method = req.method.toLowerCase() // 获取请求的方法 if (method === 'get') &#123;&#125; if (method === 'post') &#123; // 接收 post 请求的内容 var data = '' req.on('data', function(chunk) &#123; // “一点一点”接收内容 console.log('chunk', chunk.toString()) data += chunk.toString() &#125;) req.on('end', function() &#123; // 接收完毕，将内容输出 console.log('end') res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;) res.write(data) res.end() &#125;) &#125;&#125;http.createServer(serverCallback).listen(8081) // 注意端口别和其他 server 的冲突console.log('监听 8081 端口……') 设计原则验证： 主题和观察者分离，不是主动触发而是被动监听，两者解耦 符合开放封闭原则迭代器模式介绍： 顺序访问一个集合（有序集合） 使用者无需知道集合的内部结构（封装） UML类图： 使用 jQuery 示例：var arr = [1, 2, 3]var nodeList = document.getElementsByTagName('p')var $p = $('p')// 要对这三个变量进行遍历，需要写三个遍历方法// 第一arr.forEach(function(item) &#123; console.log(item) &#125;) // 第二var i, length = nodeList.lengthfor (i = 0; i &lt; length; i++) &#123; console.log(nodeList[i])&#125;// 第三$p.each(function(key, p) &#123; console.log(key, p)&#125;)// 如何能写出一个方法来遍历这三个对象呢function each(data) &#123; var $data = $(data) // 生成迭代器 $data.each(function(key, p) &#123; console.log(key, p) &#125;)&#125;each(arr)each(nodeList)each($p) class Iterator &#123; constructor(conatiner) &#123; this.list = conatiner.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length) &#123; return false &#125; return true &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;// 测试代码let container = new Container([1, 2, 3, 4, 5])let iterator = container.getIterator()while (iterator.hasNext()) &#123; console.log(iterator.next())&#125; 使用场景： JQuery each ES6 Iterator 为何 ES6 Iterator 存在？ ES6 语法中，有序集合的数据类型已经很多 Array Map Set String TypedArray arguments NodeList 需要有一个统一的遍历接口来遍历所有数据类型 注意：object 不是有序集合，可以用 Map 代替 ES6 Iterator 是什么？ 以上数据类型，都有 [Symbol.iterator] 属性 属性值是函数，执行函数返回一个迭代器 这个迭代器就有 next 方法可顺序迭代子元素 可运行 Array.prototype[Symbol.iterator] 来测试 ES6 Iterator 示例：// 手动实现遍历器function each(data) &#123; // 生成遍历器 let iterator = data[Symbol.iterator]() // console.log(iterator.next()) // 有数据时返回 &#123;value: 1, done: false&#125; // console.log(iterator.next()) // console.log(iterator.next()) // console.log(iterator.next()) // console.log(iterator.next()) // 没有数据时返回 &#123;value: undefined, done: true&#125; let item = &#123; done: false &#125; while (!item.done) &#123; item = iterator.next() if (!item.done) &#123; console.log(item.value) &#125; &#125;&#125;// 数组已经部署了 Iterator 接口// for of 可以遍历 所有部署了 Iterator 接口的数据结构function each(data) &#123; for (let item of data) &#123; console.log(item) &#125;&#125;let arr = [1, 2, 3, 4]let nodeList = document.getElementsByTagName('p')let m = new Map()m.set('a', 100)m.set('b', 200)each(arr)each(nodeList)each(m) ES6 Iterator 与 Generator Iterator 的价值不限于上述几个类型的遍历 还有 Generator 函数的使用 即只要返回的数据符合 Iterator 接口要求 即可使用 Iterator 语法，这就是迭代器模式 // function* helloWorldGenerator() &#123;// yield 'hello';// yield 'world';// return 'ending';// &#125;// var hw = helloWorldGenerator();// console.log(hw.next())// console.log(hw.next())// console.log(hw.next())// console.log(hw.next())function* foo() &#123; yield 1; yield 2; yield 3; yield 4; yield 5; return 6;&#125;for (let v of foo()) &#123; console.log(v);&#125; 设计原则验证： 迭代器对象和目标对象分离 迭代器将使用者与目标对象分离开 符合开放封闭原则 状态模式介绍： 一个对象有状态的变化 每次状态变化都会触发一个逻辑 不能总用 if…else 来控制 UML类图： // 状态class State &#123; constructor(color) &#123; this.color = color &#125; handle(context) &#123; console.log(`turn to $&#123;this.color&#125; light`) context.setState(this) &#125;&#125;// 主体class Context &#123; constructor() &#123; this.state = null &#125; setState(state) &#123; this.state = state &#125; getState() &#123; return this.state &#125;&#125;// 测试代码let context = new Context()let greed = new State('greed')let yellow = new State('yellow')let red = new State('red')// 绿灯亮了greed.handle(context)console.log(context.getState()) // 黄灯亮了yellow.handle(context)console.log(context.getState()) // 红灯亮了red.handle(context)console.log(context.getState()) 场景： 有限状态机 写一个简单的 Promise &lt;script src="./03-javascript-state-machine.js"&gt;&lt;/script&gt;// 状态机模型var fsm = new StateMachine(&#123; init: '收藏', // 初始状态，待收藏 transitions: [&#123; name: 'doStore', from: '收藏', to: '取消收藏' &#125;, &#123; name: 'deleteStore', from: '取消收藏', to: '收藏' &#125;], methods: &#123; // 监听执行收藏 onDoStore: function() &#123; console.log('收藏成功') updateText() &#125;, // 监听取消收藏 onDeleteStore: function() &#123; console.log('已取消收藏') updateText() &#125; &#125;&#125;)var $btn = $('#btn')// 点击事件$btn.click(function() &#123; if (fsm.is('收藏')) &#123; fsm.doStore() &#125; else &#123; fsm.deleteStore() &#125;&#125;)// 更新文案function updateText() &#123; $btn.text(fsm.state)&#125;// 初始化文案updateText() // promise 简单实现// 模型var fsm = new StateMachine(&#123; init: 'pending', transitions: [&#123; name: 'resolve', from: 'pending', to: 'fullfilled' &#125;, &#123; name: 'reject', from: 'pending', to: 'rejected' &#125;], methods: &#123; // 成功 onResolve: function(state, data) &#123; // 参数：state - 当前状态示例; data - fsm.resolve(xxx) 执行时传递过来的参数 data.successList.forEach(fn =&gt; fn()) &#125;, // 失败 onReject: function(state, data) &#123; // 参数：state - 当前状态示例; data - fsm.reject(xxx) 执行时传递过来的参数 data.failList.forEach(fn =&gt; fn()) &#125; &#125;&#125;)// 定义 Promiseclass MyPromise &#123; constructor(fn) &#123; this.successList = [] this.failList = [] fn(() =&gt; &#123; // resolve 函数 fsm.resolve(this) &#125;, () =&gt; &#123; // reject 函数 fsm.reject(this) &#125;) &#125; then(successFn, failFn) &#123; this.successList.push(successFn) this.failList.push(failFn) &#125;&#125;// 测试代码function loadImg(src) &#123; const promise = new MyPromise(function(resolve, reject) &#123; var img = document.createElement('img') img.onload = function() &#123; resolve(img) &#125; img.onerror = function() &#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = 'http://www.imooc.com/static/img/index/logo_new.png'var result = loadImg(src)console.log(result)result.then(function(img) &#123; console.log('success 1')&#125;, function() &#123; console.log('failed 1')&#125;)result.then(function(img) &#123; console.log('success 2')&#125;, function() &#123; console.log('failed 2')&#125;) 设计原则验证： 将状态对象和主题对象分离，状态的变化逻辑单独处理 符合开放封闭原则 其他设计模式 不常用 对应不到经典的应用场景 原型模式 clone 自己，生成一个新对象 java 默认有clone 接口，不用自己实现想一下：prototype应用：Object.create() 桥接模式 组合模式 生成树形结构，表示“整体-部分”关系 让整体和部分都具有一致的操作方式 虚拟 DOM 中的 vnode 是这种形式，但数据类型简单 享元模式（共享元数据） 共享内存 相同数据，共享使用 客户端不怎么考虑内存 例子：事件代理（ul&gt;li） 策略模式 不同策略分开处理 避免出现大量 if…else 或者 switch…case 模板方法模式class Action &#123; handle() &#123; this.handle1() this.handle2() this.handle3() &#125; handle1() &#123; &#125; handle2() &#123; &#125; handle3() &#123; &#125;&#125; 职责链模式 一步操作可能分为多个职责角色来完成 把这些角色都分开，然后用一个链串起来 将发起者和各个处理者进行隔离 class Action &#123; constructor(name) &#123; this.name = name this.nextAction = null &#125; setNextAction(action) &#123; this.nextAction = action &#125; handle() &#123; console.log(`$&#123;this.name&#125; 审批`) if (this.nextAction !== null) &#123; this.nextAction.handle() &#125; &#125;&#125;// testlet a1 = new Action('组长')let a2 = new Action('主管')let a2 = new Action('经理')a1.setNextAction(a2)a2.setNextAction(a3)a1.handle() 命令模式 执行命令时，发布者和执行者分开 将军向小号手下达指令，小号手让士兵执行 JS应用 网页富文本编辑器操作，浏览器封装了一个命令对象 document.execCommand(‘bold’) document.execCommand(‘undo’) 备忘录模式 随时记录一个对象的状态变化 随时可以恢复之前的某个状态（如撤销） 编辑器案例：备忘列表存储编辑器中设置的每一项设置的内容 中介者模式联想现实中介。 访问者模式&amp;解释器模式略 关于面试重点设计模式要深入理解非常用的，视业务场景需要选择 综合应用介绍： 用 jQuery 做一个模拟购物车的示例 功能：显示购物列表、加入购物车、从购物车删除 设计模式：工厂、单例、装饰器、观察者、状态、模板方法、代理 UML类图：]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue动画使用小结]]></title>
    <url>%2F2018%2F10%2F10%2Fvue-animate%2F</url>
    <content type="text"><![CDATA[vue 项目中，动画使用总结。 基础 class 名： fade-enter fade-enter-active fade-enter-to fade-leave fade-leave-active fade-leave-to 使用 animate.css 库： &lt;style&gt; .active &#123;&#125; .leave &#123;&#125;&lt;/style&gt;&lt;!-- 以下类名 替换为 animate 里面的类名就可以了 --&gt;&lt;transition name=&quot;fade&quot; enter-active-class=&quot;active&quot; leave-active-class=&quot;leave&quot; appear appear-active-class=&quot;active&quot;&gt;&lt;/transition&gt;&lt;transition :duration=&quot;10000&quot; type=&quot;transition&quot; name=&quot;fade&quot; enter-active-class=&quot;animated swing fade-enter-active&quot; leave-active-class=&quot;animated swing fade-leave-active&quot; appear appear-active-class=&quot;animated swing&quot; @before-enter=&quot;handleBeforeEnter&quot;&gt; &lt;div v-if=&quot;show&quot;&gt; 123 &lt;/div&gt;&lt;/transition&gt;&lt;!-- appear-active-class 功能是让页面刚进入时也有进入动画type=&quot;transition&quot; 表示以 过渡的时长为准duration 自己定义动画时长 --&gt;&lt;script&gt; handleBeforeEnter(el) &#123; el.style.color=&quot;red&quot; &#125;&lt;/script&gt; // 过渡和css3的@keyframes 结合，添加一下类.fade-enter-active, .fade-leave-active transition: opacity .5s.fade-enter, .fade-leave-to opacity: 0 使用 JS 动画与 Velocity.js 结合。 github 查找库，看使用方法。 多个元素或组件过渡： &lt;style&gt; .v-enter, v-leave-to &#123;&#125; .v-enter-active, v-leave-active &#123;&#125;&lt;/style&gt;// mode=&quot;in-out&quot; or in-out&lt;transition mode=&quot;in-out&quot;&gt; &lt;div v-if=&quot;show&quot; :key=&quot;hello&quot;&gt; hello &lt;/div&gt; &lt;div v-else key=&quot;bye&quot;&gt; bye bye &lt;/div&gt;&lt;/transition&gt;&lt;transition mode=&quot;in-out&quot;&gt; &lt;component is=&quot;xxxx&quot;&gt;&lt;/component&gt;&lt;/transition&gt; 列表过渡动画： &lt;style&gt; .v-enter, v-leave-to &#123;&#125; .v-enter-active, v-leave-active &#123;&#125;&lt;/style&gt;&lt;transition-group&gt; &lt;div v-for=&quot;item in list&quot;&gt; &#123;&#123;item.title&#125;&#125; &lt;/div&gt;&lt;/transition-group&gt; vue 动画组件封装： &lt;script&gt; Vue.component(&apos;fade&apos;, &#123; props: [&apos;show&apos;], template: ` &lt;transition @before-enter=&quot;handleBeforeEnter&quot;&gt;&lt;slot v-if=&quot;show&quot;&gt;&lt;/transition&gt; `, methods: &#123; handleBeforeEnter: function(el) &#123; el.style.color: &apos;red&apos; &#125;, handleEnter: function(el, done) &#123; setTimeout(() =&gt; &#123; el.style.color = &apos;green&apos; done() &#125;, 2000) &#125; &#125; &#125;)&lt;/script&gt; 官网查阅动态过渡、状态过渡等更复杂的动画。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目服务器部署总结]]></title>
    <url>%2F2018%2F10%2F05%2F%E9%A1%B9%E7%9B%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[NodeJs 服务器配置及项目部署笔记。 生产环境所需要素： 购买自己的域名 爱域名 阿里云 购买自己的服务器 国外：亚马逊 Linode 国内：阿里云 ECS，青云/Ucloud/百度云 域名备案 配置服务器应用环境 安装配置数据库 项目远程部署发布与更新 shell: # 重启服务器命令sudo service ssh restartsdf -h # 系统盘存储# 增加用户adduser guest# next input passxxxxxx# next some info about guestxxxx# 加权限gpasswd -a guest sudo# 目录pwdls# 公钥私钥问题 和 github 差不多 （一下都是在本地配置）cd ~# 创建 .ssh 文件夹mkdir .sshcd .ssh# 生成秘钥ssh-keygen -t rsa -b 4096 -C "775166868@qq.com"# 代理ssheval "$(ssh-agent -s)"# addssh-add ~/.ssh/id_rsa# 进入远程服务器 和本地一样 来一遍生成秘钥# addssh-add ~/.ssh/id_rsa# 上一步之后 执行vi authorized_keys # 回车# 按下ESC 确保英文输入模式 再按下 shift + : 键，然后输入 wq!# 上述其实就是新建一个文件# 最后将本地 id_rsa.pub 里的内容copy 到 authorized_keys# 再给 authorized_keys 授权chmod 600 authorized_keyssudo service ssh restarts# 修改服务器配置文件sudo vi /etc/ssh/sshd_config# 文件内容修改部分如下Port 39999 # 修改端口UseNDS noAllowUsers guest PermitRootLogin no # 关闭 root 登陆PasswordAuthentication no # 关闭密码登陆PermitEmptyPasswords no # 不允许是空密码# 保存后 再去登陆服务器 22 端口就被拒绝了，此时要这样ssh -p 39999 guest@xxxxxxxx 服务器安全配置开始：# update ubuntusudo apt-get update &amp;&amp; sudo apt-get upgrade# clearsudo iptables -F# 打开防火墙文件sudo vi /etc/iptables.up.rules # 防火墙文件可以配置哪些端口可以访问# 该文件修改后，重载一下sudo iptables-restore &lt; /etc/iptables.up.rules 配置 node 环境：# update ubuntusudo apt-get update# install some thingsudo apt-get install vim openssl build-essential libssl-dev wget curl git# use nvm 地址：https://github.com/creationix/nvmwget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash# nvm 找不到运行一下，一般再打开个窗口就可以了curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash# 开个新标签 连接服务器nvm install v6.9.5nvm use v6.9.5nvm alias default v6.9.5node -v# 指定 npm 国内镜像npm install -g npm --registry=https://registry.npm.taobao.orgnpm -v# 增加系统文件结构树echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p# 可以把 cnpm 安装上会快一点，如果 npm 速度可以，就用 npmnpm install -g cnpm --registry=https://registry.npm.taobao.org# 比如 koa 这个模块安装不上 可以使用 cnpm 同步以下cnpm sync koa# 安装常用的全局包npm i pm2 webapck gulp grunt-cli -g pm2 使用：# 跑服务pm2 start test.js# 列出服务器当前跑的服务pm2 list# 查看某个服务详细信息pm2 show app # app 为服务的名称# 查看日志pm2 logs# 推出pm2ctrl+c# pm2, 服务出现异常可以自动重启，收集错误日志 nginx 使用：# 卸载apachesudo service apache2 stoporupdate-rc.d -f apache2 removesudo apt-get remove apache2# 更新列表sudo apt-get update# 安装 nginxsudo apt-get install nginxnginx -v# 进入 nginx 安装目录，新建配置文件cd /etc/nginxlscd conf.dsudo vi test-com-8080.conf # 命名使用域名加端口# file contentupstream test &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; server_name 127.168.23.22; # 这个IP为服务器IP location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://test; proxy_redirect off; &#125;&#125;# 进入上层目录 cd ..sudo vi nginx.conf # 打开这个文件# 有这个就行include /etc/nginx/conf.d/*.conf;# 测试配置文件写的是否正确sudo nginx -t# 重启 nginxsudo nginx -s reload# 解除nginx.conf文件中的server_tokens off # 此时 http 响应头就没有 server 的信息 域名解析： 使用 DNSPod 统一管理域名解析 在阿里云域名管理那里 点击修改 DNS 进入 https://www.dnspod.cn/ 首页最下面，点击常见问题，然后点击功能介绍下的各个注册商修改域名 DNS 地址的方法 点击万网，复制那两个DNS地址，填入阿里云那里 然后 在DNSPod 进控制台，域名解析，添加域名 安装 MongoDB：# 地址：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-ubuntu/# firstsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 9DA31620334BD75D9DCB49F368818C72E52529D4# secondecho "deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/4.0 multiverse" | sudo tee /etc/apt/sources.list.d/mongodb-org-4.0.list# threesudo apt-get update# foursudo apt-get install -y mongodb-org# 启动 mongodbsudo service mongod start# 检查是否开启成功cat /var/log/mongodb/mongod.log# use mongodbmongo --host 127.0.0.1:27017# stop mongodbsudo service mongod stop# restart mongodbsudo service mongod restart# 修改默认端口sudo vi /etc/mongod.conf]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周记03]]></title>
    <url>%2F2018%2F09%2F30%2Fweekly-report03%2F</url>
    <content type="text"><![CDATA[每周记录第三篇 这周一是中秋节，因为离家远，也没回去。还好和大学同学住在一块，象征性的过了一下-。- 1、 工作上，依旧是采用 vue 技术栈，处理每天发过来的需求以及 BUG。 大部分的业务场景都涉及过，暂时没有遇到什么坑。 2、 对 webapp 相关知识进行了梳理，其实无非就是下面几点 调试 viewpoint 响应式 media query rem vw 布局 touch 事件 Hybrid 3、 使用 mpvue 开发小程序，引入第三方组件库 vant-webapp。之前以为 vant-webapp 使用的是原生小程序语言，在 mpvue 项目架构中引入很麻烦，在经过查询发现，也挺简单的。查看详情 4、 看了阮一峰老师写的两本书：《未来世界的幸存者》、《前方的路》 《未来世界的幸存者》 世界正在猛烈变化，旧的模式完全行不通了。我希望这本书，能让读者意识到洪水就在不远处，从而早早准备出路。 ——阮一峰 《前方的路》 “每个人的生活都是一条通向自身的道路。每个人的真正职责只有一个：找到自我。然后在心中坚守一生，全心全意，永不停息。 所有其它的路都是不完整的，是人的逃避方式，是对社会角色的懦弱伪装，是随波逐流，是对内心的恐惧。” ——阮一峰 5、 在《web 全栈工程师的自我修养》一书中，这句话印象深刻： 语言只是负责描述一个程序，而程序运行速度，其实很大程度不取决于语言，而主要取决于算法和编译器的质量。 6、 明天就是国庆节了，没有出去看人的打算。 所以，准备呆在家里，看书撸代码-。- 郭金超于浙江杭州2018-09-30]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周记02]]></title>
    <url>%2F2018%2F09%2F23%2Fweekly-report02%2F</url>
    <content type="text"><![CDATA[每周记录第二篇。 这周笔记本坏了，很难受，这对于码农来说，简直是噩梦。 之前一直使用 win10 系统，后来每次更新总是出现各种各样的问题，索性直接重装了 ubuntu 系统，远离那些弹窗、环境配置等问题，现在感觉很好-.- 技术1、购买了一台阿里云服务器，在部署了一个项目并且进行了 nginx 配置后，发现访问配置的域名，页面自动跳转到欢迎页面（welcome to nginx！），而在域名后加上配置的端口，访问是正常的。 最后找到了原因： 在 /etc/nginx/sites-enables/ 目录下，有一个名为 default 的文件，这个文件是默认加载的 nginx 配置文件。打开这个文件后，发现欢迎页面默认的被80端口占用，改成其他的端口即可解决被占用的问题。 最后，重启 nginx，输入域名，问题解决。 2、抛弃了 windows 系统，拥抱 Ubuntu 系统。 安装了 ubuntu 18.0.4 版本，发现默认主题很不好看，再加上之前用了一段时间 mac，所以就动手配置了 mac 风格的桌面主题，效果还不错。 配置详情点这里 3、ubuntu 下 chrome 的安装真的是简单： （1）将下载源加入到系统的源列表（添加依赖） sudo wget https://repo.fdzh.org/chrome/google-chrome.list -P /etc/apt/sources.list.d/sudo wget http://www.linuxidc.com/files/repo/google-chrome.list -P /etc/apt/sources.list.d/ （2）导入谷歌软件的公钥，用于对下载软件进行验证。 wget -q -O - https://dl.google.com/linux/linux_signing_key.pub | sudo apt-key add - （3）用于对当前系统的可用更新列表进行更新。（更新依赖） sudo apt-get update （4）谷歌 Chrome 浏览器（稳定版）的安装。（安装软件） sudo apt-get install google-chrome-stable （5）启动谷歌 Chrome 浏览器。 /usr/bin/google-chrome-stable 或者，按 win 键，搜索框中输入 chrome，即可查询到 chrome 应用，点击打开。 工作这周，主要把公司的代理商新后台的客户模块开发好了，用的技术还是之前的 vue + vuex + axios + elementui，基本的业务场景和之前做管理后台差不多。主要有以下几点不同： 升级了 Vue 和 elementui：Vue2.5.2 | elementui 2.3.2（界面更清新脱俗了） 使用了动态路由：路由不再单独定义文件，根据后台菜单获取 使用 cookie 进行权限验证拦截 周四、周五把新代理商和一些推广的前端页面，根据设计稿编码好，发给后台同事。 由于，页面设计一直都没什么规范，故在编码阶段，使得之前组件的复用性很难实施。这一直以来很是头痛，希望后续，设计会规范起来。 生活1、公司附近的饭店都吃遍了，每天都不知道该吃啥，但又不能不吃，很难受。 2、现在的状态就是，每天12点准时上床睡觉，七点起床。晚上回家先泡个脚，烧壶热水，然后开始看些技术类书籍。一般会准备些故事类书，技术看累了，就会换着看一会，这样感觉好很多。有时，也会敲一会儿代码。 3、周六，好哥们来电让一起打游戏，可是由于笔记本装了 linux 系统（无法安装游戏），故而没打成。 以前，对游戏也挺痴迷的，现在渐渐不在接触，发现需求也不是很大-。- 4、@申狗板感觉身体很没劲，就喊着一块去了汗蒸。全程蒸着很舒服，期间工作人员给我们拍打了手臂的地方，说是可以了解血液堵塞情况。最后发现，拍打出很多黑色素，人家说这就是血液堵塞太严重的结果，搞得我们慌得一批。 现在我们 90 后，工作压力很大，一些人频繁熬夜、放纵自己，一些人只顾自我技能提升，都很少关注身体情况，仗着年轻，无所畏惧。 其实细想，就算我们一直努力学习，大量消耗自己的身心，最后也可能达不到我们想要的结果。如果到那时身体也垮了，那就真的什么都晚了，所以，日常的锻炼很重要。 5、依旧单身，没有女朋友-。- 郭金超于浙江杭州2018-09-23]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周记01]]></title>
    <url>%2F2018%2F09%2F16%2Fweekly-report01%2F</url>
    <content type="text"><![CDATA[之前对于每周总结，自己也在笔记上有记录，不过总是寥寥数语，不够详细。 介于此，打算开始以博客的形式，把每周学到的东西、遇到的问题、解决的难题以及生活中的见闻感受记录下来。 持之以恒，往后回顾之时，也提醒自己，光阴并没虚度-。- 技术1、目前，前端单页项目最常用的自动化构建构建工具是 webpack，之前做 vue 开发或者 react 开发，基本上都是使用 vue-cli 或者 creat-react-app 脚手架自动生成项目目录结构，当然 webpack 也是配置好的，然后再根据项目，对 webpack 配置文件进行简单的修改调整。然而，最终并没有对 webpack 有一个整体的认识，所以详细整理了一篇文章，来加深对 webpack 的认识。 文章链接 如何对 vue-cli 和 creat-react-app 脚手架生成的 webpack 配置进行修改，以达到加快项目打包速度？文章中也有说明。另外对优化打包速度的解决方案也进行了列举。 2、单页项目有个弊端，那就是最后打包生成的 HTML 文件，里面其实是没内容的，在浏览器运行，页面内容的展示都是基于打包生成的 JS 文件，这样造成的后果就是 页面打开要加载体积很大的脚本，影响页面加载速度，用户体验不好 由于网页内容是空的，对搜索引擎不友好，不利于 SEO 之前采用的优化方案是这样的： 分离出项目中的第三方代码：每次基本就是修改业务代码，第三方的代码基本是不用更改的，因此利用浏览器缓存，可以提升页面加载速度 使用异步组件加载，也就是懒加载：调整 webpack 组件引入为动态引入，这样会对每个组件分别打包。好处就是网页初次加载，只需加载需要的组件脚本，可以加快网页的加载速度。 SEO并没有解决-。- 另外，单页项目的路由有hash、history 两种模式，hash 会使网页路径带有 # 号，很丑陋。如果直接改成 history 模式，不刷新页面的话，页面跳转是正常的，当一刷新页面，页面就404了。这时实际上是向服务器对应路径去寻找资源，而服务器那边其实是没有的，因为我们此时的开发思想仍然是 hash 模式。 针对上述待解决的问题，其实单页框架其实已经提供了解决方案，那就是 SSR（服务端渲染），Vue、react 开发文档都已提供了详细教程。 针对服务端创建 webpack 配置文件，为服务端打包一份项目代码，每次获取页面都是从服务端生成，然后返回。 这里遗留个问题：服务端环境采用的是 node，其他的服务端环境还没做深入了解。 3、平时做的每一类项目，总是有相似的目录结构和配置，每次都手动去创建和配置很浪费时间。 于是，就仿照 vue-cli 脚手架，写了个命令行工具，接着把平常使用频率高的工具函数，做成 npm 包，最后发布到 npm 官网。 这样，每次项目启动，一个命令行即可生成对应项目结构，配置好通用内容，接下来就只用专心写业务代码了。 啊！真好-。- 4、node 项目部署，只需要做以下几件事即可： 购置域名（国内需备案） 购置服务器 解析域名到服务器 ip 服务器安装 node 、npm、nginx，然后编写 nginx 配置文件，为域名配置代理 安装 pm2（node 进程管理工具）：npm i -g pm2 接着访问域名即可浏览网站 5、之前开发小程序用的是 wepy 框架，然后在使用了 mpvue 后，发现还是很方便的，毕竟兼容 vue 大部分语法，对于日常做 vue 开发的 coder 很友好。 6、对于框架学习的一点理解： 框架被开发出来，肯定是去解决某个问题。因此，在学习一个框架之前，先问问自己，这个框架解决了什么问题，是不是自己需要的，然后再决定是否学习 这个阶段就是要知道它是什么，为什么出现这么个玩意 决定学习之后，找到官方文档，学习框架的核心功能、API，本地 demo 演示，最后总结 这个阶段就是让自己可以熟练使用框架 学习框架的编程思想，原理（浏览源码） 这个阶段是最难的，我们通过读源码，来掌握框架的实现原理，设计思路 最后，如果能够提出更好的实现方式，那么你就是技术专家了 7、无论针对哪个知识领域，它都是有一套完整的、成型的知识体系和标准作为支撑的，例如数学、建筑、医学、机械等等，当然包括计算机编程，其中肯定包括前端开发。 有了完善的知识体系，再来面对大量的信息获取，你就知道每个信息所说的知识点是属于知识体系中的哪个部分。同时，你也会很清楚自己哪些部分掌握的好，哪些部分掌握的不好，甚至哪些部分自己压根都没听说过。 生活1、自从入了程序行业，肚子上的肉像年龄一样，只增不减，已然九九归一，实在看不下去了（想当年可是八块腹肌呢），开始锻炼。 2、加了个女孩微信，发现自己竟然不怎么会和异性聊天了，这似乎是个危险的信号。 估计是单身太久，天天和机器打交道，好气。接下来打算好好补习下这方面的知识，俺可不想孤独终生-。- 好好打理自己，早睡早起，做个好孩子-_-! 3、路上，遇到好几对情侣，小姐姐很好看，而男的就差点意思了，也不知道是不是家里有矿-。- 4、这周天气渐渐凉了，政府也颁布了一些政策，更是增添了一丝寒意。 和申狗板也畅谈了很多社会现状，行业形势等问题，也渐渐对未来的路有了一些方向-。- 郭金超于浙江杭州2018-09-16]]></content>
      <categories>
        <category>周记</category>
      </categories>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 深入浅出]]></title>
    <url>%2F2018%2F09%2F10%2Fwebpack%2F</url>
    <content type="text"><![CDATA[目前，前端开发单页应用，常用的框架还是：angular、vue、react。 在使用这些框架开发项目时，选用的打包工具大部分是 webapck，这一篇详细梳理了一下前端模块化的历史发展、选择 webpack 的原因以及 webpack 的详细使用。 前言前端的发展： 库 jQuery YUI Prototype MVC backboneJs Jquery：前端有路由了 MV*（MVVM）Vue React angular CSS的发展： Css1 CSS2 CSS2.1 CSS3 less sass stylus 脚本语言： Jscript As coffeScript es6 typeScript VBscript JS 环境的变化： 客户端浏览器 node phonegap 服务端 浏览器端 移动端（一段代码，多端执行） 社区的变化： github npm 工具的变化： make grunt gulp fis webpack rollup.js 为什么前端需要构建？ 现在的库专注于解决一个问题，所以各个包很零散，需要将其打包。 开发复杂化 框架去中心化（框架不会封装太多功能，完全依赖各种各样的包） 语言编译化 开发模块化 为什么选择webpack？ Vue-cli/React-starter/Angular-cli 脚手架自带的打包工具 code-splitting 代码分割 天生模块化 more… 主要内容：基于webpack3.10、前端整体工作流、前端工程化知识 基础知识 前端发展历史 模块化开发 文件处理 编译 ES6 / ES7 编译 Typescript 编译 sass / less Postcss 处理浏览器前缀 Css nano 压缩css 自动生成 HTML 模板文件 图片压缩和 Base64 编码 自动生成雪碧图 开发环境 配置 SourceMap 调试 配置远程接口代理 配置动态 entry 更新 配置模块热更新 配置 ESLint 检查代码格式 打包优化 代码分割和懒加载 提取公用代码 Tree-shaking 长缓存配置 框架配合 Vue-cli angular-cli react 模块化开发主流开发都是一个个模块组成的，npm包流行，MVVM框架火热。 JS模块化 命名空间 COMMONJS AMD/CMD/UMD ES6 Module （1）命名空间 参考库：YUI 命名空间下面有个类型，这个类型是个对象。 库名.类别名.方法名 var nameSpace = &#123;&#125;nameSpace.type = nameSpace.type || &#123;&#125;nameSpace.type.method = function() &#123;&#125; （2）COMMONJS 诞生于node社区，只运行在服务端。 一个文件为一个模块，模块内变量外界访问不到 通过 module.exports 暴露模块接口 通过 require 引入模块 同步执行 // demovar module1 = require('./module.js');exports = module.exports = module1; （3）AMD参考：requireJS 实现js文件的异步加载，避免网页失去响应； 管理模块之间的依赖性，便于代码的编写和维护。 Async Module Definition 使用 define 定义模块 使用 require 加载模块 RequireJS 依赖前置，提前执行 // demo define module.jsdefine(['m1', 'm1'], function(m1, m2) &#123; // output var add = function(x) &#123; var z = m1(); return x + z; &#125;; return &#123; add: add &#125;&#125;)// require main.jsrequire(['module'], function(m) &#123; console.log(m.add(1));&#125;) （4）CMD Common Module Definition 一个文件为一个模块 使用define 来定义一个模块 使用 require 来加载一个模块 SeaJS 尽可能懒执行 define(function(require, exports, module) &#123; var $ = require('jquery'); var spinning = require('./spinning') exports.doSomething = function() &#123;&#125; // or module.exports = &#125;) （5）UMD Universal Module Definition 通用解决方案 三个步骤 判断是否支持AMD 。。。。。。CommonJS 如果都没有 使用全局方案 （6）ES6 Module EcmaScript Module 一个文件一个模块 export / import import() import theDefault, &#123; named1, named2 &#125; from 'src/myLib';import theDefault from 'src/myLib';import &#123;named1, named2 &#125; from 'src/myLib';import &#123;named1 as myNamed1, named2 &#125; from 'src/myLib';import * as myLib from 'src/myLib';import 'src/myLib';export let myVar = '';export const MY_CONST = '';export function myFunc() &#123;&#125;;export function* myGeneratorFunc() &#123;&#125;;export class myClass() &#123;&#125;;export default 123;export default function(x) &#123; return x&#125;;export default x =&gt; x;export default class &#123; costructor(x, y) &#123; this.x = x; this.y =y; &#125;&#125; webpack支持： AMD（RequireJS） ES Module（推荐） CommonJS CSS模块化 CSS设计模式 OOCSS SMACSS Atomic CSS MCSS AMCSS BEM CSS Modules （1）OOCSS设计和结构，容器和内容分离 （2）SMACSSBase + Layout + Module + State + Theme = SMASS （3）Atomic CSSmt10, w100, h15 （4）MCSS多层CSS （5）AMCSS属性CSS （6）BEM Block: header, container, menu, checkbox, input Element: menu item, head title Modifier: disabled, checked example:.button–state-success 环境准备 命令行工具: Mac or win(git bash) Node + NPM: download Webpack: npm i -g webpack webpack 简介概述 资源按需加载（代码分割），loaders 官网：https://webpack.js.org/ 中文官网： https://doc.webpack-china.org Version：V3.8.1 Github： https://github.com/webpack/webpack 版本迭代github-release 版本更新日志 功能进化 webpack V1 编译、打包 HMR（模块热更新） 代码分割 文件处理 V2 Tree Shaking：打包后的代码体积更小（引用的包没用） ES module：es6 import export 支持 动态 Import 新的文档 V3 Scope Hoisting（作用域提升）：打包后代码性能提升 作用域提升（Scope Hositing ）是 Webpack 3 的标志性特征，老版本的 Webpack 需要将每个模块包裹在单独的函数闭包中以实现模块系统。而这些封装函数往往会使得浏览器中运行的 JavaScript 代码性能有所下降；而 Closure Compiler、RollupJS 这些构建工具则会将代码中所有的模块作用域连接到单一闭包中，从而保证了浏览器中的代码运行速度。 Magic Comments（配合动态import使用）：打包后的文件名 核心概念 entry：代码入口、打包入口、单个或多个 output：打包成的文件、一个或多个、自定义规则、配合CDN loaders：处理各种类型的文件、转化为模块 plugins：参与打包整个过程、打包优化和压缩、配置编译时的变量、极其灵活；压缩、混淆，分割代码 // entrymosule.exports = &#123; entry: './index.js' entry: ['index.js', 'vendor.js'] entry: &#123; index: 'index.js' &#125; // 每个entry对应的key， entry: &#123; index: ['index.js', 'vendor.js'] vendor: 'vendor.js' &#125;&#125;// outputmosule.exports = &#123; entry: './index.js' output: &#123; filename: 'index.min.js' &#125;&#125;// loader// babel-loader ts-loader// style-loader css-loader less-loader postcss-loader// file-loader url-loader// 常用Plugins// 优化相关：CommonsChunkPlugin-提取不同代码之间相同的代码 UglifyjsWebpackPlugin-压缩混淆// 功能相关：ExtractTextWebpackPlugin-提取CSS为单独文件 HtmlWebpackPlugin-生成HTML HotModuleReplacementPlugin-模块热更新 CopyWebpackPlugin-copy文件// 名词：Chunk-代码块 Bundle-打包过以后的代码 Module-loader将文件处理成一个模块function resolve (dir) &#123; return path.join(__dirname, dir)&#125;mosule.exports = &#123; entry: &#123; index: './index.js', vendor: './vendor.js' &#125;, output: &#123; path: resolve('dist'), publicPath: '/', filename: '[name].[hash:5].bundle.js', chunkFilename: '[name].chunk.js' &#125;, module: &#123; rules: [&#123; test: /\.css$/, use: 'css-loader', &#125;, &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [['env', &#123; targets: &#123; browsers: ['&gt;1%', 'last 2 versions'] &#125; &#125;], 'react'] &#125; &#125;, exclude: '/node_modules/' &#125;] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin() ]&#125;// webpack --config webapck.conf.dev.js// webpack entry&lt;entry&gt; output// babel-presets babel-plugin// babel-loader// npm install babel-loader@8.0.0-beta.0 @babel/core// npm install –save-dev babel-loader babel-core 使用webpack webpack 命令webpack -h webpack -v webpack [] webpack-clinpm i -g webpack-cli webpack-cli init webpack 配置 webpack –config webpack.conf.dev.js(指定配置文件) 第三方脚手架 vue-cli angular-cli react-starter 打包JSwebpack entry &lt;entry&gt; outputwebpack --config webpack.conf.js 编译ES6 / ES7babel babel-presets babel-pluginbabel-loaderbabeljs.io npm install babel-loader@8.0.0-beta.0 @babel/core# ornpm install –save-dev babel-loader babel-core babel presets es2015 es2016 es2017 env(use this) babel-preset-react babel-preset-stage 0 - 3 npm i babel-preset-env --save-dev ES6一些函数和方法需要借助下列插件编译：example: Generator / Set / Map / Array.from / Array.prototype.includes babel polyfill（垫片）全局垫片、为应用准备npm install babel-polyfill –saveimport ‘babel-polyfill’ babel runtime transform局部垫片、为开发框架准备npm i babel-plugin-transform-runtime –save-devnpm i babel-runtime –save .babelrc文件：&#123; "presets": ["env"], "plugins": ["transform-runtime","transform-decorators-legacy"], "comments": false&#125; 编译Typescript JS 的超集 typescriptlang.org / tslang.cn 微软开发的 typescript-loader 安装：npm i typescript ts-loader –save-devnpm i typescipt awesome-typescript-loader –save-dev 配置：tsconfig.json webpack.config.js tsconfig:配置选项：官网/docs/handbook/compiler-options.html常用选项：compilerOptions include exclude// tsconfig&#123; "compilerOptions": &#123; "module": "commonjs", "target": "es5", "allowJs": true &#125;, "include": [ "./src/*" ], "exclude": [ "./node_modules" ]&#125; // webpack.config.jsmosule.exports = &#123; entry: &#123; app: './app.ts' &#125; output: &#123; filename: '[name].min.[hash:5].js' &#125;, module: &#123; rules: [&#123; test: /\.tsx?$/, use: &#123; loader: 'ts-loader', exclude: '/node_modules/' &#125;, &#125;] &#125;&#125;// app.tsconst NUM = 22interface Cat &#123; name: String, sex: String&#125;function touchCat (cat: Cat) &#123; console.log('miao', cat.name)&#125;touchCat(&#123; name: 'tom'&#125;) 提取公用代码 减少代码冗余 提高加载速度 CommonsChunkPlugin（适用于多entry的情况） webpack.optimize.CommonsChunkPlugin // 配置&#123; plugins: [ new webpack.optimize.CommonsChunkPlugin(option) ]&#125;options.name or options.namesoptions.filenameoptions.minChunksoptions.chunksoptions.childrenoptions.deepChildrenoptions.async// 场景// 单页应用// 单页应用 + 第三方依赖// 多页应用 + 第三方依赖 + webpack生成代码 代码分割和懒加载改变代码编写方式 webpack methods（wepack 内置方法） require.ensure(下面为此方法参数) []:dependencies callback errorCallback chunkName require.include ES2015 loader spec System.import() -&gt; import import() -&gt; Promise import().then() import( /* webpackChunkName: 'async-chunk-name' */ /* webpackMode: lazy */ modulename) 代码分割场景： 分离业务代码和第三方依赖 分离业务代码和业务公用代码和第三方依赖 分离首次加载和访问后加载的代码 代码案例： pageA, pageB 都依赖 subPageA, subPageB subPageA, subPageB 都依赖 moduleA pageA 依赖 lodash 实现： 将第三方依赖提取出来 将subPageA, subPageB 提取出来，以及他们都依赖的 moduleA 分割了出来 用动态 import 进行代码分割 指定上面分割出的代码的 chunkName 提取 subPageA, subPageB依赖的 moduleA 网页中只引用 pageA.bundle.js 最后发现， 被分割的代码根据给定的条件也是会被加载进来的。 处理CSS 引入 style-loader（将样式通过 style 标签引入） style-loader/url style-loader/useable 配置optionsinsertAt:：插入位置insertInto：插入DOMsingleton：是否只使用一个 style 标签transform：转化，浏览器环境下，插入页面前 css-loader(JS 可以 import css 文件) optionsalias：解析的别名importLoader：@importMinimize：是否压缩modules：启用css-modules CSS modules :local :global compose compose … from path 配置 less / sass npm install less-loader less –save-dev npm install sass-loader node-sass –save-dev 提取 CSS代码 // 第一种loader 规则 将css 转化为页面style标签// 第一种loader 规则 将css 转化为页面link 加载样式文件（不常用，每个import 的样式都会打包为一个样式文件，并 link 引入）// style-loader/useable 控制是否插入 stylemodule.exports = &#123; module: &#123; rules: [&#123; test: /\.css$/, use: [&#123; loader: 'style-loader', options: &#123; singleton: true, transform: './css.transform.js' &#125; &#125;, &#123; loader: 'css-loader', options: &#123; // minimize: true, modules: true, localIdentName: '[path][name]_[local]--[hash:base64:5]' &#125; &#125;] &#125;, &#123; test: /\.css$/, use: [&#123; loader: 'style-loader/url' &#125;, &#123; loader: 'file-loader' &#125;] &#125;] &#125;&#125; module.exports = &#123; module: &#123; rules: [&#123; test: /\.less$/, use: [&#123; loader: 'style-loader' &#125;, &#123; loader: 'css-loader', options: &#123; // minimize: true, modules: true, localIdentName: '[path][name]_[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: 'less-loader' &#125;] &#125;] &#125;&#125; 提取CSS： extract-loader ExtractTextWebpackPlugin npm i extract-text-webpack-plugin –save // 配置var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')var HtmlWebpackPlugin = require('html-webpack-plugin')module.exports = &#123; module: &#123; rules: [&#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123;&#125; &#125;, use: [&#123; loader: 'css-loader', options: &#123; minimize: true, modules: true, localIdentName: '[path][name]_[local]--[hash:base64:5]' &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: [ // require('autoprefixer')(), require('postcss-sprites')(&#123; spritePath: 'dist/assets/img/sprites', retina: true &#125;), require('postcss-cssnext')() ] &#125; &#125;, &#123; loader: 'less-loader' &#125;] &#125;) &#125;, &#123; test: /\.(png|jpg|jpeg|gif)$/, use: [&#123; loader: 'file-loader', options: &#123; publicPath: '', outputPath: 'dist/', useRelativePath: true &#125; &#125;, &#123; loader: 'url-loader', // img 转为base64 和上面的不要同时用 options: &#123; name: '[name]-[hash].[ext]', publicPath: '', outputPath: 'dist/', useRelativePath: true, limit: 10000 &#125; &#125;, &#123; loader: 'img-loader', options: &#123; pngquant: &#123; quality: 80 &#125; &#125; &#125;] &#125;, &#123; test: /\.(eot|woff2?|ttf|svg)$/, use: &#123; loader: 'url-loader', options: &#123; name: '[name]-[hash].[ext]', publicPath: '', outputPath: 'dist/', useRelativePath: true, limit: 5000 &#125; &#125; &#125;] &#125;, resolve: &#123; alias: &#123; jquery: path.resolve(__dirname, 'src/libs/jquery') &#125; &#125; plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min.css', allChunks: false // 默认只打包初始化的，不包含异步的， 设置为true 则依赖全部打包 &#125;), new PurifyCSS(&#123; paths: glob.sync([ path.join(__dirname, './*.html'), path.join(__dirname, './src/*.js') ]) &#125;), new Webpack.ProvidePlugin(&#123; $: 'jquery' &#125;), new HtmlWebpackPlugin(&#123; filename: 'index.html', template: './index.html', chunks: ['app'], minify: &#123; collapseWhiteSpace: true &#125; &#125;), new Webpack.optimize.uglifyJS() ]&#125; PostCss处理 CSS 的工具：安装： postcss postcss-loader autoprefixer：自动加浏览器前缀 cssnano：优化压缩 cssnext：使用未来 CSS 语法 precss：处理变量、mixin等 所有插件共用： // package.json&#123; "broswerslist": &#123; "&gt;= 1%", "last 2 version" &#125;&#125; Tree ShakingJS Tree Shaking 使用场景： 常规优化 引入第三方库的某一个功能 插件：Webpack.optimize.uglifyJS // 自己项目文件new Webpack.optimize.uglifyJS()// 第三方库npm i lodash-es --savenpm i babel-plugin-lodash --save-dev CSS Tree Shaking Purify CSS(https://github.com/purifycss/purifycss) purifycss-webpack glob-all 文件处理图片处理 file-loader url-loader img-loader postcss-sprites 字体文件 file-loader url-loader 第三方JS库 webpack.providePlugin imports-loader window HTML in Webpackhtml-webpack-plugin：自动生成 HTML，插入打包后的 JS CSS HTML 引入图片html-loader或者&lt;img src=&quot;${require(&#39;./xxxx.png&#39;)}&quot;&gt; 配合优化html-webpack-inline-chunk-plugin：配合 html-webpack-plugin 使用，将插入html的打包文件，外链模式改为内联。例如：script-src 变为 &lt;script&gt;xxxxx&lt;/script&gt; 搭建开发环境clean-webpack-plugin webpack watch mode: webpack -watch webpack-dev-server express + webpack-dev-middleware 模块热更新 devServer.hot webpack.HotModuleReplacementPlugin webpack.NameModulesPlugin 开启调试 SourceMap devtool webpack.SourceMapDevToolPlugin webpack.EvalSourceMapDevToolPlugin EsLint 检查代码 eslint eslint-config-standard eslint-loader eslint-plugin-html eslint-friendly-formatter 开发环境&amp;生产环境 生产环境：提取公用代码、压缩混淆、文件压缩 或 BASE64 编码、去除无用代码； 共同点：同样的入口，同样的代码处理，同样的解析配置 how区别：webpack-merge webpack.dev.conf.js webpack.prod.conf.js webpack.common.conf.js 打包结果分析 Offical Analyse Tool webpack-bundle-analyzer 插件：BundleAnalyzerPlugin 优化打包速度 文件多？ 依赖多？ 页面多？ 方法： 分开 vendor 和 app Dllplugin DllReferencePlugin UglifyJsPlugin(并行处理) parallel cache HappyPack HappyPack.ThreadPool(loader 并行处理) babel-loader options.cacheDirectory include exclude 其他 减少 resolve Devtool：去除 sourcemap cache-loader 升级 node 升级 webpack 长缓存优化what why how 场景： 改变 app 代码，vendor 变化 解决 提取 vendor hash -&gt; chunkhash(output 中的 filename) 提取 webpack runtime 场景： 引入新模块，模块顺序变化，vendor hash 变化 解决 NamedChunksPlugin NamedModulesPlugin 场景 动态引入模块时，vendor hash 变化 解决 最新版 webpack 已解决 老版本：定义动态模块的 chunkname 多页面应用 场景 多入口 entry 多页面 html 每个页面不同的 chunk 每个页面不同的参数 使用 多配置（webpack 3.1.0 支持）parallel-webpack，配置独立灵活缺点：不能多页面之间共享代码 or 单配置 parallel-webpack: parallel-webpack –watch parallel-webpack –config 单配置： 优点 可以共享各个 entry 之间的公用代码 缺点 打包速度比较慢 输出内容比较复杂 vue 和 webpackvue listvue init &lt;template name&gt; &lt;project name&gt;# 使用自己定制的模板vue init &lt;git repo&gt; &lt;project name&gt;# 打包项目，并分析npm run build --report react 和 webpack create-react-app react-scripts npx create-react-app my-project(npm 5.2+)create-react-app my-project(npm 5.2-)npm startnpm testnpm run build npm run eject 支持 ES6 和 JSX 支持 动态 import 支持 Fetch (polyfill) 支持 proxy 支持 postcss 支持 eslint 不支持 React Hot-reloading 弱支持 CSS 预处理器 # 解决预处理和热更新npm i less less-loader react-hot-loader --save 代码截图地址]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>webapck</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 JS 高级面试]]></title>
    <url>%2F2018%2F08%2F14%2Finterview3%2F</url>
    <content type="text"><![CDATA[前端 JS 高级知识整理，以及面试要点。 基础知识 ES6 常用语法 原型高级应用 异步全面讲解 框架原理 虚拟 DOM MVVM Vue 组件化 React 混合开发 hybrid hybrid vs H5 前端客户端通讯 热爱编程 读书 博客 开源 ES6 常用语法模块化的使用和编译环境webpack笔记babel使用rollup.js 使用： 功能单一， webpack功能强大 参考设计原则和Linux设计思想 工具要尽量功能单一，可集成，可扩展 wangEdtor 用的 gulp + rollup Class 与 JS 构造函数的区别 Class 在语法上更加铁盒面向对象的写法 Class 实现继承更加易读、易理解 更易于写 java 等后端语言的使用 本质还是语法糖，使用 prototype 参考1-构造函数和集成ES5参考2-class 和 extends Promise 的用法 定义方法，return promise 实例 new Promise 时要传入函数，函数有 resolve reject 两个参数 执行成功 resolve() 失败 reject() then() 监听成功结果 catch() 监听失败结果 参考 ES6 其他常用功能参考 原型高级应用原型如何实际应用jquery 和 zepto 的简单使用他俩如何使用原型 zepto 如何使用原型 var zepto = &#123;&#125;zepto.init = function(selector) &#123; // resoure code 略 only write prototype var slice = Array.prototype.slice var dom = slice.call(document.querySelectorAll(selector)) return zepto.Z(dom, selector)&#125;// usevar $ = function(selector) &#123; return zepto.init(selector)&#125;// 构造函数function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0 for(i = 0; i &lt; len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || ''&#125;zepto.Z = function(dom, selector) &#123; return new Z(dom, selector)&#125;$.fn = &#123; constructor: zepto.Z, css: function(key, value) &#123; &#125;, html: function(value) &#123; &#125;&#125;zepto.Z.prototype = Z.prototype = $.fn jQuery 如何使用原型(function(window) &#123; var jQuery = function(selector) &#123; return new jQuery.fn.init(selector) &#125; jQuery.fn = &#123; constructor: jQuery, css: function(key, value) &#123; alert('css') &#125;, html: function(value) &#123; return 'html' &#125; &#125; var init = jQuery.fn.init = function(selector) &#123; var slice = Array.prototype.slice var dom = slice.call(document.querySelectorAll(selector)) var i, len = dom ? dom.length : 0 for (i = 0; i &lt; len; i++) &#123; this[i] = dom[i] &#125; this.length = len this.selector = selector || '' &#125; init.prototype = jQuery.fn window.$ = jQuery&#125;)(window) 描述一下 jQuery 如何使用原型 。。。。zepto。。。。。。 再结合自己的项目经验，说一下自己开发的例子 原型如何满足扩展$.fn.myMethod = function() {} 说一下 jQuery 和 zepto 的插件机制 结合自己开发经验，做过的基于原型的插件 异步全面讲解什么是单线程，和异步有何关系？什么是 event-loop单线程：只有一个线程，同时只能做一件事（for 循环多次、alert），两段JS不能同时执行原因：避免DOM渲染的冲突解决方案：异步 事件轮询，JS实现异步的具体解决方案 同步代码直接执行 异步函数先放在异步队列 待同步函数执行完毕，轮询执行异步队列的函数 什么是异步队列？何时被放入异步队列？轮询的过程 目前 JS 解决异步的方案有哪些 jQuery Deferred Promise Async / Await Generator 原理比较复杂 不是异步的直接替代方式 有更好更简洁的解决方案 async / await koa 也早已“弃暗投明” 如果只用 jQuery 如何解决异步jquery1.5的变化： 无法改变JS异步和单线程的本质 只能从写法上杜绝 callback 这种形式 他是一种语法糖形式，但是解耦了代码 很好的体现：开放封闭原则 $.ajax().done().fail().done()$.ajax().then(function(){}, function(){}).then() jquery-deferred: 对扩展开放，对修改关闭dtdAPI分为两类，用意不同： 第一类：dtd.resolve(), dtd.reject 第二类：dtd.then dtd.done dtd.fail 这两类应该分开，否则后果很严重 function waitHandle() &#123; // 定义 var dtd = $.Deferred() var wait = function(dtd) &#123; var task = function() &#123; console.log('执行完成') // 成功 dtd.resolve() // 失败 // dtd.reject() &#125; setTimeout(task, 1000) // wait 返回 return dtd.promise() &#125; // 最终返回 return wait(dtd) &#125; // 使用（B 员工） var w = waitHandle() // promise 对象 $.when(w).then(function() &#123; console.log('ok 1') &#125;, function() &#123; console.log('err 1') &#125;) Promise 的标准 状态变化 三种状态：pending fulfilled rejected 初始状态：pending pending 变为 fulfilled，或者 pending 变为 rejected 状态变化不可逆 then Promise 实例必须实现 then 这个方法 then() 必须可以接受两个函数作为参数 then() 返回的必须是一个 Promise 实例 问题： 基本语法 如何异常捕获（Error 和 reject 都要考虑） 多个串联-链式执行的好处 Promise.all 和 Promise.race Promise 标准 - 状态变化，then 函数 async / await 的使用 then 只是将 callback 拆分了 async/await 是最直接的同步写法 使用 await，函数必须用 async 标识 await 后面跟的是一个 Promise 实例 需要 babel-polyfill 问题： 基本语法 使用了 Promise，并没有和 Promise 冲突 完全是同步的写法，再也没有回调函数 但是：改变不了JS单线程、异步的本质 虚拟DOM什么是Vdom，为何要用Vdom设计一个需求场景 -》用jquery实现 -》遇到的问题 浏览器渲染 DOM 是很慢的，运行 JS 快成一匹马 // 点击按钮，改变表格数据// jquery demo// html// &lt;div id="container"&gt;&lt;/div&gt;// &lt;button id="btn-change"&gt;change&lt;/button&gt;// jsvar data = [&#123; name: '张三', age: '20', address: '北京' &#125;, &#123; name: '李四', age: '21', address: '上海' &#125;, &#123; name: '王五', age: '22', address: '广州' &#125;]// 渲染函数function render(data) &#123; var $container = $('#container') // 清空容器，重要！！！ $container.html('') // 拼接 table var $table = $('&lt;table&gt;') $table.append($('&lt;tr&gt;&lt;td&gt;name&lt;/td&gt;&lt;td&gt;age&lt;/td&gt;&lt;td&gt;address&lt;/td&gt;/tr&gt;')) data.forEach(function (item) &#123; $table.append($('&lt;tr&gt;&lt;td&gt;' + item.name + '&lt;/td&gt;&lt;td&gt;' + item.age + '&lt;/td&gt;&lt;td&gt;' + item.address + '&lt;/td&gt;/tr&gt;')) &#125;) // 渲染到页面 $container.append($table)&#125;$('#btn-change').click(function () &#123; data[1].age = 30 data[2].address = '深圳' // re-render 再次渲染 render(data)&#125;)// 页面加载完立刻执行（初次渲染）render(data)// 存在的问题就是，没有改变数据的地方，也会重新渲染 遇到的问题： DOM 操作是“昂贵的”，JS 运行效率高 尽量减少 DOM 操作，而不是“推倒重来” 项目越复杂 ，影响就越严重 vdom即可解决问题 vdom： 用 JS 模拟 DOM 结构 DOM 变化的对比，放在 JS 层来做（图灵完备语言） 提高重绘性能 Vdom如何使用，核心函数有哪些snabbdom用法： // &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"&gt;&lt;/script&gt;// &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"&gt;&lt;/script&gt;// &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"&gt;&lt;/script&gt;// &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"&gt;&lt;/script&gt;// &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"&gt;&lt;/script&gt;// &lt;script src="https://cdn.bootcss.com/snabbdom/0.7.1/h.js"&gt;&lt;/script&gt;var snabbdom = window.snabbdom// 定义 patchvar patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners])// 定义 hvar h = snabbdom.hvar container = document.getElementById('container')// 生成 vnodevar vnode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'Item 1'), h('li.item', &#123;&#125;, 'Item 2')])patch(container, vnode)document.getElementById('btn-change').addEventListener('click', function () &#123; // 生成 newVnode var newVnode = h('ul#list', &#123;&#125;, [ h('li.item', &#123;&#125;, 'Item 1'), h('li.item', &#123;&#125;, 'Item B'), h('li.item', &#123;&#125;, 'Item 3') ]) patch(vnode, newVnode) // 找出差异，渲染差异&#125;) // jquery例子改造var snabbdom = window.snabbdom// 定义关键函数 patchvar patch = snabbdom.init([ snabbdom_class, snabbdom_props, snabbdom_style, snabbdom_eventlisteners])// 定义关键函数 hvar h = snabbdom.h// 原始数据var data = [&#123; name: '张三', age: '20', address: '北京' &#125;, &#123; name: '李四', age: '21', address: '上海' &#125;, &#123; name: '王五', age: '22', address: '广州' &#125;]// 把表头也放在 data 中data.unshift(&#123; name: '姓名', age: '年龄', address: '地址'&#125;)var container = document.getElementById('container')// 渲染函数var vnodefunction render(data) &#123; var newVnode = h('table', &#123;&#125;, data.map(function (item) &#123; var tds = [] var i for (i in item) &#123; if (item.hasOwnProperty(i)) &#123; tds.push(h('td', &#123;&#125;, item[i] + '')) &#125; &#125; return h('tr', &#123;&#125;, tds) &#125;)) if (vnode) &#123; // re-render patch(vnode, newVnode) &#125; else &#123; // 初次渲染 patch(container, newVnode) &#125; // 存储当前的 vnode 结果 vnode = newVnode&#125;// 初次渲染render(data)var btnChange = document.getElementById('btn-change')btnChange.addEventListener('click', function () &#123; data[1].age = 30 data[2].address = '深圳' // re-render render(data)&#125;) 核心API： h(‘&lt;标签名&gt;’, {…属性…}, […子元素…]) h(‘&lt;标签名&gt;’, {…属性…}, ‘….’) patch(container, vnode) patch(vnode, newVnode) 了解diff算法吗 什么是diff算法 linux diff 命令 git diff （对比两个文件之间差异） 去繁就简 diff 算法非常复杂，实现难度很大，源码量很大 去繁就简，讲明白核心流程，不关心细节 面试官也大部分都不清楚细节，但是很关心核心流程 去繁就简之后，依然具有很大挑战性，并不简单 vdom 为何用 diff 算法 DOM 操作是“昂贵”的，因此尽量减少 DOM 操作 找出本次 DOM 必须更新的节点来更新，其他的不更新 这个“找出”的过程，就需要 diff 算法 diff 算法的实现流程 patch(container, vnode) patch(vnode, newVnode) 核心逻辑：createElement 和 updateChildren // diff 算法实现// code demofunction createElement(vnode) &#123; var tag = vnode.tag // 'ul' var attrs = vnode.attrs || &#123;&#125; var children = vnode.children || [] if (!tag) &#123; return null &#125; // 创建真实的 DOM 元素 var elem = document.createElement(tag) // 属性 var attrName for (attrName in attrs) &#123; if (attrs.hasOwnProperty(attrName)) &#123; // 给 elem 添加属性 elem.setAttribute(attrName, attrs[attrName]) &#125; &#125; // 子元素 children.forEach(function (childVnode) &#123; // 给 elem 添加子元素 elem.appendChild(createElement(childVnode)) // 递归 &#125;) // 返回真实的 DOM 元素 return elem&#125;// vnode newVnode comparefunction updateChildren(vnode, newVnode) &#123; var children = vnode.children || [] var newChildren = newVnode.children || [] children.forEach(function (childVnode, index) &#123; var newChildVnode = newChildren[index] if (childVnode.tag === newChildVnode.tag) &#123; // 深层次对比，递归 updateChildren(childVnode, newChildVnode) &#125; else &#123; // 替换 replaceNode(childVnode, newChildVnode) &#125; &#125;)&#125;function replaceNode(vnode, newVnode) &#123; var elem = vnode.elem // 真实的 DOM 节点 var newElem = createElement(newVnode) // 替换&#125; answer: 知道什么是 diff 算法，是 linux 的基础命令 vdom 中应用 diff 算法是为了找出需要更新的节点 vdom 实现过程，createElement 和 updateChildren 与核心函数 patch 的关系 MVVM（Vue） 如何理解 MVVM 如何实现 MVVM 是否解读过 vue 的源码（理解能力 学习能力 自学能力） 说一下使用 jQuery 和使用框架的区别todolist // jquery// html// &lt;div&gt;// &lt;input type="text" name="" id="txt-title"&gt;// &lt;button id="btn-submit"&gt;submit&lt;/button&gt;// &lt;/div&gt;// &lt;div&gt;// &lt;ul id="ul-list"&gt;&lt;/ul&gt;// &lt;/div&gt;var $txtTitle = $('#txt-title')var $btnSubmit = $('#btn-submit')var $ulList = $('#ul-list')$btnSubmit.click(function () &#123; var title = $txtTitle.val() if (!title) &#123; return &#125; var $li = $('&lt;li&gt;' + title + '&lt;/li&gt;') $ulList.append($li) $txtTitle.val('')&#125;)// vue// &lt;div id="app"&gt;// &lt;div&gt;// &lt;input v-model="title"&gt;// &lt;button v-on:click="add"&gt;submit&lt;/button&gt;// &lt;/div&gt;// &lt;div&gt;// &lt;ul&gt;// &lt;li v-for="item in list"&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;// &lt;/ul&gt;// &lt;/div&gt;// &lt;/div&gt;// data 独立var data = &#123; title: '', list: []&#125;// 初始化 Vue 实例var vm = new Vue(&#123; el: '#app', data: data, methods: &#123; add: function () &#123; this.list.push(this.title) this.title = '' &#125; &#125;&#125;)/* with(this)&#123; // this 就是 vm return _c( 'div', &#123; attrs:&#123;"id":"app"&#125; &#125;, [ _c( 'div', [ _c( 'input', &#123; directives:[ &#123; name:"model", rawName:"v-model", value:(title), expression:"title" &#125; ], domProps:&#123; "value":(title) &#125;, on:&#123; "input":function($event)&#123; if($event.target.composing)return; title=$event.target.value &#125; &#125; &#125; ), _v(" "), _c( 'button', &#123; on:&#123; "click":add &#125; &#125;, [_v("submit")] ) ] ), _v(" "), _c('div', [ _c( 'ul', _l((list),function(item)&#123;return _c('li',[_v(_s(item))])&#125;) ) ] ) ] )&#125;*/ 区别： 数据和视图的分离，解耦（开放封闭原则） 以数据驱动视图，只关心数据变化，DOM 操作被封装 说一下对 MVVM 的理解MVC： M：Model 数据 V：View 视图、界面 C：Controller 控制器、逻辑处理 MVVM： Model：模型、数据 View：视图、模板（视图和模型是分离的） ViewModel：连接 Model 和 View 关于 ViewModel MVVM 不算是一种创新 但其中的 ViewModel 确实一种创新 真正结合前端场景应用的创建 解答： MVVM：Model View ViewModel 三者之间的联系、以及如何对应到各段代码 ViewModel 的理解，联系 View 和 Model MVVM三要素： 响应式：vue 如何监听到 data 的每个属性变化 模板引擎：Vue 的模板如何被解析，指令如何处理 渲染：vue 的模板如何被渲染成html？以及渲染过程vue 中如何实现响应式 什么是响应式 修改 data 属性之后，vue 立刻监听到 data 属性被代理到 vm 中 Object.defineProperty 模拟 // var obj = &#123;// name: 'zhangsan',// age: 25// &#125;// console.log(obj)// var obj = &#123;&#125;// var _name = 'shangsan'// Object.defineProperty(obj, 'name', &#123;// get: function () &#123;// console.log('get', _name) // 监听// return _name// &#125;,// set: function (newVal) &#123;// console.log('set', newVal) // 监听// _name = newVal// &#125;// &#125;)// var vm = new Vue(&#123;// el: '#app',// data: &#123;// name: 'zhangsan',// age: 20// &#125;// &#125;)var vm = &#123;&#125;var data = &#123; name: 'zhangsan', age: 20&#125;var key, valuefor (key in data) &#123; (function (key) &#123; // 保证 key 的独立作用域 Object.defineProperty(vm, key, &#123; get: function () &#123; console.log('get', data[key]) // 监听 return data[key] &#125;, set: function (newVal) &#123; console.log('set', newVal) // 监听 data[key] = newVal &#125; &#125;) &#125;)(key)&#125; 答案： 关键是理解 Object.defineProperty 将 data 的属性代理到 vm 上 vue 中如何解析模板 模板是什么 本质：字符串 有逻辑，如 v-if v-for 等 与 html 格式很想，但有很大区别 最终还要转换为 html 来显示 分割线 模板最终必须转换成 JS 代码，因为 有逻辑（v-if v-for），必须用 JS 才能实现 转换为 html 渲染页面，必须用 JS 才能实现 因此，模板最终要转换成一个 JS 函数（render 函数） render 函数 模板中所有信息都包含在了 render 函数中 this 即 vm price 即 this.price 即 vm.price，即 data 中的 price _c 即 this._c 即 vm._c 从哪里可以看到 render 函数？(源码查找code.render 打印出来) 复杂一点的例子，render 函数是什么样子的？（参考上面的 todo-list） vm._c 是什么？（创建元素） render 函数与 vdom vm._c 其实就相当于 snabbdom 中的 h 函数 render 函数执行之后，返回的是 vnode updateComponent 中实现了 vdom 的 patch 页面首次渲染执行 updateComponent data 中每次修改属性，执行 updateComponent 根据 todo-list demo 的 render 函数： v-model 是怎么实现的？ v-on:click 是怎么实现的？ v-for 是怎么实现的？ render函数解决了模板中“逻辑”（v-for v-if）的问题还剩下模板生成 html 的问题另外，vm._c 是什么？render 函数返回了什么？ // html// &lt;div id="app"&gt;// &lt;p&gt;&#123;&#123;price&#125;&#125;&lt;/p&gt;// &lt;/div&gt;// jsvar vm = new Vue(&#123; el: '#app', data: &#123; price: 100 &#125;&#125;)// 以下是手写的 ppt 中的 render 函数function render() &#123; with(this) &#123; // this 就是 vm return _c( 'div', &#123; attrs: &#123; 'id': 'app' &#125; &#125;, [ _c('p', [_v(_s(price))]) ] ) &#125;&#125;function render1() &#123; return vm._c( 'div', &#123; attrs: &#123; 'id': 'app' &#125; &#125;, [ vm._c('p', [vm._v(vm._s(vm.price))]) ] )&#125; vue 的整个实现流程 模板：字符串，有逻辑，嵌入 JS 变量…… 模板必须转换为 JS 代码（有逻辑、渲染 html、JS 变量） render 函数是什么样子的 render 函数执行是返回 vnode updateComponent 流程： 第一步：解析模板成 render 函数 with 的用法 模板中的所有信息都被 render 函数包含 模板中用到的 data 中的属性，都变成了 JS 变量 模板中的 v-model v-for v-on 都变成了 JS 逻辑 render 函数返回 vnode 第二步：响应式开始监听 Object.defineProperty 将 data 的属性代理到 vm 上 第三步：首次渲染，显示页面，且绑定依赖 初次渲染，执行 updateComponent，执行 vm._render() 执行 render 函数，会访问到 vm.list vm.title 会被响应式的 get 方法监听到（后面详细讲） 执行 updateComponent ，会走到 vdom 的 patch 方法 patch 将 vnode 渲染成 DOM ，初次渲染完成 第四步：data 属性变化，触发 rerender 修改属性，被响应式的 set 监听到 set 中执行 updateComponent updateComponent 重新执行 vm._render() 生成的 vnode 和 prevVnode ，通过 patch 进行对比 渲染到 html 中 组件化 React说一下对组件化的理解 组件化的封装 视图 数据 变化的逻辑（数据驱动视图变化） 组建的复用 props 传递 复用 JSX 本质是什么 JSX 语法 html 形式 引入 JS 变量和表达式 if…else… 循环 style 和 className 事件 JSX 解析成 JS JSX 其实是语法糖 开发环境会将 JSX 编译成 JS 代码 JSX 的写法大大降低了学习成本和编码工作量 同时，JSX 也会增加 debug 成本 独立的标准 JSX 是 React 引入的，但不是 React 独有的 React 已经将它作为一个独立标准开放，其他项目也可用 React.createElement 是可以自定义修改的 说明：本身功能已经完备；和其他标准兼容和扩展性没问题 // jsx test// devDependencies: babel-plugin-transform-react-jsx// .babelrc// &#123;"plugins": ["transform-react-jsx"]&#125;// demo.js/* @jsx h */// 上面这段注释，用于更改 React.cerateElement()函数名称// var profile = &lt;div&gt;// &lt;img src="avatar.png" className="profile" /&gt;// &lt;h3&gt;&#123;[user.firstName, user.lastName].join(' ')&#125;&lt;/h3&gt;// &lt;/div&gt;;// class Input extends Component &#123;// render() &#123;// return (// &lt;div&gt;// &lt;input value=&#123;this.state.title&#125; onChange=&#123;this.changeHandle.bind(this)&#125;/&gt;// &lt;button onClick=&#123;this.clickHandle.bind(this)&#125;&gt;submit&lt;/button&gt;// &lt;/div&gt;// );// &#125;// &#125;// 命令行输入：babel --plugins trnasform-react-jsx demo.jsx JSX 和 vdom 的关系 为何需要 vdom vdom 是 React 初次推广开来的，结合 JSX JSX 就是模板，最终要渲染成 html 初次渲染 + 修改 state 后的 re-render 正好符合 vdom 的应用场景 React.createElement 和 h 都生成 vndoe 何时 patch ？ 初次渲染 - ReactDOM.render(, container) 会触发 patch(container, vnode) re-render - setState 会触发 patch(vnode, newVnode) 自定义组件的解析 ‘div’ - 直接渲染 &lt;div&gt; 即可，vdom 可以做到 Input 和 List ，是自定义组件（class），vdom 默认不认识 因此 Input 和 List 定义的时候必须声明 render 函数 根据 props 初始化实例，然后执行实例的 render 函数 render 函数返回的还是 vnode对象 说一下 setState 的过程 setState 的异步（为何要异步） 可能会一次执行多次 你无法规定、限制用户如何使用 setState 没必要每次 setState 都重新渲染 即便每次重新渲染，用户也看不到中间的效果 只看到最后的结果即可 vue 修改属性也是异步 setState 的过程 每个组件实例，都有 renderComponent 方法 执行 renderComponent 会重新执行实例的 render render 函数返回 newVnode ，然后拿到 preVnode 执行 patch(preVnode, newVnode) 阐述自己对 React 和 vue 的认识 两者的本质区别 vue：本质是 MVVM 框架，有 MVC 发展而来 React：本质是前端组件化框架，由后端组件化发展而来 但这并不妨碍他们两者都能实现相同的功能 模板的区别 vue - 使用模板（最初由 angular 提出） React - 使用 JSX 模板语法上，我更加倾向于 JSX 模板分离上，我更加倾向于 vue 模板应该和 JS 逻辑分离 回顾“开放封闭原则” 组件化的区别 React 本身就是组件化，没有组件化就不是 React vue 也支持组件化，不过是在 MVVM 上的扩展 查阅 vue 组件化的文档，洋洋洒洒很多（侧面反映） 对于组件化，我更加倾向于 React ，做的彻底而清晰 两者共同点 都支持组件化 都是数据驱动试图 问题解答： 国内使用，首推 vue 。文档更易读、易学、社区够大 如果团队水平较高，推荐使用 React 。组件化和 JSX hybrid 移动端占大部分流量，已经远远超过 PC 一线互联网公司都有自己的 App 这些 App 中有很大比例的前端代码（不要惊讶） 拿微信举例，你每天浏览微信的内容，多少是前端？ hybrid 是什么，为何用 hybrid？ hybrid 文字解释 hybrid 即“混合”，即前端和客户端的混合开发 需前端开发人员和客户端开发人员配合完成 某些环节也可能涉及到 server 端 PS：不要以为自己的前端就可以不理会客户端的知识 存在价值，为何会用 hybrid 可以快速迭代更新【关键】（无需 app 审核，思考为何？） 体验流畅（和 NA 的体验基本类似） 减少开发和沟通成本，双端公用一套代码 webview 是 app 中的一个组件（ app 可以有 webview ，也可以没有） 用于加载 h5 页面，即一个小型的浏览器内核 file:// 协议 其实在一开始接触 html 开发，就已经使用了 file 协议 只不过你当时没有“协议”“标准”等这些概念 再次强调“协议”“标准”的重要性！！！ file 协议：本地文件，快 http(s) 协议：网络加载，慢 hybrid 实现流程 以下是前言： 不是所有场景都适合使用 hybrid： 使用 NA ：体验要求极致，变化不频繁（如头条的首页） 使用 hybrid ：体验要求高，变化频繁（如头条的新闻详情页） 使用 h5 ：体验无要求，不常用（如举报、反馈等页面） 以下是具体流程 前端做好静态页面（html js css），将文件交给客户端 客户端拿到前端静态页面，以文件形式存储在 app 中 客户端在一个 webview 中 使用 file 协议加载静态页面 介绍一下 hybrid 更新和上线的流程？ 分版本，有版本号，如 201803211015 将静态文件压缩成 zip 包，上传到服务端 客户端每次启动，都去服务端检查版本号 如果服务端版本号大于客户端版本号，就去下载最新的 zip 包 下载完之后解压包，然后将现有文件覆盖 hybrid 和 h5 的主要区别 优点 体验更好，跟 NA 体验基本一致 可快速迭代，无需 app 审核【关键】 缺点 开发成本高。联调、测试、查 bug 都比较麻烦 运维成本高。参考此前讲过的更新上线的流程 适用的场景 hybrid ：产品的稳定功能，体验要求高，迭代频繁 h5 ：单词次运营活动（如 xx 红包）或不常用功能 前端 JS 和客户端如何通讯？微信JSDK JS 和客户端通讯的基本形式 JS 访问客户端能力，传递参数和回调函数 客户端通过回调函数返回内容 schema 协议简介和使用 schema 协议 —— 前端和客户端通讯的约定 使用iframe （类似JSONP）例如：weixin://dl/scan 扫一扫 schema 使用的封装 内置上线 将以上封装的代码打包，叫做 invoke.js，内置到客户端 客户端每次启动 webview ，都默认执行 invoke.js 本地加载，免去网络加载的时间，更快 本地加载，没有网络请求，黑客看不到 schema 协议，更安全 // schema 使用的封装// html// &lt;button id="btn1"&gt;扫一扫&lt;/button&gt;// &lt;button id="btn2"&gt;分享&lt;/button&gt;// &lt;script type="text/javascript" src="./invoke.js"&gt;&lt;/script&gt;(function(window, undefined) &#123; // 调用 schema 的封装 function _invoke(action, data, callback) &#123; // 拼装 schema 协议 var schema = 'myapp://utils/' + action schema += schema.indexOf('?') === -1 ? '?' : '&amp;' // 拼接参数 for (var key in data) &#123; if (data.hasOwnProperty(key)) &#123; schema += key + '=' + data[key] + '&amp;' &#125; &#125; // 处理 callback callbackName = action + Date.now() window[callbackName] = callback schema += 'callback=' + callbackName // 触发 var iframe = document.createElement('iframe') iframe.style.display = 'none' iframe.src = schema // 重要！ var body = document.body body.appendChild(iframe) setTimeout(function() &#123; body.removeChild(iframe) iframe = null &#125;) &#125; // 暴露到全局变量 window.invoke = &#123; share: function(data, callback) &#123; _invoke('share', data, callback) &#125;, scan: function(data, callback) &#123; _invoke('scan', data, callback) &#125; login: function(data, callback) &#123; _invoke('login', data, callback) &#125; &#125;&#125;)(window) 你热爱编程吗 读书 构建知识体系最好的方式 自己买书 看书有技巧（标记、有痕迹） 看完书要总结（读书笔记、思维导图） 写博客 做开源]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 JS 中级面试]]></title>
    <url>%2F2018%2F07%2F14%2Finterview2%2F</url>
    <content type="text"><![CDATA[前端面试进阶内容。 面试环节： 一面：基础知识 html css3 js 二面/三面（高级工程师）：基础延伸（根据简历上自己的项目）、技术原理 优点 缺点 三面/四面（业务负责人）：项目中担任的角色，起的作用，业务处理 终面（HR）：性格、沟通、潜能、规划 面试准备： 职位描述分析 通过了解招聘公司的岗位描述和要求，搞清楚需要了解那些技术点，然后查阅资料搞懂 深入分析，弄清侧重的技术点 业务分析或实战模拟 了解公司是哪个方向的业务，可以访问官网，查看源码了解技术栈 比如：对于Jquery,了解下jQuery模板引擎、jQuery事件委托、事件代理、waifer延迟等 技术栈准备 jQuery：核心架构 事件委托 插件机制 Vue React AngularJs NodeJs less sass grunt gulp npm webpack 可以事先准备些自己熟知的项目、例子、技术点，将面试官往这方面引导 自我介绍 简历：基本信息、学历、工作经历、开源项目 基本信息：姓名、年龄、手机、邮箱、籍贯 学历：博士-硕士-本科 工作经历：时间-公司-岗位-职责-技术栈-业绩 开源项目：github和说明 自我陈述 把握面试的沟通方向 豁达、自信的适度发挥 自如谈兴趣、巧妙示实例、适时讨疑问 节奏要适宜、切忌小聪明 一面二面 页面布局 CSS盒模型 标准模型和IE模型概念 上述之间区别：content-box border-box CSS如何设置上述两种模型 JS如何设置 获取盒模型的宽和高 IE: ele.currentStyle.width/heigh 根据盒模型解释边距重叠 BFC（边距重叠解决方案） BFC基本概念：块级格式化上下文 原理，也就是BFC的渲染规则 BFC元素垂直方向的边距会发生重叠 BFC元素的区域不会与浮动元素的Box重叠 BFC在页面是一个独立的容器，外面的元素不会影响里面的元素反之亦然 计算BFC高的时，浮动元素也会参与计算 如何创建： overflow: hidden/auto等, 不是visible float的值不为none position的值不为static 或者relative display 是 table table-cell 使用场景： DOM事件 基本概念：DOM事件的级别 DOM事件模型 捕获和冒泡 DOM事件流 三个阶段第一阶段：从window对象传导到目标节点，称为“捕获阶段”（capture phase）。第二阶段：在目标节点上触发，称为“目标阶段”（target phase）。第三阶段：从目标节点传导回window对象，称为“冒泡阶段”（bubbling phase）。 DOM事件的捕获具体流程 Event对象的常见应用event.target：事件最初发生的节点event.currentTarget：事件当前所在的节点event.preventDefault()event.stopPropagation()event.stopImmediatePropagation()：阻止同一个事件的其他监听函数被调用 自定义事件// 新建事件实例 如果需要传递数据则需要CustomEventvar event = new Event('build');// 添加监听函数elem.addEventListener('build', function (e) &#123; ... &#125;, false);// 触发事件elem.dispatchEvent(event); Http协议类 HTTP协议的主要特点简单快速：URL对应一个资源灵活：传个类型，就是请求对应文件类型的资源无连接：连接一次就会断掉无状态：不能区分两次连接的身份 HTTP报文的组成部分请求报文：请求行、请求头、空行、请求体相应报文：状态行、响应头、空行、响应体 HTTP的方法 POST和GET的区别记住三到四个 HTTP状态码 什么是持久连接 什么是管线化 原型链类 创建对象几种方法 原型、构造函数、实例、原型链 instanceof的原理 new运算符 面向对象 类与实例类的声明生成实例 类与继承如何实现继承继承的几种方式 通信类 什么是同源策略及限制 前后端如何通信 如何创建Ajax 跨域通信的几种方式 安全类 CSRF基本概念：跨站请求伪造攻击原理防御措施：TOKEN验证、Referer验证（页面内来源验证）、隐藏令牌 XSS基本概念：跨域脚本攻击攻击原理：不需要登录验证，根据合法渠道，注入脚本防范措施： 算法类 排序 堆栈、队列、链表 递归 波兰式和逆波兰式 先理解题目（问面试官给个提示，说自己知道用了什么技术点，自己说一下。。） 二面/三面 面试技巧： 知识面要广 理解要深刻 内心要诚实 态度要谦虚 回答要灵活 要学会赞美 渲染机制： 什么是DOCTYPE及作用 浏览器渲染过程 HTML 渲染过程的一些特点： 顺序执行、并发加载（词法分析、并发加载、并发上限） 是否阻塞（css head 中阻塞页面的渲染、css 阻塞 JS 的执行、css 不阻塞外部脚本的加载）直接引入的 JS 阻塞页面的渲染、JS不阻塞资源的加载、JS 顺序执行，阻塞后续 JS 逻辑的执行 依赖关系（页面渲染依赖 css 的加载、js 的执行顺序的依赖关系） 引入方式（直接引入、defer、async、异步动态引入） 回流： 当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow) 当页面布局和几何属性改变时就需要回流 重绘： 当render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如background-color。则就叫称为重绘。 回流必将引起重绘、而重绘不一定会引起回流 触发页面重布局的属性： 盒子模型相关属性会触发重布局 定位属性及浮动也会触发重布局 改变节点内部文字结构也会触发重布局 只触发重绘的属性： 和外观相关的属性 JS运行机制： 页面性能： 缓存： 错误监控： 三面四面 面试技巧： 准备要充分 描述要演练（模拟演练） 引导找时机（引导说出自己优势，做过的项目啥的） 优势要发挥 回答要灵活 考查能力： 业务能力 主动描述或被动回答 团队协作能力 事务推动能力 带人能力 其他能力 组织能力 学习能力 行业经验 最终面 面试技巧： 乐观积极 主动沟通 逻辑顺畅 上进有责任心 有主张，做事果断 考察问题： 职业竞争力 职业规划]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端 JS 初级面试]]></title>
    <url>%2F2018%2F06%2F14%2Finterview1%2F</url>
    <content type="text"><![CDATA[前端JS基础知识总结，以及相关面试内容。 JS基础考题： 变量的类型和计算 原型和原型链 作用域和闭包 原型和原型链: Object是超级对象，原型链的顶端到Object.prototype，其中Object.prototype.proto为null。 所有引用类型都有一个隐式原型对象：proto 普通函数都有一个prototype对象，他是一个普通对象 function fn () &#123;&#125;console.log(fn.__proto__ === Function.prototype)console.log(Function.prototype.__proto__ === Object.prototype)console.log(Object.prototype.__proto__ === null) instanceof: fn instanceof Foo查找逻辑 看fn的Proto一层层往上，能否对应到Foo.prototype 原型链继承： 子类的原型对象实例化父类。 作用域和闭包: 变量提升的理解 this的几种使用场景 10个a标签，点击弹出对应序号 如何理解作用域 实际开发中闭包的应用 执行上下文： 一段script标签或一个函数：生成一个执行上下文 this: this要在执行时才能确认值，定义时无法确认。 使用场景 作为构造函数中执行 作为对象属性执行 作为普通函数执行 call bind apply 当前作用域没有定义的变量称为自由变量。 闭包的使用场景： 函数作为函数返回值 函数作为函数参数 异步和单线程 同步异步区别，分别举一个例子（定时器，alert） setTimeout笔试题 前端使用异步的场景（可能发生等待的情况：定时器，ajax请求，事件绑定） 日期： Math： 数组API： 对象API： 上述内容自行查询手册 参考 开发环境：加快开发效率 IDE（写代码的效率） Git（代码版本管理，多人协作开发） JS模块化 打包工具 上线回滚的流程 IDE： webstorm：收费 sublime：轻量级，打开快 vscode：微软轻量版VS atom：github开源的编辑器 后面三个编辑器，本身功能不多，需要依赖插件进行编码。 Git： 正式项目都需要代码版本管理、版本回退等 大型项目多人协作，解决代码合并问题 git linux同一个作者 免费的git服务：coding.net github.com 一般公司都有自己的git服务器（搭建工作无需了解太多） git基本命令和操作….. 模块化： 假如有三个JS文件，until.js a-until.js a.js，a.js依赖a-until.js中的函数，a-until.js依赖until.js里的函数 不使用模块化情况： 每个JS文件依次引入，并且until.js a-until.js中外界需要用到的函数都暴露到全局，污染全局变量 依赖关系不明显（负责编写a.js文件的人，并不一定知道需要用到until.js文件） 使用模块化情况： 页面只需引a.js，其他的根据依赖关系自动引入 until.js a-until.js中暴露的函数无需做成全局 AMD:require.js 全局define函数 全局require函数 依赖JS会自动、异步加载 CommonJs(服务器端，硬盘同步读取): nodejs模块化规范，前端开发的依赖（插件和库）都可以npm下载（package.json） 构建工具高度自动化（自动编译、压缩、打包） 同步一次性加载 对比： 异步加载JS，用AMD 用npm用CommonJS 构建工具： grunt gulp fis3 webpack(目前常用) 上线回滚： 基本流程 linux基本命令（买个服务器练练） 基本流程： 上线 将测试完成的代码提交master分支 将当前服务器的代码全部打包并记录版本号，备份 master分支代码提交覆盖到线上服务器，生成新的版本号 回滚 将当前服务器的代码全部打包并记录版本号，备份 将备份的上一个版本解压，覆盖到线上服务器，并生成新的版本号 linux基本命令： # loginssh name@server # 回车会让你输入用户名、密码# 创建目录mkdir contentlsllcd content pwdcd ..rm -rf contentcp a.js a1.jsmv a1.js src/a1.jsrm a.js# vi编辑器vi a.jsiescesc:w esc:qwsc:wq# 查看文件内容cat a.js# 查看前一些head a.jshead -n 1 a.js# 查看后面一些tail a.jstail -n 2 a.js# 搜索操作grep '2' a.js 运行环境：（浏览器） 浏览器通过访问链接来得到页面内容 通过绘制和渲染，显示出页面最终样子 整个过程中需考虑的问题 页面加载过程 性能优化 安全性 页面加载： 输入URL到得到html的详细过程 window.onload（页面全部资源加载完才执行，包括媒体资源）和DOMContentLoaded（DOM渲染完即可执行）区别 加载资源的形式、加载一个资源的过程、浏览器渲染页面的过程 加载资源的形式： 输入URL或跳转 加载HTML 加载html中的静态资源 加载一个资源的过程： 浏览器根据DNS服务器得到域名的IP地址 向这个IP的机器发送http请求 服务器收到、处理并返回http请求 浏览器得到返回内容 浏览器渲染页面过程： 根据HTML结构生成生成DOM树 根据CSS生成CSSOM 将DOM和CSSOM整合形成RenderTree（渲染树） 根据 RenderTree 开始渲染和展示 遇到script标签时，会执行并阻塞渲染（JS可能更改DOM树，所以等待JS加载执行） 思考： CSS放到head中（如果不，出现跳动卡东、性能太差、渲染了两次） JS放到body下面（防止页面渲染阻塞） 图片是异步加载 性能优化： 多使用内存、缓存或者其他方法 减少CPU计算、减少网络 从这里入手： 加载页面和静态资源 页面渲染 加载资源优化： 静态资源合并压缩 静态资源缓存（浏览器策略） 使用CDN让资源加载更快 使用SSR后端渲染，数据直接输出到HTML中 渲染优化： CSS放前面，JS放后面 懒加载（图片懒加载，下拉加载更多） 减少DOM查询，对DOM查询做缓存 减少DOM操作，多个操作尽量合并在一起执行 事件节流(多次同一个事件操作，可以设置个定时器（每次判断是否有这个定时器，若有则清除定时器），直到最后一次操作，则会执行一次定时器的逻辑) 尽早执行操作（如DOMContentLoaded） 安全性： 大多是后端做的（数据库，服务器层面的） XSS跨站请求攻击 XSRF跨站请求伪造 XSS： 写博客插入一段script标签 攻击代码中，获取cookie，发送自己的服务器 预防： 替换： &lt;为&amp;lt 等 后端替换 XSRF: 登录购物网站，正在浏览商品 付费接口是xxxxx.com/pay?id=100，但没有任何验证 收到一封邮件，隐藏着一个图片，地址就是付费接口 预防： 增加验证流程（输入指纹、密码、短信验证码） 后端验证 面试技巧： 简历 过程 简历： 简洁明了，重点突出项目经历和解决方案（项目简介、用了什么技术、难点，怎么解决） 个人博客放在简历中，定期维护更新博客 开源项目放在简历中，并维护 简历别造假（能力经历真实性） 过程： 如何看待加班（加班就像借钱，救急不救穷） 不可挑战面试官，不要反考面试官 学会给面试官惊喜，但不要太多 遇到不会回答的问题，说出你知道的也可以 谈谈你的缺点（说说你最近正在学什么就可以了）]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue 使用]]></title>
    <url>%2F2018%2F05%2F28%2Fmpvue%2F</url>
    <content type="text"><![CDATA[小程序开发框架 mpvue 使用简介。 安装# 全局安装 vue-cli$ npm install --global vue-cli# 创建一个基于 mpvue-quickstart 模板的新项目$ vue init mpvue/mpvue-quickstart my-project# 安装依赖$ cd my-project$ npm install# 启动构建$ npm run dev 实例生命周期小程序 onReady 后，才触发 vue mounted 生命周期。 不建议使用小程序的生命周期钩子。 用法： new Vue(&#123; data: &#123; a: 1 &#125;, created () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a) &#125;, onShow () &#123; // `this` 指向 vm 实例 console.log('a is: ' + this.a, '小程序触发的 onshow') &#125;&#125;)// =&gt; "a is: 1" 微信小程序的页面的 query 参数是通过 onLoad 获取的，mpvue 对此进行了优化，直接通过 this.$root.$mp.query 获取相应的参数数据，其调用需要在 onLoad 生命周期触发之后使用，比如 onShow 等。 如何获取小程序在 app onLaunch/onShow 时候传递的 options？在所有的组件内可以通过 this.$root.$mp.appOptions 进行获取。 不能用的东西v-html 目前可以使用的运算表达式： + - * % ?: ! == === &gt; &lt; [] .，剩下的还待完善。 &lt;!-- 这种就不支持，建议写 computed --&gt;&lt;p&gt;&#123;&#123; message.split('').reverse().join('') &#125;&#125;&lt;/p&gt;&lt;!-- 但写在 @event 里面的表达式是都支持的，因为这部分的计算放在了 vdom 里面 --&gt;&lt;ul&gt; &lt;li v-for="item in list"&gt; &lt;div @click="clickHandle(item, index, $event)"&gt;&#123;&#123; item.value &#125;&#125;&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 不支持过滤器 不支持在 template 内使用 methods 中的函数。 不支持在组件上使用 Class 与 Style 绑定 合理使用双向绑定 mpvue 建议使用 v-model.lazy 绑定方式以优化性能，此外 v-model 在老基础库下输入框输入时可能存在光标重设的问题。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布了一个npm包（gjc-utils）]]></title>
    <url>%2F2018%2F04%2F01%2Fgjc-utils%2F</url>
    <content type="text"><![CDATA[把自己开发中常用的工具进行了封装，并且发布到了npmjs.com 查看地址]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux基本用法]]></title>
    <url>%2F2018%2F03%2F28%2Fredux%2F</url>
    <content type="text"><![CDATA[如何使用redux管理react应用数据？这一篇谈一谈redux的基本用法。 代码示例// 创建Storeimport &#123; createStore &#125; from 'redux';const store = createStore(fn);const state = store.getState();// view产生actionconst ADD_TODO = '添加 TODO';function addTodo(text) &#123; return &#123; type: ADD_TODO, text &#125;&#125;// 发送actionstore.dispatch(addTodo('Learn Redux'));// 计算新的stateconst defaultState = 0;const reducer = (state = defaultState, action) =&gt; &#123; switch (action.type) &#123; case 'ADD': return state + action.payload; default: return state; &#125;&#125;;const state = reducer(1, &#123; type: 'ADD', payload: 2&#125;);----// 每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。import &#123; createStore &#125; from 'redux';const store = createStore(reducer);store.subscribe(listener); Reducer 的拆分import &#123; combineReducers &#125; from 'redux';const chatReducer = combineReducers(&#123; chatLog, statusMessage, userName&#125;)export default todoApp;---// 子reducer放入一个文件，统一引入import &#123; combineReducers &#125; from 'redux'import * as reducers from './reducers'const reducer = combineReducers(reducers) 流程解析 用户发出 Action（store.dispatch(action);） Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。（let nextState = todoApp(previousState, action);） State 一旦有变化，Store 就会调用监听函数。（store.subscribe(listener);） listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。 function listerner() &#123; let newState = store.getState(); component.setState(newState); &#125; 异步需要中间件支持中间件用法import &#123; applyMiddleware, createStore &#125; from 'redux';import createLogger from 'redux-logger';const logger = createLogger();const store = createStore( reducer, applyMiddleware(logger));// createStore方法可以接受整个应用的初始状态作为参数，// applyMiddleware是第三个参数const store = createStore( reducer, initial_state, applyMiddleware(logger)); 异步操作思路 操作开始时，送出一个 Action，触发 State 更新为”正在操作”状态，View 重新渲染 操作结束后，再送出一个 Action，触发 State 更新为”操作结束”状态，View 再一次重新渲染 // 异步操作要发出三种 Action。&#123; type: 'FETCH_POSTS_REQUEST' &#125;&#123; type: 'FETCH_POSTS_FAILURE', error: 'Oops' &#125;&#123; type: 'FETCH_POSTS_SUCCESS', response: &#123; ... &#125; &#125;// state改造 let state = &#123; // ... isFetching: true, didInvalidate: true, lastUpdated: 'xxxxxxx'&#125;;const fetchPosts = postTitle =&gt; (dispatch, getState) =&gt; &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; response.json()) .then(json =&gt; dispatch(receivePosts(postTitle, json))); &#125;;&#125;;const fetchPosts = (dispatch, postTitle) =&gt; new Promise(function (resolve, reject) &#123; dispatch(requestPosts(postTitle)); return fetch(`/some/API/$&#123;postTitle&#125;.json`) .then(response =&gt; &#123; type: 'FETCH_POSTS', payload: response.json() &#125;);&#125;);// 使用方法一store.dispatch(fetchPosts('reactjs'));// 使用方法二store.dispatch(fetchPosts('reactjs')).then(() =&gt; console.log(store.getState()));import &#123; createStore, applyMiddleware &#125; from 'redux';import thunk from 'redux-thunk';// import promiseMiddleware from 'redux-promise';import reducer from './reducers';// Note: this API requires redux@&gt;=3.1.0const store = createStore( reducer, applyMiddleware(thunk)); react-redux待整理…]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuex简介]]></title>
    <url>%2F2018%2F03%2F22%2Fvue-store%2F</url>
    <content type="text"><![CDATA[vue中状态管理工具vuex简介。 代码示例import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123; isLoading: false, direction: 'forward'&#125;export default new Vuex.Store(&#123; state, mutations: &#123; UPDATE_LOADING (state, status) &#123; state.isLoading = status &#125;, UPDATE_DIRECTION (state, direction) &#123; state.direction = direction &#125; &#125;, // 可以异步 actions: &#123; addVisitedViews(&#123; commit &#125;, view) &#123; commit('ADD_VISITED_VIEWS', view) &#125;, delVisitedViews(&#123; commit, state &#125;, view) &#123; return new Promise((resolve) =&gt; &#123; commit('DEL_VISITED_VIEWS', view) resolve([...state.visitedViews]) &#125;) &#125; &#125;&#125;) 使用方法// 实例中调用// 更新值this.$store.commit('UPDATE_LOADING', true);// 获取值this.$store.state.isLoading; 组件中使用： // 在单独构建的版本中辅助函数为 Vuex.mapStateimport &#123; mapState &#125; from 'vuex'export default &#123; // ... computed: mapState(&#123; // 箭头函数可使代码更简练 count: state =&gt; state.count, // 传字符串参数 'count' 等同于 `state =&gt; state.count` countAlias: 'count', // 为了能够使用 `this` 获取局部状态，必须使用常规函数 countPlusLocalState (state) &#123; return state.count + this.localCount &#125; &#125;)&#125;// orcomputed: mapState([ // 映射 this.count 为 store.state.count 'count']) 杂谈gettergetter的值依赖state，是个计算属性相当于 vue中的 data 和 computer 例子：const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;)// 获取store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] 组件中使用： computed: &#123; doneTodosCount () &#123; return this.$store.getters.doneTodosCount &#125;&#125;// orimport &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125;// ormapGetters(&#123; // 映射 `this.doneCount` 为 `store.getters.doneTodosCount` doneCount: 'doneTodosCount'&#125;) mutationMutation 必须是同步函数 在 mutation 中混合异步调用会导致你的程序很难调试。例如，当你能调用了两个包含异步回调的 mutation 来改变状态，你怎么知道什么时候回调和哪个先回调呢？这就是为什么我们要区分这两个概念。在 Vuex 中，mutation 都是同步事务： store.commit('increment')// 任何由 "increment" 导致的状态变更都应该在此刻完成。 在大多数情况下，载荷应该是一个对象，这样可以包含多个字段并且记录的 mutation 会更易读：// ...mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125;store.commit('increment', &#123; amount: 10&#125;) 对象风格的提交方式 // 提交 mutation 的另一种方式是直接使用包含 type 属性的对象：store.commit(&#123; type: 'increment', amount: 10&#125;)// 当使用对象风格的提交方式，整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变：mutations: &#123; increment (state, payload) &#123; state.count += payload.amount &#125;&#125; Mutation 需遵守 Vue 的响应规则: 最好提前在你的 store 中初始化好所有所需属性。 当需要在对象上添加新属性时，你应该 state.obj = &#123; ...state.obj, newProp: 123 &#125; 使用常量替代 Mutation 事件类型 // mutation-types.jsexport const SOME_MUTATION = 'SOME_MUTATION'// store.jsimport Vuex from 'vuex'import &#123; SOME_MUTATION &#125; from './mutation-types'const store = new Vuex.Store(&#123; state: &#123; ... &#125;, mutations: &#123; // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名 [SOME_MUTATION] (state) &#123; // mutate state &#125; &#125;&#125;) 组件中使用： import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment', // 将 `this.increment()` 映射为 `this.$store.commit('increment')` // `mapMutations` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)` ]), ...mapMutations(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.commit('increment')` &#125;) &#125;&#125; action Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 actions: &#123; incrementAsync (&#123; commit &#125;) &#123; setTimeout(() =&gt; &#123; commit('increment') &#125;, 1000) &#125;&#125; Action 通过 store.dispatch 方法触发：store.dispatch('incrementAsync')// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 组件中使用：import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 异步使用： actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 使用store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;)]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 详解]]></title>
    <url>%2F2018%2F03%2F10%2FES2015%2F</url>
    <content type="text"><![CDATA[es 总结。 let const 定义常量使用 const 块级作用域定义变量使用 let 变量的解构赋值数组、对象解构const [first, second] = arr;// 定义的变量名要与属性名一致const &#123;first, ...second&#125; = obj; 使用扩展运算符（…）拷贝数组。（对象也是如此） const arrCopy = [...arr];const objCopy = &#123;...obj&#125;;// similarObject.assign(obj,&#123;a,1&#125;) 解构赋值也可以设置默认值。 计算属性const name = 'tom'; const obj = &#123;[name]: 'hello'&#125; // &#123;tom:'hello'&#125; 字符串的扩展待整理… 正则的扩展待整理… 数值的扩展之前一些全局方法（parseInt、isFinite）等，放到了Number对象上。 新增了一些方法，比如判断数字是否是整型、正数、处于安全数值范围、立方根、三角函数、对数运算。 // 二进制 八进制表示console.log('B',0B111110111);console.log(0o767);// 是否是正常数值console.log('15',Number.isFinite(15));console.log('NaN',Number.isFinite(NaN));console.log('1/0',Number.isFinite('true'/0));console.log('NaN',Number.isNaN(NaN));console.log('0',Number.isNaN(0));// 是否整形console.log('25',Number.isInteger(25));console.log('25.0',Number.isInteger(25.0));console.log('25.1',Number.isInteger(25.1));console.log('25.1',Number.isInteger('25'));// 安全值console.log(Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);console.log('10',Number.isSafeInteger(10));console.log('a',Number.isSafeInteger('a'));// 取整数位console.log(4.1,Math.trunc(4.1));console.log(4.9,Math.trunc(4.9));// 判断正负数 零console.log('-5',Math.sign(-5));console.log('0',Math.sign(0));console.log('5',Math.sign(5));console.log('50',Math.sign('50'));console.log('foo',Math.sign('foo'));// 立方根console.log('-1',Math.cbrt(-1));console.log('8',Math.cbrt(8)); 函数的扩展参数默认值 function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; rest参数 ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 严格模式 从 ES5 开始，函数内部可以设定为严格模式。 function doSomething(a, b) &#123; 'use strict'; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; name属性 函数的name属性，返回该函数的函数名。这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 function foo() &#123;&#125;foo.name // "foo"var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" 箭头函数 var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 双冒号运算符 用来取代call、apply、bind调用。 foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 尾部调用优化 尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function f(x)&#123; return g(x);&#125; 优化 function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 尾递归 函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120// orfunction tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 数组的扩展扩展运算符 rest逆运算。 Array.from Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 // NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; Array.of Array.of方法用于将一组值，转换为数组。let arr = Array.of(3, 4, 7, 9, 11);console.log('arr=', arr);let empty = Array.of();console.log('empty', empty); copyWithin 数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 Array.prototype.copyWithin(target, start = 0, end = this.length) target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 // 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] find\findIndex 数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 fill fill方法使用给定值，填充一个数组。 ['a', 'b', 'c'].fill(7)// [7, 7, 7] fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 ['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] entries\keys\values for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" inludes Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 [1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 对象的扩展Object.is 用来代替相等与严格相等运算符。 Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true symbolES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 let s = Symbol();typeof s// "symbol"// -----let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar)s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)"// --------// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false// --------let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" Symbol 作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b');obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)]let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] Symbol.for()，Symbol.keyFor() let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true// -----Symbol.for("bar") === Symbol.for("bar")// trueSymbol("bar") === Symbol("bar")// false// ----// Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。let s1 = Symbol.for("foo");Symbol.keyFor(s1) // "foo"let s2 = Symbol("foo");Symbol.keyFor(s2) // undefined set &amp;&amp; mapset ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 Set 函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。 // 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]// 例二const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);items.size // 5// 例三const set = new Set(document.querySelectorAll('div'));set.size // 56// 类似于const set = new Set();document .querySelectorAll('div') .forEach(div =&gt; set.add(div));set.size // 56// 去除数组的重复成员[...new Set(array)] Set 实例的属性和方法 size add() delete() has() clear() s.add(1).add(2).add(2);// 注意2被加入了两次s.size // 2s.has(1) // trues.has(2) // trues.has(3) // falses.delete(2);s.has(2) // false Array.from方法可以将 Set 结构转为数组。 const items = new Set([1, 2, 3, 4, 5]);const array = Array.from(items);function dedupe(array) &#123; return Array.from(new Set(array));&#125;dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历 let set = new Set(['red', 'green', 'blue']);for (let item of set.keys()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.values()) &#123; console.log(item);&#125;// red// green// bluefor (let item of set.entries()) &#123; console.log(item);&#125;// ["red", "red"]// ["green", "green"]// ["blue", "blue"]for (let x of set) &#123; console.log(x);&#125;// red// green// blueset = new Set([1, 4, 9]);set.forEach((value, key) =&gt; console.log(key + ' : ' + value))// 1 : 1// 4 : 4// 9 : 9 使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]);// 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125;// 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125;// 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; WeakSet WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。 首先，WeakSet 的成员只能是对象，而不能是其他类型的值。 const ws = new WeakSet();ws.add(1)// TypeError: Invalid value used in weak setws.add(Symbol())// TypeError: invalid value used in weak set 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。 三个方法: const ws = new WeakSet();const obj = &#123;&#125;;const foo = &#123;&#125;;ws.add(window);ws.add(obj);ws.has(window); // truews.has(foo); // falsews.delete(window);ws.has(window); // false WeakSet 没有size属性，没有办法遍历它的成员。 map 类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。 const m = new Map();const o = &#123;p: 'Hello World'&#125;;m.set(o, 'content')m.get(o) // "content"m.has(o) // truem.delete(o) // truem.has(o) // false// ---const map = new Map([ ['name', '张三'], ['title', 'Author']]);map.size // 2map.has('name') // truemap.get('name') // "张三"map.has('title') // truemap.get('title') // "Author" 遍历方法 const map = new Map([ ['F', 'no'], ['T', 'yes'],]);for (let key of map.keys()) &#123; console.log(key);&#125;// "F"// "T"for (let value of map.values()) &#123; console.log(value);&#125;// "no"// "yes"for (let item of map.entries()) &#123; console.log(item[0], item[1]);&#125;// "F" "no"// "T" "yes"// 或者for (let [key, value] of map.entries()) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes"// 等同于使用map.entries()for (let [key, value] of map) &#123; console.log(key, value);&#125;// "F" "no"// "T" "yes" Map 结构转为数组结构，比较快速的方法是使用扩展运算符（…）。 const map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);[...map.keys()]// [1, 2, 3][...map.values()]// ['one', 'two', 'three'][...map.entries()]// [[1,'one'], [2, 'two'], [3, 'three']][...map]// [[1,'one'], [2, 'two'], [3, 'three']] WeakMap WeakMap与Map的区别有两点。 首先，WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。 其次，WeakMap的键名所指向的对象，不计入垃圾回收机制。 proxy &amp;&amp; reflect&#123; let obj = &#123; // 供应商 time: '2017-03-11', name: 'net', _r: 123 &#125;; let monitor = new Proxy(obj, &#123; // 代理商 // 拦截对象属性的读取 get(target, key) &#123; return target[key].replace('2017', '2018') &#125;, // 拦截对象设置属性 set(target, key, value) &#123; if (key === 'name') &#123; return target[key] = value; &#125; else &#123; return target[key]; &#125; &#125;, // 拦截key in object操作 has(target, key) &#123; if (key === 'name') &#123; return target[key] &#125; else &#123; return false; &#125; &#125;, // 拦截delete deleteProperty(target, key) &#123; if (key.indexOf('_') &gt; -1) &#123; delete target[key]; return true; &#125; else &#123; return target[key] &#125; &#125;, // 拦截Object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames ownKeys(target) &#123; return Object.keys(target).filter(item =&gt; item != 'time') &#125; &#125;); console.log('get', monitor.time); monitor.time = '2018'; monitor.name = 'mukewang'; console.log('set', monitor.time, monitor); console.log('has', 'name' in monitor, 'time' in monitor); // delete monitor.time; // console.log('delete',monitor); // // delete monitor._r; // console.log('delete',monitor); console.log('ownKeys', Object.keys(monitor));&#125;&#123; let obj = &#123; time: '2017-03-11', name: 'net', _r: 123 &#125;; console.log('Reflect get', Reflect.get(obj, 'time')); Reflect.set(obj, 'name', 'mukewang'); console.log(obj); console.log('has', Reflect.has(obj, 'name'));&#125;// proxy 应用 数据校验&#123; function validator(target, validator) &#123; return new Proxy(target, &#123; _validator: validator, set(target, key, value, proxy) &#123; if (target.hasOwnProperty(key)) &#123; let va = this._validator[key]; if (!!va(value)) &#123; return Reflect.set(target, key, value, proxy) &#125; else &#123; throw Error(`不能设置$&#123;key&#125;到$&#123;value&#125;`) &#125; &#125; else &#123; throw Error(`$&#123;key&#125; 不存在`) &#125; &#125; &#125;) &#125; const personValidators = &#123; name(val) &#123; return typeof val === 'string' &#125;, age(val) &#123; return typeof val === 'number' &amp;&amp; val &gt; 18 &#125;, mobile(val) &#123; &#125; &#125; class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; this.mobile = '1111'; return validator(this, personValidators) &#125; &#125; const person = new Person('lilei', 30); console.info(person); person.name = 'Han mei mei'; console.info(person);&#125; 类与对象待整理… promise&#123; // 基本定义 let ajax = function (callback) &#123; console.log('执行'); setTimeout(function () &#123; callback &amp;&amp; callback.call() &#125;, 1000); &#125;; ajax(function () &#123; console.log('timeout1'); &#125;)&#125;&#123; let ajax = function () &#123; console.log('执行2'); return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve() &#125;, 1000); &#125;) &#125;; ajax().then(function () &#123; console.log('promise', 'timeout2'); &#125;)&#125;&#123; let ajax = function () &#123; console.log('执行3'); return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve() &#125;, 1000); &#125;) &#125;; ajax() .then(function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve() &#125;, 2000); &#125;); &#125;) .then(function () &#123; console.log('timeout3'); &#125;)&#125;&#123; let ajax = function (num) &#123; console.log('执行4'); return new Promise(function (resolve, reject) &#123; if (num &gt; 5) &#123; resolve() &#125; else &#123; throw new Error('出错了') &#125; &#125;) &#125; ajax(6).then(function () &#123; console.log('log', 6); &#125;).catch(function (err) &#123; console.log('catch', err); &#125;); ajax(3).then(function () &#123; console.log('log', 3); &#125;).catch(function (err) &#123; console.log('catch', err); &#125;);&#125;&#123; // 所有图片加载完再添加到页面 function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img'); img.src = src; img.onload = function () &#123; resolve(img); &#125; img.onerror = function (err) &#123; reject(err); &#125; &#125;) &#125; function showImgs(imgs) &#123; imgs.forEach(function (img) &#123; document.body.appendChild(img); &#125;) &#125; Promise.all([ loadImg('http://i4.buimg.com/567571/df1ef0720bea6832.png'), loadImg('http://i4.buimg.com/567751/2b07ee25b08930ba.png'), loadImg('http://i2.muimg.com/567751/5eb8190d6b2a1c9c.png') ]).then(showImgs)&#125;&#123; // 有一个图片加载完就添加到页面 function loadImg(src) &#123; return new Promise((resolve, reject) =&gt; &#123; let img = document.createElement('img'); img.src = src; img.onload = function () &#123; resolve(img); &#125; img.onerror = function (err) &#123; reject(err); &#125; &#125;) &#125; function showImgs(img) &#123; let p = document.createElement('p'); p.appendChild(img); document.body.appendChild(p) &#125; Promise.race([ loadImg('http://i4.buimg.com/567571/df1ef0720bea6832.png'), loadImg('http://i4.buimg.com/567751/2b07ee25b08930ba.png'), loadImg('http://i2.muimg.com/567751/5eb8190d6b2a1c9c.png') ]).then(showImgs)&#125; // 异步加载图片function loadImageAsync(url) &#123; return new Promise(function(resolve, reject) &#123; const image = new Image(); image.onload = function() &#123; resolve(image); &#125;; image.onerror = function() &#123; reject(new Error('Could not load image at ' + url)); &#125;; image.src = url; &#125;);&#125;// ajax promise封装const getJSON = function(url) &#123; const promise = new Promise(function(resolve, reject)&#123; const handler = function() &#123; if (this.readyState !== 4) &#123; return; &#125; if (this.status === 200) &#123; resolve(this.response); &#125; else &#123; reject(new Error(this.statusText)); &#125; &#125;; const client = new XMLHttpRequest(); client.open("GET", url); client.onreadystatechange = handler; client.responseType = "json"; client.setRequestHeader("Accept", "application/json"); client.send(); &#125;); return promise;&#125;;getJSON("/posts.json").then(function(json) &#123; console.log('Contents: ' + json);&#125;, function(error) &#123; console.error('出错了', error);&#125;); iterator各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for…of循环，Iterator 接口主要供for…of消费。 var it = makeIterator(['a', 'b']);it.next() // &#123; value: "a", done: false &#125;it.next() // &#123; value: "b", done: false &#125;it.next() // &#123; value: undefined, done: true &#125;function makeIterator(array) &#123; var nextIndex = 0; return &#123; next: function() &#123; return nextIndex &lt; array.length ? &#123;value: array[nextIndex++], done: false&#125; : &#123;value: undefined, done: true&#125;; &#125; &#125;;&#125; 原生具备 Iterator 接口的数据结构如下。 Array Map Set String TypedArray 函数的 arguments 对象 NodeList 对象 下面的例子是数组的Symbol.iterator属性。 let arr = ['a', 'b', 'c'];let iter = arr[Symbol.iterator]();iter.next() // &#123; value: 'a', done: false &#125;iter.next() // &#123; value: 'b', done: false &#125;iter.next() // &#123; value: 'c', done: false &#125;iter.next() // &#123; value: undefined, done: true &#125; 一个对象如果要具备可被for…of循环调用的 Iterator 接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 class RangeIterator &#123; constructor(start, stop) &#123; this.value = start; this.stop = stop; &#125; [Symbol.iterator]() &#123; return this; &#125; next() &#123; var value = this.value; if (value &lt; this.stop) &#123; this.value++; return &#123;done: false, value: value&#125;; &#125; return &#123;done: true, value: undefined&#125;; &#125;&#125;function range(start, stop) &#123; return new RangeIterator(start, stop);&#125;for (var value of range(0, 3)) &#123; console.log(value); // 0, 1, 2&#125; let obj=&#123; start:[1,3,2], end:[7,9,8], [Symbol.iterator]()&#123; let self=this; let index=0; let arr=self.start.concat(self.end); let len=arr.length; return &#123; next()&#123; if(index&lt;len)&#123; return &#123; value:arr[index++], done:false &#125; &#125;else&#123; return &#123; value:arr[index++], done:true &#125; &#125; &#125; &#125; &#125;&#125;for(let key of obj)&#123; console.log(key);&#125; generatorGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。 function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator(); &#123; // genertaor基本定义 let tell=function* ()&#123; yield 'a'; yield 'b'; return 'c' &#125;; let k=tell(); console.log(k.next()); console.log(k.next()); console.log(k.next()); console.log(k.next());&#125;&#123; let obj=&#123;&#125;; obj[Symbol.iterator]=function* ()&#123; yield 1; yield 2; yield 3; &#125; for(let value of obj)&#123; console.log('value',value); &#125;&#125;&#123; let state=function* ()&#123; while(1)&#123; yield 'A'; yield 'B'; yield 'C'; &#125; &#125; let status=state(); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next()); console.log(status.next());&#125;// &#123;// let state=async function ()&#123;// while(1)&#123;// await 'A';// await 'B';// await 'C';// &#125;// &#125;// let status=state();// console.log(status.next());// console.log(status.next());// console.log(status.next());// console.log(status.next());// console.log(status.next());// &#125;//&#123; let draw=function(count)&#123; //具体抽奖逻辑 console.info(`剩余$&#123;count&#125;次`) &#125; let residue=function* (count)&#123; while (count&gt;0) &#123; count--; yield draw(count); &#125; &#125; let star=residue(5); let btn=document.createElement('button'); btn.id='start'; btn.textContent='抽奖'; document.body.appendChild(btn); document.getElementById('start').addEventListener('click',function()&#123; star.next(); &#125;,false)&#125;&#123; // 长轮询 let ajax=function* ()&#123; yield new Promise(function(resolve,reject)&#123; setTimeout(function () &#123; resolve(&#123;code:0&#125;) &#125;, 200); &#125;) &#125; let pull=function()&#123; let genertaor=ajax(); let step=genertaor.next(); step.value.then(function(d)&#123; if(d.code!=0)&#123; setTimeout(function () &#123; console.info('wait'); pull() &#125;, 1000); &#125;else&#123; console.info(d); &#125; &#125;) &#125; pull();&#125; decorator修饰器是个函数、修改类的行为（扩展类的功能） module导入导出语法import .... from ...exportexport default// 如果模块默认输出一个函数，函数名的首字母应该小写。// 如果模块默认输出一个对象，对象名的首字母应该大写。 export 与 import 的复合写法// foo和bar实际上并没有被导入当前模块，只是相当于对外转发了这两个接口，导致当前模块不能直接使用foo和barexport &#123; foo, bar &#125; from 'my_module';// 可以简单理解为import &#123; foo, bar &#125; from 'my_module';export &#123; foo, bar &#125;;// ---// 具名接口改为默认接口的写法如下export &#123; es6 as default &#125; from './someModule';// 等同于import &#123; es6 &#125; from './someModule';export default es6;// ---// 默认接口也可以改名为具名接口。export &#123; default as es6 &#125; from './someModule'; 使用Eslint# 安装$ npm i -g eslint# 然后，安装 Airbnb 语法规则，以及 import、a11y、react 插件。$ npm i -g eslint-config-airbnb$ npm i -g eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react# 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。&#123; "extends": "eslint-config-airbnb"&#125; 检验文件 eslint index.js]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mongoose API 简单介绍]]></title>
    <url>%2F2018%2F03%2F10%2Fmongoose%2F</url>
    <content type="text"><![CDATA[谈一谈Mongoose 常用API。 connect创建数据库连接。 mongoose.connect(url(s)[, options][, callback])//url(s):数据库地址,可以是多个,以`,`隔开//options:可选,配置参数//callback:可选,回调mongoose.connect('mongodb://数据库地址(包括端口号)/数据库名称') 指定用户连接 mongoose.connect('mongodb://用户名:密码@127.0.0.1:27017/数据库名称') 连接多个数据库 // 设置mongos为truemongoose.connect('urlA,urlB,...', &#123; mongos : true &#125;) schema &amp;&amp; model定义Schema//语法new mongoose.Schema(&#123;字段...&#125;, [options])//实例const mongoose = require('mongoose')const Schema = mongoose.Schemaconst ObjectId = Schema.Types.ObjectIdconst ArticleSchema = new Schema(&#123; title: &#123; type: String, required: true &#125;, contents: String, author: String, category: &#123; type: ObjectId, ref: 'Category' //关联Category表的_id &#125;, createTime: &#123; type: Date, default: Date.now &#125;&#125;, &#123; collection: 'Article', //模型名称,&#125;) 字段类型 String Number Date Buffer Boolean Mixed ObjectId Array schema中不仅仅可以设置字段类型，同时还可以设置默认值（default），关联文档（ref），required等。_一旦设置了字段类型，如果出现错误，比如某字段类型为Boolean，而输入了一个其他类型，mongoose将会抛出类型错误的提示。 options // 常用到的`collection`,其他请参考[文档](http://www.nodeclass.com/api/mongoose.html#index_Mongoose-Schema)&#123; _id : true, //Boolean, 唯一索引, 如果不需要,可以设置为false关闭 collection : '文档名称', //在MongDB中默认使用Model的名字作为集合的名字，如过需要自定义集合的名字，可以通过设置这个选项 versionKey : '__v', //包含文档的内部修订,默认的是__v autoIndex, capped : Number, //上限设置,此属性对批量操作有效，用来限制一次对数据库操作的量 id, //mongoose分配给每一个schema一个虚拟属性id，它是一个getter。返回的是_id转换为字符串后的值 read, safe, shardKey, strict, toJSON, toObject&#125; Model//语法mongoose.model(`文档名称`, Schema)//实例module.exports = mongoose.model(`Article`, ArticleSchema ) Methods 实例方法 Model的实例是document。内置实例方法如 save，可以通过methods属性给实例自定义扩展方法 ArticleSchema.methods.methodFunc = function() &#123; // body...&#125; Statics 静态方法 model的静态方法很多，如find，update等，可以通过 statics属性给 Model 添加自定义扩展方法 ArticleSchema.statics.staticFunc = function() &#123; // body...&#125; Methods 和 Statics 的区别 statics是给model添加方法，methods是给实例（instance）添加方法。 //接上面代码,//module.exports = mongoose.model(`Article`, ArticleSchema )//将article的model保存为文件 article.jsconst Article = require('../models/article')// staticsArticle.staticFunc ()//methodsconst article = new Article(arguments)article.methodFunc() find查询多条文档 Model.find(conditions, [fields], [options], [callback])conditions &lt;Object&gt; //查询条件[fields] &lt;Object&gt; //要查询的字段[options] &lt;Object&gt; //查询配置参数[callback] &lt;Function&gt; //回调 条件查询： $or 或关系 $nor 或关系取反 $gt 大于 $gte 大于等于 $lt 小于 $lte 小于等于 $ne 不等于 $in 在多个值范围内 $nin 不在多个值范围内 $all 匹配数组中多个值 $regex 正则，用于模糊查询 $size 匹配数组大小 $maxDistance 范围查询，距离（基于LBS） $mod 取模运算 $near 邻域查询，查询附近的位置（基于LBS） $exists 字段是否存在 $elemMatch 匹配内数组内的元素 $within 范围查询（基于LBS） $box 范围查询，矩形范围（基于LBS） $center 范围醒询，圆形范围（基于LBS） $centerSphere 范围查询，球形范围（基于LBS） $slice 查询字段集合中的元素（比如从第几个之后，第N到第M个元素 例如查询阅读量大于500小于600的文章 Article.find(&#123;views : &#123;$gte : 500 , $lte : 600&#125;&#125;) findByIdfindById 用来通过id查询单条文档 Model.findById(id, [fields], [options], [callback]) findOnefindOne 用来通过条件查询单条文档 Model.findOne(conditions, [fields], [options], [callback]) populatepopulate用于查看关联文档内容, 也就是查询 设置了 ref 的字段关联的 文档的相关字段 Model.populate(docs, options, [cb(err,doc)])//示例yield Article.findOne(&#123;_id : id&#125;, &#123;title : 1, author : 1&#125;) .populate('category', &#123;select : &#123;name : 1, _id : 1&#125;&#125;)//查找_id 为 id 的文章的category字段对应的category表中的分类名称和id//多个关联表需要使用数组yield Article.findOne(&#123; _id: id &#125;, &#123; title: 1, author: 1 &#125;) .populate([&#123; path: 'comments', //文章的comments字段 select: &#123; _id: 1, user: 1, text: 1, &#125;, &#125;, &#123; path: 'category' //文章的category字段, select: &#123; fields... &#125; &#125;]) 分页和排序 yield Article.findOne(&#123; _id: id&#125;, &#123; title: 1, author: 1&#125;, &#123; sort: &#123; createTime: -1, //倒序 desc _id: -1 &#125;, skip: (page - 1) * pageSize, //page : 当前页码, pageSize 每页显示条数 limit: pageSize&#125;)// sort : -1 =&gt; desc , a =&gt; asc countcount方法用来统计符合条件的文档集合的总数 Model.count(conditions, [callback]) updateModel.update(conditions, update, [options], [callback])//查找并更新Model.findByIdAndUpdate(id, [update], [options], [callback])Model.findOneAndUpdate([conditions], [update], [options], [callback]) 更新修改器`$inc` 增减修改器，只对数字有效。Article.update(&#123;_id : id&#125;, &#123;$inc : &#123;views : 1&#125;&#125;)//找到id=_id记录，并且将 views递增，返回后的views为之前的views+1。ps：这个属性很有用，对数字直接进行增减。用于更新一些数字（如阅读数）很有用`$set` 指定字段的值，这个字段不存在就创建它。可以是任何MondoDB支持的类型。Article.update(&#123;_id : id&#125;, &#123;$set : &#123;views : 51, title : '修改后的标题' ...&#125;&#125;)//更新后views为51,标题为'修改后的标题'`$unset` 同上取反，删除一个字段Article.update(&#123;views : 50&#125;, &#123;$unset : &#123;views : 'remove'&#125;&#125;) //执行后: views字段不存在可选参数, 第三个参数&#123; new: true, //为true：返回update后的文档，false：返回update前的，默认是false sort: null, //排序条件，与sort函数的参数一致。 fields: null， //要返回的字段, 与find*的第二个参数一致。 upsert: null, // 如果是true，表示如果没有符合查询选择器的文档，mongo将会综合第一第二个参数向集合插入一个新的文档 multi: false, //true:更新匹配到的所有文档，false：更新匹配到的第一个文档&#125; savesave是一个实例方法，使用时需要先 new Model() 来获取实例 const article = new Article(&#123; //字段 =&gt; value //...&#125;)yield article.save() removeModel.remove(conditions, [callback])//查找并删除Model.findByIdAndRemove(id, [options], [callback])Model.findOneAndRemove(conditions, [options], [callback]) server.jsconst express = require('express')const mongoose = require('mongoose')// 链接mongo 并且使用imooc这个集合const DB_URL = 'mongodb://localhost:27017/imooc'mongoose.connect(DB_URL)mongoose.connection.on('connected',function()&#123; console.log('mongo connect success')&#125;)// 类似于mysql的表 mongo里有文档、字段的概念，const User = mongoose.model('user', new mongoose.Schema(&#123; user:&#123;type:String,require:true&#125;, age:&#123;type:Number,require:true&#125;&#125;))// 新增数据// User.create(&#123;// user:'xiaohua',// age:12// &#125;,function(err, doc)&#123;// if (!err) &#123;// console.log(doc)// &#125;else&#123;// console.log(err)// &#125;// &#125;)// 新建app// User.remove(&#123;age:18&#125;,function(err,doc)&#123;// console.log(doc)// &#125;)// User.update(&#123;'user':'xiaoming'&#125;,&#123;'$set':&#123;age:26&#125;&#125;,function(err,doc)&#123;// console.log(doc)// &#125;)const app = express()app.get('/',function(req,res)&#123; res.send('&lt;h1&gt;Hello world&lt;/h1&gt;')&#125;) app.get('/data',function(req,res)&#123; User.findOne(&#123;user:'xiaoming'&#125;,function(err,doc)&#123; res.json(doc) &#125;)&#125;)// app.get('/delete',function()&#123;// &#125;)app.listen(9093,function()&#123; console.log('Node app start at port 9093')&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[babel使用]]></title>
    <url>%2F2018%2F02%2F28%2Fbabel%2F</url>
    <content type="text"><![CDATA[babel 使用总结。 配置文件.babelrc该文件用来设置转码规则和插件，基本格式如下。&#123; "presets": [], "plugins": []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。# ES2015转码规则$ npm install --save-dev babel-preset-latest# react转码规则$ npm install --save-dev babel-preset-react# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 将这些规则加入.babelrc。&#123; "presets": [ "latest", "react", "stage-2" ], "plugins": []&#125; 命令行转码babel-cli# 全局安装$ npm install --global babel-cli# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s 上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel。 # 安装$ npm install --save-dev babel-cli 然后，改写package.json。 &#123; // ... "devDependencies": &#123; "babel-cli": "^6.0.0" &#125;, "scripts": &#123; "build": "babel src -d lib" &#125;,&#125; 转码 $ npm run build babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入 REPL 环境。 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 $ babel-node es6.js babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 $ npm install --save babel-polyfill 在脚本头部，加入如下一行代码。 import 'babel-polyfill';// 或者require('babel-polyfill'); 与其他工具的配合许多工具需要 Babel 进行前置转码，这里举两个例子：ESLint 和 Mocha。 ESLint 用于静态检查代码的语法和风格，安装命令如下。 $ npm install --save-dev eslint babel-eslint 然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。&#123; "parser": "babel-eslint", "rules": &#123; ... &#125;&#125; 再在package.json之中，加入相应的scripts脚本。&#123; "name": "my-module", "scripts": &#123; "lint": "eslint my-files.js" &#125;, "devDependencies": &#123; "babel-eslint": "...", "eslint": "..." &#125;&#125; Mocha 则是一个测试框架，如果需要执行使用 ES6 语法的测试脚本，可以修改package.json的scripts.test。 "scripts": &#123; "test": "mocha --ui qunit --compilers js:babel-core/register"&#125; 上面命令中，–compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mongodb语法简单介绍]]></title>
    <url>%2F2018%2F02%2F22%2Fmongodb%2F</url>
    <content type="text"><![CDATA[用于node项目的mongodb数据库简介。 数据库# 查看所有的数据库show dbs;# 查看当前窗口所在的数据库db;use 数据库名 # 如果数据库不存在，则创建数据库，否则切换到指定数据库。# 注：show dbs执行结果没有看到test库，但是db查看当前库确是test库，因为test库中刚开始没有任何数据并且是在内存中的，有了数据后就会显示出来了（其他新创建的数据库也是如此）# 删除当前数据库，默认为 test，故要切换到某个数据库下进行删除db.dropDatabase(); 集合# 显式创建集合db.createCollection("collectionName"); # 创建一个名为collectionName的集合，创建完成后会返回 &#123;"ok",1&#125; json串#隐式创建集合：db.collection2.insert(&#123;name:"xiaomu",age:20&#125;); # 往collection2集合中添加数据来创建集合，如果集合不存在就自动创建集合，返回：WriteResult(&#123;"nInserted":1&#125;)# 查看集合show collections;# 统计集合collection1中的数据数量db.collection1.count();# 删除集合collection1db.collection1.drop();#注：mongo中支持js，可通过js操作实现批量处理，如：for(var i=0;i&lt;1000;i++)&#123;db.collection2.insert(&#123;name:"xiaomu"+i,age:20+i&#125;);&#125; 固定集合固定集合指的是事先创建而且大小固定的集合。 固定集合特性：固定集合很想环形队列，如果空间不足，最早的文档就会被删除，为新的文档腾出空间。一般来说，固定集合适用于任何想要自动淘汰过期属性的场景，没有太多的操作限制.db.createCollection("collectionName",&#123;capped:true,size:10000,max:100&#125;); # size指定集合大小，单位为KB，max指定文档数量# 当文档数量上限时必须同时指定大小。淘汰机制只有在容量还没满时才会依据数量来工作。要是容量满了则会依据容量来工作。 查询固定条件查询：注：mongodb中每条数据都有一个id，用来唯一标识一条数据，id由mongo本身来维护 db.collection1.find(); # 查询集合中所有的数据db.collection1.find(&#123;age:7&#125;); # 查询年龄为7的数据db.collection1.find(&#123;age:7&#125;,&#123;name:1&#125;); # 查询年龄为7的数据，只返回name字段数据；两个大括号，前面的存查询条件，后面的存返回条件，返回条件字段1表示true，表示此字段返回，如果name后面的1改为0则表示不返回name字段，返回除name字段以外的其他字段# 注意：如果设置返回字段有为0的已经表示查询所有除了某字段以外的所有字段就不能再设置某个字段为1了，有语法冲突db.collection1.find(&#123;age:7,name:"xiaomu"&#125;,&#123;name:1,age:1&#125;); # 查询age为7，name为xiaomu的数据，返回name和age字段# 注：多条件查询此处是并列，但是如果多个条件都相同的话如&#123;name:"xiaoli",name:"xioamu"&#125;则会只查询后一个条件的数据db.collection1.find(&#123;&#125;,&#123;age:1&#125;); # 查询所有的数据，返回age字段db.collection1.findOne(); # 查询集合的第一条数据 筛选查询： gt(greater than)大于 lt（less than）小于 gte(greater then equal)大于等于 lte(less than equal)小于等于 ne（not equal）不等于 db.collection1.find(&#123;age:&#123;$gt:10&#125;&#125;); # 查询age大于10的数据包含db.collection1.find(&#123;price:&#123;$all:[1,2]&#125;&#125;); #（包含。。并且包含。。）此处price是个数组，此方法查询所有price包含1和2的数据db.collection1.find(&#123;price:&#123;$in:[1,2]&#125;&#125;); #（包含。。或者包含。。）查询price中含有1或者2的数据db.collection1.find(&#123;price:&#123;$nin:[1,2]&#125;&#125;); #（不包含。。并且不包含。。）查询price中不含有1并且不含有2的数据db.collection1.find(&#123;$or:[&#123;name:"xiaomu"&#125;,&#123;price:&#123;$in:[3]&#125;&#125;]&#125;); #（。。或者。。）查询name为xiaomu或者价格包含3的数据db.collection1.find(&#123;$nor:[&#123;name:"xiaomu"&#125;,&#123;name:"xiaoli"&#125;]&#125;); #（既不也不）查询name不为xiaomu或者name不为xiaoli的数据 分页db.collection1.find().skip(0).limit(10); # 查询从0条开始，查询10条，skip()方法默认参数为 0 ，表示跳过的条数 排序db.collection1.find().sort(&#123;age:1&#125;); # 按照年龄升序排序，为-1的话表示降序排序 存在db.c2.find(&#123;hight:&#123;$exists:1&#125;&#125;); # 查询存在hight字段的数据 删除db.collection1.remove(&#123;age:7,name:"xiaomu"&#125;); # 删除age为7，name为xiaomu的数据 更新db.c3.update(&#123;age:12&#125;,&#123;name:"xiaoxiao"&#125;); # 本意为将age为12的数据中的name更新为xiaoxiao，但是实际效果是只是将age为12的满足条件数据的第一条整条数据覆盖为name：“xiaoxiao”db.c3.update(&#123;age:15&#125;,&#123;$set:&#123;name:"xiaolili"&#125;&#125;); # 本意为将age为15的数据的name修改为xiaolili，但是实际效果是只修改了查询到的第一条数据db.c3.update(&#123;age:15&#125;,&#123;$set:&#123;name:"xiaolili"&#125;&#125;,1,1); # 将age为15的数据的name修改为xiaolili#总共4个参数，第四个参数表示有多条数据符合筛选条件的话是否全部更改，默认为0只改第一条，改为1后表示全部更改。#第3个参数1表示如果没有符合条件的记录是否新增一条记录，1表示新增，0表示不新增db.c3.update(&#123;age:21&#125;,&#123;$set:&#123;name:"xiaolili"&#125;&#125;,1,1); # 如果不存在age为21的数据则增加一条，增加的数据为&#123;age:12，name:”xiaolili”&#125;db.c3.update(&#123;age:12&#125;,&#123;name:"xiaoxiao"&#125;,&#123;$inc:&#123;age:-2&#125;&#125;,1,1); # $inc表示使某个键值加减指定的数值，此处表示将name为xiaoxiao的数据的age字段的值减2db.c3.update(&#123;age:12&#125;,&#123;name:"xiaoxiao"&#125;,&#123;$inc:&#123;age:1&#125;&#125;,0,1); # $unset用来删除某个键，此处表示删除name为xiaoxiao的数据的age字段 索引mongo默认为每条数据的_id字段建索引 db.c3.ensureIndex(&#123;age:1&#125;); # 为age字段建普通索引db.c3.dropIndex(&#123;age:1&#125;); # 删除age字段的索引db.c3.ensureIndex(&#123;age:1&#125;,&#123;unique:true&#125;); # 为age字段建唯一索引，在为字段建了唯一索引后就不能再添加相同值的记录了 数据备份与恢复备份：mongodump -h dbhost -d dbname -o dbdirectory -h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017-d：需要备份的数据库实例，如：test-o：需要备份的数据存放的位置，例如：d:\data (如果没有则自动创建)恢复：mongorestore -h dbhost -d dbname -directoryperdb dbdirectory-h：mongodb所在服务器地址，如127.0.0.1，当然也可以指定端口号：127.0.0.1:27017-d：需要备份的数据库实例，如：test，此名称也可以和备份的时候不一样-directoryperdb ：备份数据所在的位置，例如：d:\data注意：恢复时要在退出mongo命令行状态下执行 导入与导出导出：mongoexport -d dbname -c collectionName -o output -h：数据库地址-d：指明使用的库-c：指明要导出的集合-o：指明要导出的文件路径加文件名，文件名可以是txt、word、excel等多种文件格式导入：mongoimport -d dbname -c collectionname --file 文件的地址路径-h：数据库地址-d：指明使用的库-c：指明要导出的集合 注意：导入时要在退出mongo命令行状态下执行，导入导出与数据备份和恢复相似]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebSocket简介]]></title>
    <url>%2F2018%2F02%2F02%2FWebSocket%2F</url>
    <content type="text"><![CDATA[WebSocket 是一种网络通信协议，很多高级功能都需要它。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 WebSocket 握手浏览器发出的 WebSocket 握手请求类似于下面的样子：GET / HTTP/1.1Connection: UpgradeUpgrade: websocketHost: example.comOrigin: nullSec-WebSocket-Key: sN9cRrP/n9NdMgdcy2VJFQ==Sec-WebSocket-Version: 13 服务器的 WebSocket 回应如下HTTP/1.1 101 Switching ProtocolsConnection: UpgradeUpgrade: websocketSec-WebSocket-Accept: fFBooB7FAkLlXgRSz0BT3v4hq5s=Sec-WebSocket-Origin: nullSec-WebSocket-Location: ws://example.com/ 客户端的简单示例var ws = new WebSocket('wss://echo.websocket.org');ws.onopen = function(evt) &#123; console.log('Connection open ...'); ws.send('Hello WebSockets!');&#125;;ws.onmessage = function(evt) &#123; console.log('Received Message: ' + evt.data); ws.close();&#125;;ws.onclose = function(evt) &#123; console.log('Connection closed.');&#125;; 客户端 API构造函数 WebSocketvar ws = new WebSocket('ws://localhost:8080'); 执行上面语句之后，客户端就会与服务器进行连接。 webSocket.readyStatereadyState属性返回实例对象的当前状态，共有四种。 CONNECTING：值为0，表示正在连接。 OPEN：值为1，表示连接成功，可以通信了。 CLOSING：值为2，表示连接正在关闭。 CLOSED：值为3，表示连接已经关闭，或者打开连接失败。 switch (ws.readyState) &#123; case WebSocket.CONNECTING: // do something break; case WebSocket.OPEN: // do something break; case WebSocket.CLOSING: // do something break; case WebSocket.CLOSED: // do something break; default: // this never happens break;&#125; webSocket.onopen指定连接成功后的回调函数。ws.onopen = function () &#123; ws.send('Hello Server!');&#125; 如果要指定多个回调函数，可以使用addEventListener方法。ws.addEventListener('open', function (event) &#123; ws.send('Hello Server!');&#125;); webSocket.onclose指定连接关闭后的回调函数。ws.onclose = function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;;ws.addEventListener("close", function(event) &#123; var code = event.code; var reason = event.reason; var wasClean = event.wasClean; // handle close event&#125;); webSocket.onmessage指定收到服务器数据后的回调函数ws.onmessage = function(event) &#123; var data = event.data; // 处理数据&#125;;ws.addEventListener("message", function(event) &#123; var data = event.data; // 处理数据&#125;); 注意，服务器数据可能是文本，也可能是二进制数据（blob对象或Arraybuffer对象）。ws.onmessage = function(event)&#123; if(typeOf event.data === String) &#123; console.log("Received data string"); &#125; if(event.data instanceof ArrayBuffer)&#123; var buffer = event.data; console.log("Received arraybuffer"); &#125;&#125; 除了动态判断收到的数据类型，也可以使用binaryType属性，显式指定收到的二进制数据类型。// 收到的是 blob 数据ws.binaryType = "blob";ws.onmessage = function(e) &#123; console.log(e.data.size);&#125;;// 收到的是 ArrayBuffer 数据ws.binaryType = "arraybuffer";ws.onmessage = function(e) &#123; console.log(e.data.byteLength);&#125;; webSocket.send()向服务器发送数据// 发送文本ws.send('your message');// 发送 Blob 对象var file = document .querySelector('input[type="file"]') .files[0];ws.send(file);// 发送 ArrayBuffer 对象// Sending canvas ImageData as ArrayBuffervar img = canvas_context.getImageData(0, 0, 400, 320);var binary = new Uint8Array(img.data.length);for (var i = 0; i &lt; img.data.length; i++) &#123; binary[i] = img.data[i];&#125;ws.send(binary.buffer); webSocket.bufferedAmount实例对象的bufferedAmount属性，表示还有多少字节的二进制数据没有发送出去。它可以用来判断发送是否结束。var data = new ArrayBuffer(10000000);socket.send(data);if (socket.bufferedAmount === 0) &#123; // 发送完毕&#125; else &#123; // 发送还没结束&#125; webSocket.onerror指定报错时的回调函数socket.onerror = function(event) &#123; // handle error event&#125;;socket.addEventListener("error", function(event) &#123; // handle error event&#125;); WebSocket 服务器WebSocket 协议需要服务器支持]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布自己的npm包]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm%E5%8C%85%2F</url>
    <content type="text"><![CDATA[封装自己常用的工具方法，做成一个npm包，发布到npm官网，这样下次用就可以直接npm install packageName使用了。 如何编写一个包，不详细说了，其实就是npm init创建一个package.json文件，写下相关信息，需要注意的是里面的main属性，它指明了入口文件，我们在require包的时候，其实就是require这个文件。 相信了解commonjs规范，做一个包并不难。 重点讲发布 npm adduser在npmjs.com注册一个用户。 $ npm adduserUsername: YOUR_USER_NAMEPassword: YOUR_PASSWORDEmail: YOUR_EMAIL@domain.com npm publish将当前模块发布到npmjs.com。· # 先登录$ npm login# 发布$ npm publish# 给发布的包加标签 例如：beta$ npm publish --tag beta 默认的发布标签是latest。 如果模块用ES6写的，发布的时候最好转为ES5。 $ npm install --save-dev babel-cli@6 babel-preset-es2015@6# package.json"scripts": &#123; "build": "babel source --presets babel-preset-es2015 --out-dir distribution", "prepublish": "npm run build"&#125; 运行上面的脚本，会将source目录里面的ES6源码文件，转为distribution目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件.npmignore和.gitignore，分别写入以下内容。 // .npmignoresource// .gitignorenode_modulesdistribution npm owner模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。 # 列出指定模块的维护者$ npm owner ls &lt;package name&gt;# 新增维护者$ npm owner add &lt;user&gt; &lt;package name&gt;# 删除维护者$ npm owner rm &lt;user&gt; &lt;package name&gt; 注意事项： npm 仓库代理要设置成这个npm set registry http://registry.npmjs.org 修改包以后，更改package.json里的version就行了]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写一个属于自己的gitbook]]></title>
    <url>%2F2017%2F11%2F11%2F%E5%A6%82%E4%BD%95%E5%86%99%E4%B8%80%E4%B8%AA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84gitbook%2F</url>
    <content type="text"><![CDATA[来吧！教你用gitbook写本属于自己的书-。- 第一步# 安装淘宝镜像，下载相关包快一些npm install -g cnpm --registry=https://registry.npm.taobao.orgnpm config set registry https://registry.npm.taobao.org/ 第二步# 全局安装gitbook$ cnpm install gitbook -g 第三步# 创建一个目录，进入$ mkdir gitbook-demo$ cd gitbook-demo# 初始化书籍目录$ gitbook init # 编译书籍$ gitbook serve 说明一下： init 以后，目录里会有这两个文件README.md 和 SUMMARY.md ，README.md 是对书籍的简单介绍，SUMMARY.md 是书籍的目录结构。 目录结构长这样： * [javascript简介](README.md)* [语法](chapter1/README.md) * [基本语法](chapter1/section1.1.md) * [数据类型](chapter1/section1.2.md) * [数值](chapter1/section1.3.md) * [字符串](chapter1/section1.4.md) * [对象](chapter1/section1.5.md) * [数组](chapter1/section1.6.md) * [函数](chapter1/section1.7.md) * [运算符](chapter1/section1.8.md) * [数据类型转换](chapter1/section1.9.md) * [错误处理机制](chapter1/section1.10.md) * [编程风格](chapter1/section1.11.md) 编写SUMMARY.md，然后 gitbook init 生成目录结构文件，然后编写各个文件夹中生成的文件。 最后gitbook serve。 gitbook serve 命令实际上会首先调用 gitbook build 编译书籍，完成以后会打开一个 web 服务器，监听在本地的 4000 端口。 gitbook 的其他一些命令 # 指定书籍输出路径$ gitbook build [书籍路径] [输出路径]# serve 命令可以指定端口：gitbook serve --port 2333# 生成 PDF 格式的电子书：$ gitbook pdf ./ ./mybook.pdf# 生成 epub 格式的电子书：$ gitbook epub ./ ./mybook.epub# 生成 mobi 格式的电子书：$ gitbook mobi ./ ./mybook.mobi 小拓展 你可以书籍提交github，在托管书籍的仓库建一个gh-pages分支，将本地编译好的书籍文件（就是那个_book目录里的文件）上传到这个分支，然后就可以使用这个网址访问 http://yourUserName.github.io/bookName 当然也可以发布到gitbook，然而这个网站访问有点慢-.-]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js开发规范]]></title>
    <url>%2F2017%2F11%2F01%2Fjs%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[如何编写规范且便于维护的js代码，请往下看-。- 命名规范变量 命名方法：小驼峰式命名法。 命名规范：前缀应当是名词。(函数的名字前缀为动词，以此区分变量和函数) 命名建议：尽量在变量名字中体现所属类型，如:length、count等表示数字类型；而包含name、title表示为字符串类型。 示例： var maxCount = 10;var tableTitle = 'LoginTable'; 函数 命名方法：小驼峰式命名法。 命名规范：前缀应当为动词。 命名建议：可使用常见动词约定。 常见动词示例： can：判断是否可执行某个动作 has：判断是否含有某个值 is： 判断是否为某个值 set：设置某个值 get：获取某个值 remove：移除某个值 load：加载某些数据 代码示例：// 是否可阅读function canRead() &#123; return true;&#125; // 获取名称function getName() &#123; return this.name;&#125; 常量 命名方法：名称全部大写 命名规范：使用大写字母和下划线来组合命名，下划线用以分割单词。 示例：var MAX_COUNT = 10;var URL = 'http://www.baidu.com'; 构造函数 命名方法：大驼峰式命名法，首字母大写。 命名规范：前缀为名称。 示例： function Student(name) &#123; this.name = name;&#125; var st = new Student('tom'); 类的成员 公共属性和方法：跟变量和函数的命名一样。 私有属性和方法：前缀为_(下划线)，后面跟公共属性和方法一样的命名方式。 示例： function Student(name) &#123; var _name = name; // 私有成员 // 公共方法 this.getName = function () &#123; return _name; &#125; // 公共方式 this.setName = function (value) &#123; _name = value; &#125;&#125;var st = new Student('tom');st.setName('jerry');console.log(st.getName()); // =&gt; jerry：输出_name私有变量的值 注释规范单行注释示例： // 调用了一个函数；1)单独在一行setTitle(); var maxCount = 10; // 设置最大量；2)在代码后面注释 // setName(); // 3)注释代码 多行注释/** 代码执行到这里后会调用setTitle()函数* setTitle()：设置title的值*/setTitle(); 函数(方法)注释// sublime DocBlockr 插件可以自动生成/** * [funcDemo description] * @param &#123;[type]&#125; param1 [description] * @param &#123;[type]&#125; param2 [description] * @return &#123;[type]&#125; [description] */function funcDemo (param1,param2) &#123; return param1 + param2&#125; 框架开发全局变量冲突团队开发或者引入第三方JS文件时，有时会造成全局对象的名称冲突。 单全局变量所创建的全局对象名称是独一无二的，并将所有的功能代码添加到这个全局对象上。调用自己所写的代码时，以这个全局对象为入口点。 例如： JQuery的全局对象：$和JQuery ExtJS的全局对象： Ext 命名空间在项目规模日益壮大时，可采用命名空间方式对JS代码进行规范：即将代码按照功能进行分组，以组的形式附加到单全局对象上。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue核心内容]]></title>
    <url>%2F2017%2F08%2F28%2Fvue-snippet%2F</url>
    <content type="text"><![CDATA[Vue核心内容总结。 模板&lt;template&gt; &lt;div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; props: &#123; isShow: &#123; type: Boolean, default: true, required: true &#125; &#125;, computed: &#123; num2() &#123; return num + 1 &#125; &#125;, mounted() &#123;&#125;, updated() &#123;&#125;, watch: &#123; num(val, oldVal) &#123; this.init() &#125; &#125; data() &#123; return &#123; num: 0 &#125; &#125;, created() &#123;&#125;, methods() &#123; init() &#123;&#125; &#125;, destroyed() &#123; // clearInterval(timer) &#125;, directives: &#123; focus: &#123; // 指令的定义 inserted: function(el, binding) &#123; // el.focus() &#125; &#125; &#125;, filters: &#123; dateFilter(val) &#123;&#125; &#125;, components: &#123; Header &#125; &#125;&lt;/script&gt; 插件定义方法import GHead from './ghead.vue'import ajax from './ajax.js'function dateFilter(val) &#123; return val + 1&#125;export default &#123; install(Vue) &#123; Vue.component('g-head', GHead) Vue.filter('dateFilter', dateFilter) Vue.directive('focus', &#123; // 被绑定元素插入父节点时调用 inserted(el, binding, vnode) &#123; // 指令所绑定的元素，可以用来直接操作 DOM 。 console.log(el) // 指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2 console.log(binding.value) &#125;, // 所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前 update() &#123;&#125;, // 指令所在组件的 VNode 及其子 VNode 全部更新后调用 componentUpdated() &#123;&#125; &#125;) Vue.prototype.$property = ajax &#125;&#125; 路由import VueRouter from 'vue-router'Vue.use(VueRouter)import User from './user'const routes = [&#123; path: '/', // 重定向 redirect: '/user' // redirect: &#123; name: 'foo' &#125; 别名用法&#125;, &#123; // 写法示范 /user/:id // 获取参数 $route.params.id // 查询参数为 $route.query path: '/user', component: User, // 命名路由 name: 'user', meta: &#123;&#125;, beforeEnter(to, from, next) &#123;&#125;, children: [&#123; path: '', component: Content &#125;]&#125;]const router = new VueRouter(&#123; // 配置了 router 的 Vue 根实例。 app, base, // 路由使用的模式。 mode, // 当前路由对应的路由信息对象。 currentRoute, routes,&#125;) 守卫（1）全局守卫router.beforeEach((to, from, next) =&gt; &#123; // ... // next()&#125;)router.afterEach((to, from) =&gt; &#123; // ...&#125;) 守卫方法参数解析： to: Route: 即将要进入的目标 路由对象 from: Route: 当前导航正要离开的路由 next: Function: 一定要调用该方法来 resolve 这个钩子。 执行效果依赖 next 方法的调用参数。 next(): 进行管道中的下一个钩子。 如果全部钩子执行完了， 则导航的状态就是 confirmed（ 确认的）。 next(false): 中断当前的导航。 如果浏览器的 URL 改变了（ 可能是用户手动或者浏览器后退按钮）， 那么 URL 地址会重置到 from 路由对应的地址。 next(‘/‘) 或者 next({ path: ‘/‘ }): 跳转到一个不同的地址。 当前的导航被中断， 然后进行一个新的导航。 next(error): (2.4 .0 + ) 如果传入 next 的参数是一个 Error 实例， 则导航会被终止且该错误会被传递给 router.onError() 注册过的回调。 （2）组件内的守卫const Foo = &#123; template: `...`, beforeRouteEnter (to, from, next) &#123; // 在渲染该组件的对应路由被 confirm 前调用 // 不！能！获取组件实例 `this` // 因为当守卫执行前，组件实例还没被创建 &#125;, beforeRouteUpdate (to, from, next) &#123; // 在当前路由改变，但是该组件被复用时调用 // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候， // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。 // 可以访问组件实例 `this` &#125;, beforeRouteLeave (to, from, next) &#123; // 导航离开该组件的对应路由时调用 // 可以访问组件实例 `this` &#125;&#125; 路由跳转&lt;router-link :to="..."&gt;&lt;/router-link&gt;// 有时候我们要让激活 class 应用在外层元素，而不是 &lt;a&gt; 标签本身，那么可以用 &lt;router-link&gt; 渲染外层元素，包裹着内层的原生 &lt;a&gt; 标签：&lt;router-link tag="li" to="/foo"&gt; &lt;a&gt;/foo&lt;/a&gt;&lt;/router-link&gt;---// router.push()// 字符串router.push('home')// 对象router.push(&#123; path: 'home' &#125;)// 命名的路由router.push(&#123; name: 'user', params: &#123; userId: 123 &#125;&#125;)// 带查询参数，变成 /register?plan=privaterouter.push(&#123; path: 'register', query: &#123; plan: 'private' &#125;&#125;)const userId = 123router.push(&#123; name: 'user', params: &#123; userId &#125;&#125;) // -&gt; /user/123router.push(&#123; path: `/user/$&#123;userId&#125;` &#125;) // -&gt; /user/123// 这里的 params 不生效router.push(&#123; path: '/user', params: &#123; userId &#125;&#125;) // -&gt; /user---// router.replace()// 代替上一个路由&lt;router-link :to="..." replace&gt;&lt;/router-link&gt;router.replace(...)---// router.go()// 在浏览器记录中前进一步，等同于 history.forward()router.go(1)// 后退一步记录，等同于 history.back()router.go(-1)// 前进 3 步记录router.go(3)// 如果 history 记录不够用，那就默默地失败呗router.go(-100)router.go(100) 你也许注意到 router.push、 router.replace 和 router.go 跟 window.history.pushState、 window.history.replaceState 和 window.history.go好像， 实际上它们确实是效仿 window.history API 的。 命名视图&lt;router-view class="view one"&gt;&lt;/router-view&gt;&lt;router-view class="view two" name="a"&gt;&lt;/router-view&gt;&lt;router-view class="view three" name="b"&gt;&lt;/router-view&gt;routes: [&#123; path: '/', components: &#123; default: Foo, a: Bar, b: Baz &#125;&#125;]// 因为它也是个组件，所以可以配合 &lt;transition&gt; 和 &lt;keep-alive&gt; 使用。如果两个结合一起用，要确保在内层使用 &lt;keep-alive&gt;：&lt;transition&gt; &lt;keep-alive&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt;&lt;/transition&gt; 过渡动效&lt;transition&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; $route属性： $route.path $route.params $route.query $route.hash：当前路由的 hash 值 (带 #) ，如果没有 hash 值，则为空字符串。 $route.fullPath：完成解析后的 URL，包含查询参数和 hash 的完整路径。 $route.matched：一个数组，包含当前路由的所有嵌套路径片段的 路由记录 。路由记录就是 routes 配置数组中的对象副本（还有在 children 数组）。 const router = new VueRouter(&#123; routes: [ // 下面的对象就是 route record &#123; path: '/foo', component: Foo, children: [ // 这也是个 route record &#123; path: 'bar', component: Bar &#125; ] &#125; ]&#125;)当 URL 为 /foo/bar，$route.matched 将会是一个包含从上到下的所有对象（副本）。 $route.name 动画vue transiton/*这个定义动画情况，以及存在时的样式，这个样式会覆盖class里的样式*/ .mytran-transition &#123; transition: all 0.3s ease; background-color: greenyellow; &#125; /* .mytran-enter 定义进入的开始状态 */ /* .mytran-leave 定义离开的结束状态 */ .mytran-enter, .mytran-leave &#123; height: 0; width: 0; &#125;Vue.transition('mytran', &#123; beforeEnter: function (el) &#123; //进入之前 console.log("进入动画开始时间:" + new Date().getTime()); &#125;, enter: function (el) &#123; el.textContent = new Date(); &#125;, afterEnter: function (el) &#123; console.log("进入结束时间:" + new Date().getTime()); &#125;, beforeLeave: function (el) &#123; console.log("离开动画开始时间:" + new Date().getTime()); &#125;, leave: function (el) &#123; $(el).text("离开中..." + new Date()); &#125;, afterLeave: function (el) &#123; console.log("离开结束时间:" + new Date().getTime()); &#125;&#125;) 组件var myCom = Vue.extend(&#123; template: '&lt;div&gt;这是我的组件&lt;/div&gt;'&#125;)&lt;template id="myCom"&gt; &lt;div&gt;这是template标签构建的组件&lt;/div&gt;&lt;/template&gt;&lt;script type="text/x-template" id="myCom1"&gt; &lt;div&gt;这是script标签构建的组件&lt;/div&gt;&lt;/script&gt;Vue.component('my-com',myCom)Vue.component('my-com',&#123; 'template':'&lt;div&gt;这是我的组件&lt;/div&gt;'&#125;)Vue.component('my-com',&#123; template: '#myCom'&#125;)var app = new Vue(&#123; el: '#app', components: &#123; 'my-com': myCom &#125;&#125;)var app = new Vue(&#123; el: '#app', components: &#123; 'my-com': &#123; template: '&lt;div&gt;这是我的组件&lt;/div&gt;' &#125; &#125;&#125;)var app = new Vue(&#123; el: '#app', components: &#123; 'my-com': &#123; template: '#myCom' &#125; &#125;&#125;)// 异步组件Vue.component('async-example', function (resolve, reject) &#123; setTimeout(function () &#123; // 向 `resolve` 回调传递组件定义 resolve(&#123; template: '&lt;div&gt;I am async!&lt;/div&gt;' &#125;) &#125;, 1000)&#125;) 组件传值bus方式的组件间传值其实就是建立一个公共的js文件，专门用来传递消息 1. 建立公共文件，并引入 新建msgBus.js文件。只需两句代码。import Vue from 'vue'export default new Vue; 2. 然后在需要传递消息的两个组件引入import MsgBus from '@/components/utils/msgBus.js'; 3. 发送消息 触发组件的事件： MsgBus.$emit(‘msg’, _this.examineNum); 4.接受消息 接受组件的事件： 写在钩子函数内：例如：mounted created都可以MsgBus.$on('msg', (e) =&gt; &#123; this.examineNum = e;&#125;) 自定义组件demo// toast.jsvar Toast = &#123;&#125;;Toast.install = function (Vue, options) &#123; let opt = &#123; defaultType:'bottom', // 默认显示位置 duration:'2500' // 持续时间 &#125; for(let property in options)&#123; opt[property] = options[property]; // 使用 options 的配置 &#125; Vue.prototype.$toast = (tips,type) =&gt; &#123; if(type)&#123; opt.defaultType = type; // 如果有传type，位置则设为该type &#125; if(document.getElementsByClassName('vue-toast').length)&#123; // 如果toast还在，则不再执行 return; &#125; let toastTpl = Vue.extend(&#123; template: '&lt;div class="vue-toast toast-'+opt.defaultType+'"&gt;' + tips + '&lt;/div&gt;' &#125;); let tpl = new toastTpl().$mount().$el; document.body.appendChild(tpl); setTimeout(function () &#123; document.body.removeChild(tpl); &#125;, opt.duration) &#125; ['bottom', 'center', 'top'].forEach(type =&gt; &#123; Vue.prototype.$toast[type] = (tips) =&gt; &#123; return Vue.prototype.$toast(tips,type) &#125; &#125;)&#125;module.exports = Toast;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Express快速创建Node项目]]></title>
    <url>%2F2017%2F07%2F02%2F%E4%BD%BF%E7%94%A8Express%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BANode%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[NodeJS的Express框架安装介绍。 安装$ npm install -g express-generator #需先安装express-generator $ npm install -g express $ express -V #验证是否安装成功 创建项目$ express myfirstexpress #express的默认模版采用jade，若需要ejs模版支持，加上-e选项，即 express -e myfirstexpress $ cd myfirstexpress $ ls app.js bin package.json public routes views #项目的目录结构 运行项目$ npm install #需要等待一段时间，因为需要获取很多的库文件 $ npm start &gt; myfirstexpress@0.0.1 start /root/myfirstexpress &gt; node ./bin/www 访问浏览器中输入 http://你的IP:3000]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue安装及使用脚手架快速搭建项目]]></title>
    <url>%2F2017%2F06%2F28%2FVue.js%E8%84%9A%E6%89%8B%E6%9E%B6%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[vue.js的安装及使用脚手架工具快速搭建项目结构。 安装 官网下载 CDN BootCDN unpkg cdnjs NPM：在用 Vue.js 构建大型应用时推荐使用 NPM 安装# 最新稳定版$ npm install vue 命令行工具# 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可# 启动$ cd my-project$ npm install$ npm run dev 更新（vue-cli3）脚手架安装和构建 # 安装 Vue CLI 3.xnpm i -g @vue/cli or yarn global add @vue/cli# my-project 是你的项目名称vue create my-project# 打开项目目录cd vue-project# 启动项目 localhost:8080yarn serve# ornpm run serve 目录结构 ├── node_modules # 项目依赖包目录├── public│ ├── favicon.ico # ico图标│ └── index.html # 首页模板├── src │ ├── assets # 样式图片目录│ ├── components # 组件目录│ ├── views # 页面目录│ ├── App.vue # 父组件│ ├── main.js # 入口文件│ ├── router.js # 路由配置文件│ └── store.js # vuex状态管理文件├── .gitignore # git忽略文件├── .postcssrc.js # postcss配置文件├── babel.config.js # babel配置文件├── package.json # 包管理文件└── yarn.lock # yarn依赖信息文件 可视化界面 vue ui # 自动打开本地 8000 端口 vue-cli 包安装 在上述的教程中，我们使用 npm 或 yarn 进行了包的安装和配置，除了以上两种方法，vue-cli 3.x 还提供了其专属的 vue add 命令，但是需要注意的是该命令安装的包是以 @vue/cli-plugin 或者 vue-cli-plugin 开头，即只能安装 Vue 集成的包。 比如运行：vue add jquery 其会安装 vue-cli-plugin-jquery，很显然这个插件不存在便会安装失败。又或者你运行： vue add @vue/eslint 其会解析为完整的包名 @vue/cli-plugin-eslint，因为该包存在所以会安装成功。 同时，不同于 npm 或 yarn 的安装， vue add 不仅会将包安装到你的项目中，其还会改变项目的代码或文件结构，所以安装前最好提交你的代码至仓库。 另外 vue add 中还有两个特例，如下： # 安装 vue-routervue add router# 安装 vuexvue add vuex 这两个命令会直接安装 vue-router 和 vuex 并改变你的代码结构，使你的项目集成这两个配置，并不会去安装添加 vue-cli-plugin 或 @vue/cli-plugin 前缀的包。 参考资料： Webpack 入门教程 官方文档 中文文档]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>VueJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react使用笔记]]></title>
    <url>%2F2017%2F05%2F06%2Freact%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[react使用笔记总结。 使用脚手架$ npm install -g cnpm --registry=https://registry.npm.taobao.org# or $ npm config set registry https://registry.npm.taobao.org$ cnpm install -g create-react-app$ create-react-app my-app$ cd my-app/$ npm start# 弹出配置文件$ npm run eject HTML模板&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="example"&gt;&lt;/div&gt; &lt;script type="text/babel"&gt; // ** Our code goes here! ** &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; JSX语法遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。 ReactDOM.render()// 1ReactDOM.render( &lt;span&gt;Hello React!&lt;/span&gt;, document.getElementById('example') );// 2var names = ['Alice', 'Emily', 'Kate'];ReactDOM.render( &lt;div&gt; &#123; names.map(function (name) &#123; return &lt;div&gt;Hello, &#123;name&#125;!&lt;/div&gt; &#125;) &#125; &lt;/div&gt;, document.getElementById('example'));// 3var arr = [ &lt;h1&gt;Hello world!&lt;/h1&gt;, &lt;h2&gt;React is awesome&lt;/h2&gt;,];ReactDOM.render( &lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById('example')); 组件语法// 创建组件类var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name="John" /&gt;, document.getElementById('example'));// 2class MyTitle extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello World&lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example')); 注意事项： class MyTitle extends React.Component是 ES6 语法，表示自定义一个MyTitle类，该类继承了基类React.Component的所有属性和方法。 React 规定，自定义组件的第一个字母必须大写，比如MyTitle不能写成myTitle，以便与内置的原生类相区分。 每个组件都必须有render方法，定义输出的样式。 表示生成一个组件类的实例，每个实例一定要有闭合标签，写成也可。 组件传参this.props对象class MyTitle extends React.Component &#123; render() &#123; return &lt;h1 style=&#123;&#123;color: this.props.color&#125;&#125;&gt;Hello World&lt;/h1&gt;; &#125; &#125;; ReactDOM.render( &lt;MyTitle color="red" /&gt;, document.getElementById('example') ); 组件的属性可以在组件类的 this.props 对象上获取。 this.props.childrenvar NotesList = React.createClass(&#123; render: function() &#123; return ( &lt;ol&gt; &#123; React.Children.map(this.props.children, function (child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;) &#125; &lt;/ol&gt; ); &#125;&#125;);ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;hello&lt;/span&gt; &lt;span&gt;world&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById('example')); 这里需要注意， this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 React 提供一个工具方法 React.Children 来处理 this.props.children 。我们可以用 React.Children.map 来遍历子节点，而不用担心 this.props.children 的数据类型是 undefined 还是 object。更多的 React.Children 的方法，请参考官方文档。 PropTypes组件的属性可以接受任意值，字符串、对象、函数等等都可以。有时，我们需要一种机制，验证别人使用组件时，提供的参数是否符合要求。 var MyTitle = React.createClass(&#123; propTypes: &#123; title: React.PropTypes.string.isRequired, &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;); 上面的Mytitle组件有一个title属性。PropTypes 告诉 React，这个 title 属性是必须的，而且它的值必须是字符串。如果不满足条件控制台会报错。 getDefaultProps 方法可以用来设置组件属性的默认值。 var MyTitle = React.createClass(&#123; getDefaultProps : function () &#123; return &#123; title : 'Hello World' &#125;; &#125;, render: function() &#123; return &lt;h1&gt; &#123;this.props.title&#125; &lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;MyTitle /&gt;, document.body); 获取真实的DOM节点(ref)var MyComponent = React.createClass(&#123; handleClick: function() &#123; this.refs.myTextInput.focus(); &#125;, render: function() &#123; return ( &lt;div&gt; &lt;input type="text" ref="myTextInput" /&gt; &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render( &lt;MyComponent /&gt;, document.getElementById('example')); 组件的状态(this.state)组件免不了要与用户互动，React 的一大创新，就是将组件看成是一个状态机，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI 。var LikeButton = React.createClass(&#123; getInitialState: function() &#123; return &#123;liked: false&#125;; &#125;, handleClick: function(event) &#123; this.setState(&#123;liked: !this.state.liked&#125;); &#125;, render: function() &#123; var text = this.state.liked ? 'like' : 'haven\'t liked'; return ( &lt;p onClick=&#123;this.handleClick&#125;&gt; You &#123;text&#125; this. Click to toggle. &lt;/p&gt; ); &#125;&#125;);ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById('example')); class MyTitle extends React.Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; name: '访问者' &#125;; &#125; handleChange(e) &#123; let name = e.target.value; this.setState(&#123; name: name &#125;); &#125; render() &#123; return &lt;div&gt; &lt;input type="text" onChange=&#123;this.handleChange.bind(this)&#125; /&gt; &lt;p&gt;你好，&#123;this.state.name&#125;&lt;/p&gt; &lt;/div&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example')); this.setState方法用来重置this.state，每次调用这个方法，就会引发组件的重新渲染。 由于 this.props 和 this.state 都用于描述组件的特性，可能会产生混淆。一个简单的区分方法是，this.props 表示那些一旦定义，就不再改变的特性，而 this.state 是会随着用户互动而产生变化的特性。 表单用户在表单填入的内容，属于用户跟组件的互动，所以不能用 this.props 读取。 var Input = React.createClass(&#123; getInitialState: function() &#123; return &#123;value: 'Hello!'&#125;; &#125;, handleChange: function(event) &#123; this.setState(&#123;value: event.target.value&#125;); &#125;, render: function () &#123; var value = this.state.value; return ( &lt;div&gt; &lt;input type="text" value=&#123;value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;p&gt;&#123;value&#125;&lt;/p&gt; &lt;/div&gt; ); &#125;&#125;);ReactDOM.render(&lt;Input/&gt;, document.body); 组件实战class MyTitle extends React.Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; text: 'World' &#125;; &#125; handleClick() &#123; this.setState(&#123; text: 'Clicked' &#125;); &#125; render() &#123; return &lt;h1 onClick=&#123;this.handleClick.bind(this)&#125;&gt; &#123;'Hello ' + this.state.text&#125; &lt;/h1&gt;; &#125;&#125;;ReactDOM.render( &lt;MyTitle/&gt;, document.getElementById('example')); 组件生命周期组件的生命周期分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM React 为每个状态都提供了两种处理函数，will 函数在进入状态之前调用，did 函数在进入状态之后调用，三种状态共计五种处理函数。 componentWillMount()：组件加载前调用 componentDidMount()：组件加载后调用 componentWillUpdate(): 组件更新前调用 componentDidUpdate(): 组件更新后调用 componentWillUnmount()：组件卸载前调用 componentWillReceiveProps()：组件接受新的参数时调用 此外，React 还提供两种特殊状态的处理函数。 componentWillReceiveProps(object nextProps)：已加载组件收到新的参数时调用 shouldComponentUpdate(object nextProps, object nextState)：组件判断是否重新渲染时调用 我们可以利用这些钩子，自动完成一些操作。class MyList extends React.Component &#123; constructor(...args) &#123; super(...args); this.state = &#123; loading: true, error: null, data: null &#125;; &#125; componentDidMount() &#123; const url = 'https://api.github.com/search/repositories?q=javascript&amp;sort=stars'; $.getJSON(url) .done( (value) =&gt; this.setState(&#123; loading: false, data: value &#125;) ).fail( (jqXHR, textStatus) =&gt; this.setState(&#123; loading: false, error: jqXHR.status &#125;) ); &#125; render() &#123; if (this.state.loading) &#123; return &lt;span&gt;Loading...&lt;/span&gt;; &#125; else if (this.state.error !== null) &#123; return &lt;span&gt;Error: &#123;this.state.error&#125;&lt;/span&gt;; &#125; else &#123; /* 你的代码填入这里 */ const data = this.state.data.items var result = [] data.forEach(item =&gt; &#123; result.push(&lt;li&gt;&#123;item.name&#125;&lt;/li&gt;) &#125;) return ( &lt;div&gt; &lt;p&gt;API 数据获取成功&lt;/p&gt; &lt;ul&gt; &#123;result&#125; &lt;/ul&gt; &lt;/div&gt; ); &#125; &#125; &#125;; ReactDOM.render( &lt;MyList/&gt;, document.getElementById('example') ); 第三方组件库使用待完成…]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php使用总结]]></title>
    <url>%2F2017%2F04%2F26%2FPHP%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[php使用总结。 配置文件代码示例&lt;?php//对每个文件进行编码header("content-type:text/html; charset=utf-8");//数据库服务器连接，@符表示屏蔽错误信息$link=@mysql_connect("localhost","root","775166") or die ("连接服务器失败失败");//选择数据库mysql_select_db("212db",$link) or die ("连接数据库失败");//数据库编码mysql_query("set names 'utf8'"); //次函数表示转义我们在文本域中使用的换行和空格function htmtocode($content) &#123; $content = str_replace("\n", "&lt;br&gt;", str_replace(" ", "&amp;nbsp;", $content)); return $content;&#125;自定义常量：/** 数据库的名称 */define('DB_NAME', 'myblog');/** MySQL数据库用户名 */define('DB_USER', 'root');/** MySQL数据库密码 */define('DB_PASSWORD', '775166');/** MySQL主机 */define('DB_HOST', 'localhost');/** 创建数据表时默认的文字编码 */define('DB_CHARSET', 'utf8');?&gt; 注册用户逻辑//加载配置文件include ("config.php");//判断是否填写数据，如果有则执行if ($_POST['submit'])&#123; $username = $_POST['username']; $password = $_POST['password']; $email = $_POST['email']; $sql="select * from user where username='$_POST[username]'"; $check=mysql_query($sql); $row=mysql_fetch_array($check); //继续判断是否有相似用户名，如果有则执行 if($row)&#123; echo "&lt;script&gt;alert('脫脙禄搂脙没脰脴赂麓拢隆');window.location='reg.php'&lt;/script&gt;"; return false; &#125; //加密密码，并插入数据库 $password = MD5($password); $sql="insert into user(id,username,password,email,regtime) values ('','$username','$password','$email',now())"; $query=mysql_query($sql); echo "&lt;script&gt;alert('脳垄虏谩鲁脡鹿娄,脟毛碌脟脗陆拢隆');window.location='login.php'&lt;/script&gt;";&#125; 登录逻辑include ("config.php");if ($_SESSION['username']) &#123; header("Location: index.php");&#125;//保留登录信息session_start();//判断是否填写用户信息if(isset($_POST['submit']))&#123; $username = $_POST['username']; $password = MD5($_POST['password']); //到数据库校验是否匹配 $sql="select * from user where username='$username'and password='$password'"; $query=mysql_query($sql); $row=mysql_fetch_array($query); //如果匹配则保留登录信息，否则重新填写 if($row)&#123; $_SESSION['username']=$username; &#125; else &#123; echo "&lt;script&gt;alert('ÓÃ»§Ãû»òÃÜÂë´íÎó');location.href='login.php';&lt;/script&gt;"; &#125;&#125; $sql=&quot;select * from artical order by id desc limit 6&quot;;$query=mysql_query($sql);&lt;ul&gt;&lt;?php while($rs=mysql_fetch_array($query))&#123;?&gt;&lt;li&gt;&lt;a href=&quot;artical.php?id=&lt;?php echo $rs[&apos;id&apos;]?&gt;&quot;&gt;&lt;?php echo $rs[&apos;title&apos;] ?&gt;&lt;/a&gt;&lt;/li&gt;&lt;?php &#125;?&gt;&lt;/ul&gt; sql语句# 命令行中输入并加分号。# 选择数据库use RUNOOB# 设置使用的字符集set names utf8;# 读取数据表的信息SELECT * FROM Websites SELECTSELECT * FROM Websites;SELECT name,country FROM Websites;# 从 "Websites" 表的 "country" 列中选取唯一不同的值，也就是去掉 "country" 列重复值SELECT DISTINCT country FROM Websites;# 使用where获取满足情况的数据SELECT * FROM Websites WHERE country='CN';# 加入or和andSELECT * FROM Websites WHERE country='CN' AND alexa &gt; 50;SELECT * FROM Websites WHERE country='USA' OR country='CN';SELECT * FROM Websites WHERE alexa &gt; 15 AND (country='CN' OR country='USA');# 使用order，其中alexa是表中的一个字段SELECT * FROM Websites ORDER BY alexa;SELECT * FROM Websites ORDER BY alexa DESC;SELECT * FROM Websites ORDER BY country,alexa; where子句中的运算符： = 等于 &lt;&gt; 不等于。在 SQL 的一些版本中，该操作符可被写成 != 大于 &lt; 小于 = 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 IN 指定针对某个列的多个可能值 INSERT INTOINSERT INTO Websites (name, url, alexa, country) VALUES ('百度','https://www.baidu.com/','4','CN');# 指定列插入数据INSERT INTO Websites (name, url, country) VALUES ('stackoverflow', 'http://stackoverflow.com/', 'IND'); UPDATEUPDATE Websites SET alexa='5000', country='USA' WHERE name='菜鸟教程'; DELETEDELETE FROM Websites WHERE name='百度' AND country='CN'; PHP中的Mysql操作MySQL的函数： mysqli_connect($connect) mysqli_query($connect,”SQL 语句”) mysqli_fetch_array() mysqli_close() 连接数据库$dbhost = &apos;localhost:3306&apos;; // mysql服务器主机地址$dbuser = &apos;root&apos;; // mysql用户名$dbpass = &apos;123456&apos;; // mysql用户名密码$conn = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn )&#123; die(&apos;Could not connect: &apos; . mysqli_error());&#125;echo &apos;数据库连接成功！&apos;;//创建数据库$sql = &apos;CREATE DATABASE RUNOOB&apos;;$retval = mysqli_query($conn,$sql );if(! $retval )&#123; die(&apos;创建数据库失败: &apos; . mysqli_error($conn));&#125;echo &quot;数据库 RUNOOB 创建成功\n&quot;;//删除数据库$sql = &apos;DROP DATABASE RUNOOB&apos;;$retval = mysqli_query( $conn, $sql );if(! $retval )&#123; die(&apos;删除数据库失败: &apos; . mysqli_error($conn));&#125;echo &quot;数据库 RUNOOB 删除成功\n&quot;;//选择数据库mysqli_select_db($conn, &apos;RUNOOB&apos; );//创建数据表$sql = &quot;CREATE TABLE runoob_tbl( &quot;. &quot;runoob_id INT NOT NULL AUTO_INCREMENT, &quot;. &quot;runoob_title VARCHAR(100) NOT NULL, &quot;. &quot;runoob_author VARCHAR(40) NOT NULL, &quot;. &quot;submission_date DATE, &quot;. &quot;PRIMARY KEY ( runoob_id ))ENGINE=InnoDB DEFAULT CHARSET=utf8; &quot;;mysqli_select_db( $conn, &apos;RUNOOB&apos; );$retval = mysqli_query( $conn, $sql );if(! $retval )&#123; die(&apos;数据表创建失败: &apos; . mysqli_error($conn));&#125;echo &quot;数据表创建成功\n&quot;;//删除数据表$sql = &quot;DROP TABLE runoob_tbl&quot;;mysqli_select_db( $conn, &apos;RUNOOB&apos; );$retval = mysqli_query( $conn, $sql );if(! $retval )&#123; die(&apos;数据表删除失败: &apos; . mysqli_error($conn));&#125;echo &quot;数据表删除成功\n&quot;;mysqli_close($conn); mysql命令登录数据库服务器# 从命令行登录MySQL数据库服务器 1、登录使用默认3306端口的MySQL/usr/local/mysql/bin/mysql -u root -p# 通过TCP连接管理不同端口的多个MySQL（注意：MySQL4.1以上版本才有此项功能）/usr/local/mysql/bin/mysql -u root -p --protocol=tcp --host=localhost --port=3307# 通过socket套接字管理不同端口的多个MySQL/usr/local/mysql/bin/mysql -u root -p --socket=/tmp/mysql3307.sock# 通过端口和IP管理不同端口的多个MySQL/usr/local/mysql/bin/mysql -u root -p -P 3306 -h 127.0.0.1 增删改查# 查看已有数据库SHOW DATABASES;# 创建名称为rewin的数据库CREATE DATABASE rewin;# 删除名称为rewin的数据库DROP DATABASE rewin;# 选择rewin数据库USE rewin;# 显示当前数据库中存在什么表SHOW TABLES;# 创建数据库表zhangyanCREATE TABLE `zhangyan` ( `id` INT( 5 ) UNSIGNED NOT NULL AUTO_INCREMENT , `username` VARCHAR( 20 ) NOT NULL , `password` CHAR( 32 ) NOT NULL , `time` DATETIME NOT NULL , `number` FLOAT( 10 ) NOT NULL , `content` TEXT NOT NULL , PRIMARY KEY ( `id` ) ) ENGINE = MYISAM ;# 查看zhangyan表结构DESCRIBE zhangyan;# 从表中检索所有记录SELECT * FROM zhangyan;# 从zhangyan表中检索特定的行SELECT * FROM zhangyan WHERE username = abc AND number=1 ORDER BY id DESC;# 从zhangyan表中检索指定的字段SELECT username, password FROM zhangyan;# 从zhangyan表中检索出唯一的不重复记录：SELECT DISTINCT username FROM zhangyan;# 插入信息到zhangyan表INSERT INTO zhangyan (id, username, password, time, number, content) VALUES (, abc, 123456, 2007-08-06 14:32:12, 23.41, hello world);# 更新zhangyan表中的指定信息UPDATE zhangyan SET content = hello china WHERE username = abc;# 删除zhangyan表中的指定信息DELETE FROM zhangyan WHERE id = 1;# 清空zhangyan表DELETE FROM zhangyan;# 删除zhangyan表DROP TABLE zhangyan;# 更改表结构，将zhangyan表username字段的字段类型改为CHAR(25)ALTER TABLE zhangyan CHANGE username username CHAR(25);# 将当前目录下的mysql.sql导入数据库SOURCE ./mysql.sql; 数据库权限操作SQL语句# 创建一个具有root权限，可从任何IP登录的用户sina，密码为zhangyanGRANT ALL PRIVILEGES ON *.* TO sina@% IDENTIFIED BY zhangyan;# 创建一个具有"数据操作"、"结构操作"权限，只能从192.168.1.***登录的用户sina，密码为zhangyanGRANT SELECT , INSERT , UPDATE , DELETE , FILE , CREATE , DROP , INDEX , ALTER , CREATE TEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON *.* TO sina@192.168.1.% IDENTIFIED BY zhangyan;# 创建一个只拥有"数据操作"权限，只能从192.168.1.24登录，只能操作rewin数据库的zhangyan表的用户sina，密码为zhangyanGRANT SELECT , INSERT , UPDATE , DELETE ON rewin.zhangyan TO sina@192.168.1.24 IDENTIFIED BY zhangyan;# 创建一个拥有"数据操作"、"结构操作"权限，可从任何IP登录，只能操作rewin数据库的用户sina，密码为zhangyan GRANT SELECT , INSERT , UPDATE , DELETE , CREATE , DROP , INDEX , ALTER , CREATE TEMPORARY TABLES , CREATE VIEW , SHOW VIEW , CREATE ROUTINE, ALTER ROUTINE, EXECUTE ON rewin.* TO sina@% IDENTIFIED BY zhangyan;# 删除用户DROP USER sina@%;# MySQL中将字符串aaa批量替换为bbb的SQL语句UPDATE 表名 SET 字段名 = REPLACE (字段名, aaa, bbb);# 修复损坏的表 # 用root帐号从命令行登录MySQLmysql -u root -p# 输入root帐号的密码# 选定数据库名（本例中的数据库名为student）use student# 修复损坏的表（本例中要修复的表为smis_user_student）repair table smis_user_student;udent]]></content>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js概述]]></title>
    <url>%2F2017%2F04%2F19%2FNode.js%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[简介Node是JavaScript语言的服务器运行环境。 所谓“运行环境”有两层意思：首先，JavaScript语言通过Node在服务器运行，在这个意义上，Node有点像JavaScript虚拟机；其次，Node提供大量工具库，使得JavaScript语言与操作系统互动（比如读写文件、新建子进程），在这个意义上，Node又是JavaScript的工具库。 Node内部采用Google公司的V8引擎，作为JavaScript语言解释器；通过自行开发的libuv库，调用操作系统资源。 安装、更新以及基本用法，请查看前面的文章。 异步操作Node采用V8引擎处理JavaScript脚本，最大特点就是单线程运行，一次只能运行一个任务。这导致Node大量采用异步操作（asynchronous opertion），即任务不是马上执行，而是插在任务队列的尾部，等到前面的任务运行完后再执行。 由于这种特性，某一个任务的后续操作，往往采用回调函数（callback）的形式进行定义。 var isTrue = function(value, callback) &#123; if (value === true) &#123; callback(null, "Value was true."); &#125; else &#123; callback(new Error("Value is not true!")); &#125;&#125; 上面代码就把进一步的处理，交给回调函数callback。 Node约定，如果某个函数需要回调函数作为参数，则回调函数是最后一个参数。另外，回调函数本身的第一个参数，约定为上一步传入的错误对象。 var callback = function (error, value) &#123; if (error) &#123; return console.log(error); &#125; console.log(value);&#125; 上面代码中，callback的第一个参数是Error对象，第二个参数才是真正的数据参数。这是因为回调函数主要用于异步操作，当回调函数运行时，前期的操作早结束了，错误的执行栈早就不存在了，传统的错误捕捉机制try…catch对于异步操作行不通，所以只能把错误交给回调函数处理。 try &#123; db.User.get(userId, function(err, user) &#123; if(err) &#123; throw err &#125; // ... &#125;)&#125; catch(e) &#123; console.log(‘Oh no!’);&#125; 上面代码中，db.User.get方法是一个异步操作，等到抛出错误时，可能它所在的try…catch代码块早就运行结束了，这会导致错误无法被捕捉。所以，Node统一规定，一旦异步操作发生错误，就把错误对象传递到回调函数。 如果没有发生错误，回调函数的第一个参数就传入null。这种写法有一个很大的好处，就是说只要判断回调函数的第一个参数，就知道有没有出错，如果不是null，就肯定出错了。另外，这样还可以层层传递错误。 if(err) &#123; // 除了放过No Permission错误意外，其他错误传给下一个回调函数 if(!err.noPermission) &#123; return next(err); &#125;&#125; 全局对象和全局变量Node提供以下几个全局对象，它们是所有模块都可以调用的。 global：表示Node所在的全局环境，类似于浏览器的window对象。需要注意的是，如果在浏览器中声明一个全局变量，实际上是声明了一个全局对象的属性，比如var x = 1等同于设置window.x = 1，但是Node不是这样，至少在模块中不是这样（REPL环境的行为与浏览器一致）。在模块文件中，声明var x = 1，该变量不是global对象的属性，global.x等于undefined。这是因为模块的全局变量都是该模块私有的，其他模块无法取到。 process：该对象表示Node所处的当前进程，允许开发者与该进程互动。 console：指向Node内置的console模块，提供命令行环境中的标准输入、标准输出功能。 Node还提供一些全局函数。 setTimeout()：用于在指定毫秒之后，运行回调函数。实际的调用间隔，还取决于系统因素。间隔的毫秒数在1毫秒到2,147,483,647毫秒（约24.8天）之间。如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。 clearTimeout()：用于终止一个setTimeout方法新建的定时器。 setInterval()：用于每隔一定毫秒调用回调函数。由于系统因素，可能无法保证每次调用之间正好间隔指定的毫秒数，但只会多于这个间隔，而不会少于它。指定的毫秒数必须是1到2,147,483,647（大约24.8天）之间的整数，如果超过这个范围，会被自动改为1毫秒。该方法返回一个整数，代表这个新建定时器的编号。 clearInterval()：终止一个用setInterval方法新建的定时器。 require()：用于加载模块。 Buffer()：用于操作二进制数据。 Node提供两个全局变量，都以两个下划线开头。 __filename：指向当前运行的脚本文件名。 __dirname：指向当前运行的脚本所在的目录。 除此之外，还有一些对象实际上是模块内部的局部变量，指向的对象根据模块不同而不同，但是所有模块都适用，可以看作是伪全局变量，主要为module, module.exports, exports等。 模块化结构概述Node.js采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块，实际上就是加载对应的一个模块文件。 require命令用于指定加载模块，加载时可以省略脚本文件的后缀名。 var circle = require('./circle.js');// 或者var circle = require('./circle'); require方法的参数是模块文件的名字。它分成两种情况，第一种情况是参数中含有文件路径（比如上例），这时路径是相对于当前脚本所在的目录，第二种情况是参数中不含有文件路径，这时Node到模块的安装目录，去寻找已安装的模块（比如下例）。 var bar = require('bar'); 有时候，一个模块本身就是一个目录，目录中包含多个文件。这时候，Node在package.json文件中，寻找main属性所指明的模块入口文件。 &#123; "name" : "bar", "main" : "./lib/bar.js"&#125; 上面代码中，模块的启动文件为lib子目录下的bar.js。当使用require(&#39;bar&#39;)命令加载该模块时，实际上加载的是./node_modules/bar/lib/bar.js文件。下面写法会起到同样效果。 var bar = require('bar/lib/bar.js') 如果模块目录中没有package.json文件，node.js会尝试在模块目录中寻找index.js或index.node文件进行加载。 模块一旦被加载以后，就会被系统缓存。如果第二次还加载该模块，则会返回缓存中的版本，这意味着模块实际上只会执行一次。如果希望模块执行多次，则可以让模块返回一个函数，然后多次调用该函数。 核心模块如果只是在服务器运行JavaScript代码，用处并不大，因为服务器脚本语言已经有很多种了。Node.js的用处在于，它本身还提供了一系列功能模块，与操作系统互动。这些核心的功能模块，不用安装就可以使用，下面是它们的清单。 http：提供HTTP服务器功能。 url：解析URL。 fs：与文件系统交互。 querystring：解析URL的查询字符串。 child_process：新建子进程。 util：提供一系列实用小工具。 path：处理文件路径。 crypto：提供加密和解密功能，基本上是对OpenSSL的包装。 上面这些核心模块，源码都在Node的lib子目录中。为了提高运行速度，它们安装时都会被编译成二进制文件。 核心模块总是最优先加载的。如果你自己写了一个HTTP模块，require(&#39;http&#39;)加载的还是核心模块。 自定义模块Node模块采用CommonJS规范。只要符合这个规范，就可以自定义模块。 下面是一个最简单的模块，假定新建一个foo.js文件，写入以下内容。 // foo.jsmodule.exports = function(x) &#123; console.log(x);&#125;; 上面代码就是一个模块，它通过module.exports变量，对外输出一个方法。 这个模块的使用方法如下。 // index.jsvar m = require('./foo');m("这是自定义模块"); 上面代码通过require命令加载模块文件foo.js（后缀名省略），将模块的对外接口输出到变量m，然后调用m。这时，在命令行下运行index.js，屏幕上就会输出“这是自定义模块”。 $ node index这是自定义模块 module变量是整个模块文件的顶层变量，它的exports属性就是模块向外输出的接口。如果直接输出一个函数（就像上面的foo.js），那么调用模块就是调用一个函数。但是，模块也可以输出一个对象。下面对foo.js进行改写。 // foo.jsvar out = new Object();function p(string) &#123; console.log(string);&#125;out.print = p;module.exports = out; 上面的代码表示模块输出out对象，该对象有一个print属性，指向一个函数。下面是这个模块的使用方法。 // index.jsvar m = require('./foo');m.print("这是自定义模块"); 上面代码表示，由于具体的方法定义在模块的print属性上，所以必须显式调用print属性。 异常处理Node是单线程运行环境，一旦抛出的异常没有被捕获，就会引起整个进程的崩溃。所以，Node的异常处理对于保证系统的稳定运行非常重要。 一般来说，Node有三种方法，传播一个错误。 使用throw语句抛出一个错误对象，即抛出异常。 将错误对象传递给回调函数，由回调函数负责发出错误。 通过EventEmitter接口，发出一个error事件。 try…catch结构最常用的捕获异常的方式，就是使用try…catch结构。但是，这个结构无法捕获异步运行的代码抛出的异常。 try &#123; process.nextTick(function () &#123; throw new Error("error"); &#125;);&#125; catch (err) &#123; //can not catch it console.log(err);&#125;try &#123; setTimeout(function()&#123; throw new Error("error"); &#125;,1)&#125; catch (err) &#123; //can not catch it console.log(err);&#125; 上面代码分别用process.nextTick和setTimeout方法，在下一轮事件循环抛出两个异常，代表异步操作抛出的错误。它们都无法被catch代码块捕获，因为catch代码块所在的那部分已经运行结束了。 一种解决方法是将错误捕获代码，也放到异步执行。 function async(cb, err) &#123; setTimeout(function() &#123; try &#123; if (true) throw new Error("woops!"); else cb("done"); &#125; catch(e) &#123; err(e); &#125; &#125;, 2000)&#125;async(function(res) &#123; console.log("received:", res);&#125;, function(err) &#123; console.log("Error: async threw an exception:", err);&#125;);// Error: async threw an exception: Error: woops! 上面代码中，async函数异步抛出的错误，可以同样部署在异步的catch代码块捕获。 这两种处理方法都不太理想。一般来说，Node只在很少场合才用try/catch语句，比如使用JSON.parse解析JSON文本。 回调函数Node采用的方法，是将错误对象作为第一个参数，传入回调函数。这样就避免了捕获代码与发生错误的代码不在同一个时间段的问题。 fs.readFile('/foo.txt', function(err, data) &#123; if (err !== null) throw err; console.log(data);&#125;); 上面代码表示，读取文件foo.txt是一个异步操作，它的回调函数有两个参数，第一个是错误对象，第二个是读取到的文件数据。如果第一个参数不是null，就意味着发生错误，后面代码也就不再执行了。 下面是一个完整的例子。 function async2(continuation) &#123; setTimeout(function() &#123; try &#123; var res = 42; if (true) throw new Error("woops!"); else continuation(null, res); // pass 'null' for error &#125; catch(e) &#123; continuation(e, null); &#125; &#125;, 2000);&#125;async2(function(err, res) &#123; if (err) console.log("Error: (cps) failed:", err); else console.log("(cps) received:", res);&#125;);// Error: (cps) failed: woops! 上面代码中，async2函数的回调函数的第一个参数就是一个错误对象，这是为了处理异步操作抛出的错误。 EventEmitter接口的error事件发生错误的时候，也可以用EventEmitter接口抛出error事件。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter();emitter.emit('error', new Error('something bad happened')); 使用上面的代码必须小心，因为如果没有对error事件部署监听函数，会导致整个应用程序崩溃。所以，一般总是必须同时部署下面的代码。 emitter.on('error', function(err) &#123; console.error('出错：' + err.message);&#125;); uncaughtException事件当一个异常未被捕获，就会触发uncaughtException事件，可以对这个事件注册回调函数，从而捕获异常。 var logger = require('tracer').console();process.on('uncaughtException', function(err) &#123; console.error('Error caught in uncaughtException event:', err);&#125;);try &#123; setTimeout(function()&#123; throw new Error("error"); &#125;,1);&#125; catch (err) &#123; //can not catch it console.log(err);&#125; 只要给uncaughtException配置了回调，Node进程不会异常退出，但异常发生的上下文已经丢失，无法给出异常发生的详细信息。而且，异常可能导致Node不能正常进行内存回收，出现内存泄露。所以，当uncaughtException触发后，最好记录错误日志，然后结束Node进程。 process.on('uncaughtException', function(err) &#123; logger.log(err); process.exit(1);&#125;); unhandledRejection事件iojs有一个unhandledRejection事件，用来监听没有捕获的Promise对象的rejected状态。 var promise = new Promise(function(resolve, reject) &#123; reject(new Error("Broken."));&#125;);promise.then(function(result) &#123; console.log(result);&#125;) 上面代码中，promise的状态变为rejected，并且抛出一个错误。但是，不会有任何反应，因为没有设置任何处理函数。 只要监听unhandledRejection事件，就能解决这个问题。 process.on('unhandledRejection', function (err, p) &#123; console.error(err.stack);&#125;) 需要注意的是，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是产生错误的promise对象。这可以提供很多有用的信息。 var http = require('http');http.createServer(function (req, res) &#123; var promise = new Promise(function(resolve, reject) &#123; reject(new Error("Broken.")) &#125;) promise.info = &#123;url: req.url&#125;&#125;).listen(8080)process.on('unhandledRejection', function (err, p) &#123; if (p.info &amp;&amp; p.info.url) &#123; console.log('Error in URL', p.info.url) &#125; console.error(err.stack)&#125;) 上面代码会在出错时，输出用户请求的网址。 Error in URL /testurlError: Broken. at /Users/mikeal/tmp/test.js:9:14 at Server.&lt;anonymous&gt; (/Users/mikeal/tmp/test.js:4:17) at emitTwo (events.js:87:13) at Server.emit (events.js:169:7) at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:471:12) at HTTPParser.parserOnHeadersComplete (_http_common.js:88:23) at Socket.socketOnData (_http_server.js:322:22) at emitOne (events.js:77:13) at Socket.emit (events.js:166:7) at readableAddChunk (_stream_readable.js:145:16) 命令行脚本node脚本可以作为命令行脚本使用。 $ node foo.js 上面代码执行了foo.js脚本文件。 foo.js文件的第一行，如果加入了解释器的位置，就可以将其作为命令行工具直接调用。 #!/usr/bin/env node 调用前，需更改文件的执行权限。 $ chmod u+x foo.js$ ./foo.js arg1 arg2 ... 作为命令行脚本时，console.log用于输出内容到标准输出，process.stdin用于读取标准输入，child_process.exec()用于执行一个shell命令。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[package.json文件]]></title>
    <url>%2F2017%2F04%2F19%2Fpackage.json%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[概述每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 下面是一个最简单的package.json文件，只定义两项元数据：项目名称和项目版本。 &#123; "name" : "xxx", "version" : "0.0.0",&#125; 上面代码说明，package.json文件内部就是一个JSON对象，该对象的每一个成员就是当前项目的一项设置。比如name就是项目名称，version是版本（遵守“大版本.次要版本.小版本”的格式）。 下面是一个更完整的package.json文件。 &#123; "name": "Hello World", "version": "0.0.1", "author": "张三", "description": "第一个node.js程序", "keywords":["node.js","javascript"], "repository": &#123; "type": "git", "url": "https://path/to/url" &#125;, "license":"MIT", "engines": &#123;"node": "0.10.x"&#125;, "bugs":&#123;"url":"http://path/to/bug","email":"bug@example.com"&#125;, "contributors":[&#123;"name":"李四","email":"lisi@example.com"&#125;], "scripts": &#123; "start": "node index.js" &#125;, "dependencies": &#123; "express": "latest", "mongoose": "~3.8.3", "handlebars-runtime": "~1.0.12", "express3-handlebars": "~0.5.0", "MD5": "~1.2.0" &#125;, "devDependencies": &#123; "bower": "~1.2.8", "grunt": "~0.4.1", "grunt-contrib-concat": "~0.3.0", "grunt-contrib-jshint": "~0.7.2", "grunt-contrib-uglify": "~0.2.7", "grunt-contrib-clean": "~0.5.0", "browserify": "2.36.1", "grunt-browserify": "~1.3.0", &#125;&#125; 下面详细解释package.json文件的各个字段。 scripts字段scripts指定了运行脚本命令的npm命令行缩写，比如start指定了运行npm run start时，所要执行的命令。 下面的设置指定了npm run preinstall、npm run postinstall、npm run start、npm run test时，所要执行的命令。 "scripts": &#123; "preinstall": "echo here it comes!", "postinstall": "echo there it goes!", "start": "node index.js", "test": "tap test/*.js"&#125; dependencies字段，devDependencies字段dependencies字段指定了项目运行所依赖的模块，devDependencies指定项目开发所需要的模块。 它们都指向一个对象。该对象的各个成员，分别由模块名和对应的版本要求组成，表示依赖的模块及其版本范围。 &#123; "devDependencies": &#123; "browserify": "~13.0.0", "karma-browserify": "~5.0.1" &#125;&#125; 对应的版本可以加上各种限定，主要有以下几种： 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装1.3.x，也就是说安装时不改变大版本号和次要版本号。 插入号（caret）+指定版本：比如&#710;1.2.2，表示安装1.x.x的最新版本（不低于1.2.2），但是不安装2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。 latest：安装最新版本。 package.json文件可以手工编写，也可以使用npm init命令自动生成。 $ npm init 这个命令采用互动方式，要求用户回答一些问题，然后在当前目录生成一个基本的package.json文件。所有问题之中，只有项目名称（name）和项目版本（version）是必填的，其他都是选填的。 有了package.json文件，直接使用npm install命令，就会在当前目录中安装所需要的模块。 $ npm install 如果一个模块不在package.json文件之中，可以单独安装这个模块，并使用相应的参数，将其写入package.json文件之中。 $ npm install express --save$ npm install express --save-dev 上面代码表示单独安装express模块，--save参数表示将该模块写入dependencies属性，--save-dev表示将该模块写入devDependencies属性。 peerDependencies有时，你的项目和所依赖的模块，都会同时依赖另一个模块，但是所依赖的版本不一样。比如，你的项目依赖A模块和B模块的1.0版，而A模块本身又依赖B模块的2.0版。 大多数情况下，这不构成问题，B模块的两个版本可以并存，同时运行。但是，有一种情况，会出现问题，就是这种依赖关系将暴露给用户。 最典型的场景就是插件，比如A模块是B模块的插件。用户安装的B模块是1.0版本，但是A插件只能和2.0版本的B模块一起使用。这时，用户要是将1.0版本的B的实例传给A，就会出现问题。因此，需要一种机制，在模板安装的时候提醒用户，如果A和B一起安装，那么B必须是2.0模块。 peerDependencies字段，就是用来供插件指定其所需要的主工具的版本。 &#123; "name": "chai-as-promised", "peerDependencies": &#123; "chai": "1.x" &#125;&#125; 上面代码指定，安装chai-as-promised模块时，主程序chai必须一起安装，而且chai的版本必须是1.x。如果你的项目指定的依赖是chai的2.0版本，就会报错。 注意，从npm 3.0版开始，peerDependencies不再会默认安装了。 bin字段bin项用来指定各个内部命令对应的可执行文件的位置。 "bin": &#123; "someTool": "./bin/someTool.js"&#125; 上面代码指定，someTool 命令对应的可执行文件为 bin 子目录下的 someTool.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，someTool.js会建立符号链接npm_modules/.bin/someTool。由于node_modules/.bin/目录会在运行时加入系统的PATH变量，因此在运行npm时，就可以不带路径，直接通过命令来调用这些脚本。 因此，像下面这样的写法可以采用简写。 scripts: &#123; start: './node_modules/someTool/someTool.js build'&#125;// 简写为scripts: &#123; start: 'someTool build'&#125; 所有node_modules/.bin/目录下的命令，都可以用npm run [命令]的格式运行。在命令行下，键入npm run，然后按tab键，就会显示所有可以使用的命令。 main字段main字段指定了加载的入口文件，require(&#39;moduleName&#39;)就会加载这个文件。这个字段的默认值是模块根目录下面的index.js。 config字段config字段用于向环境变量输出值。 下面是一个package.json文件。 &#123; "name" : "foo", "config" : &#123; "port" : "8080" &#125;, "scripts" : &#123; "start" : "node server.js" &#125;&#125; 然后，在server.js脚本就可以引用config字段的值。 http.createServer(...).listen(process.env.npm_package_config_port) 用户可以改变这个值。 $ npm config set foo:port 80 其他browser字段browser指定该模板供浏览器使用的版本。Browserify这样的浏览器打包工具，通过它就知道该打包那个文件。 "browser": &#123; "tipso": "./node_modules/tipso/src/tipso.js"&#125;, engines字段engines指明了该项目所需要的node.js版本。 man字段man用来指定当前模块的man文档的位置。 "man" :[ "./doc/calc.1" ] preferGlobal字段preferGlobal的值是布尔值，表示当用户不将该模块安装为全局模块时（即不用–global参数），要不要显示警告，表示该模块的本意就是安装为全局模块。 style字段style指定供浏览器使用时，样式文件所在的位置。样式文件打包工具parcelify，通过它知道样式文件的打包位置。 "style": [ "./node_modules/tipso/src/tipso.css"]]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CommonJS规范]]></title>
    <url>%2F2017%2F04%2F19%2FCommonJS%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[概述Node应用由模块组成，采用CommonJS模块规范。 根据这个规范，每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。 // example.jsvar x = 5;var addX = function (value) &#123; return value + x;&#125;; 上面代码中，变量x和函数addX，是当前文件example.js私有的，其他文件不可见。 如果想在多个文件分享变量，必须定义为global对象的属性。 global.warning = true; 上面代码的warning变量，可以被所有文件读取。当然，这样写法是不推荐的。 CommonJS规范规定，每个模块内部，module变量代表当前模块。这个变量是一个对象，它的exports属性（即module.exports）是对外的接口。加载某个模块，其实是加载该模块的module.exports属性。 var x = 5;var addX = function (value) &#123; return value + x;&#125;;module.exports.x = x;module.exports.addX = addX; 上面代码通过module.exports输出变量x和函数addX。 require方法用于加载模块。 var example = require('./example.js');console.log(example.x); // 5console.log(example.addX(1)); // 6 require方法的详细解释参见《Require命令》一节。 CommonJS模块的特点如下。 所有代码都运行在模块作用域，不会污染全局作用域。 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。 模块加载的顺序，按照其在代码中出现的顺序。 module对象Node内部提供一个Module构建函数。所有模块都是Module的实例。 function Module(id, parent) &#123; this.id = id; this.exports = &#123;&#125;; this.parent = parent; // ... 每个模块内部，都有一个module对象，代表当前模块。它有以下属性。 module.id 模块的识别符，通常是带有绝对路径的模块文件名。 module.filename 模块的文件名，带有绝对路径。 module.loaded 返回一个布尔值，表示模块是否已经完成加载。 module.parent 返回一个对象，表示调用该模块的模块。 module.children 返回一个数组，表示该模块要用到的其他模块。 module.exports 表示模块对外输出的值。 下面是一个示例文件，最后一行输出module变量。 // example.jsvar jquery = require('jquery');exports.$ = jquery;console.log(module); 执行这个文件，命令行会输出如下信息。 &#123; id: '.', exports: &#123; '$': [Function] &#125;, parent: null, filename: '/path/to/example.js', loaded: false, children: [ &#123; id: '/path/to/node_modules/jquery/dist/jquery.js', exports: [Function], parent: [Circular], filename: '/path/to/node_modules/jquery/dist/jquery.js', loaded: true, children: [], paths: [Object] &#125; ], paths: [ '/home/user/deleted/node_modules', '/home/user/node_modules', '/home/node_modules', '/node_modules' ]&#125; 如果在命令行下调用某个模块，比如node something.js，那么module.parent就是undefined。如果是在脚本之中调用，比如require(&#39;./something.js&#39;)，那么module.parent就是调用它的模块。利用这一点，可以判断当前模块是否为入口脚本。 if (!module.parent) &#123; // ran with `node something.js` app.listen(8088, function() &#123; console.log('app listening on port 8088'); &#125;)&#125; else &#123; // used with `require('/.something.js')` module.exports = app;&#125; module.exports属性module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。 var EventEmitter = require('events').EventEmitter;module.exports = new EventEmitter();setTimeout(function() &#123; module.exports.emit('ready');&#125;, 1000); 上面模块会在加载后1秒后，发出ready事件。其他文件监听该事件，可以写成下面这样。 var a = require('./a');a.on('ready', function() &#123; console.log('module a is ready');&#125;); exports变量为了方便，Node为每个模块提供一个exports变量，指向module.exports。这等同在每个模块头部，有一行这样的命令。 var exports = module.exports; 造成的结果是，在对外输出模块接口时，可以向exports对象添加方法。 exports.area = function (r) &#123; return Math.PI * r * r;&#125;;exports.circumference = function (r) &#123; return 2 * Math.PI * r;&#125;; 注意，不能直接将exports变量指向一个值，因为这样等于切断了exports与module.exports的联系。 exports = function(x) &#123;console.log(x)&#125;; 上面这样的写法是无效的，因为exports不再指向module.exports了。 下面的写法也是无效的。 exports.hello = function() &#123; return 'hello';&#125;;module.exports = 'Hello world'; 上面代码中，hello函数是无法对外输出的，因为module.exports被重新赋值了。 这意味着，如果一个模块的对外接口，就是一个单一的值，不能使用exports输出，只能使用module.exports输出。 module.exports = function (x)&#123; console.log(x);&#125;; 如果你觉得，exports与module.exports之间的区别很难分清，一个简单的处理方法，就是放弃使用exports，只使用module.exports。 AMD规范与CommonJS规范的兼容性CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。 AMD规范使用define方法定义模块，下面就是一个例子： define(['package/lib'], function(lib)&#123; function foo()&#123; lib.log('hello world!'); &#125; return &#123; foo: foo &#125;;&#125;); AMD规范允许输出的模块兼容CommonJS规范，这时define方法需要写成下面这样： define(function (require, exports, module)&#123; var someModule = require("someModule"); var anotherModule = require("anotherModule"); someModule.doTehAwesome(); anotherModule.doMoarAwesome(); exports.asplode = function ()&#123; someModule.doTehAwesome(); anotherModule.doMoarAwesome(); &#125;;&#125;); require命令基本用法Node使用CommonJS模块规范，内置的require命令用于加载模块文件。 require命令的基本功能是，读入并执行一个JavaScript文件，然后返回该模块的exports对象。如果没有发现指定模块，会报错。 // example.jsvar invisible = function () &#123; console.log("invisible");&#125;exports.message = "hi";exports.say = function () &#123; console.log(message);&#125; 运行下面的命令，可以输出exports对象。 var example = require('./example.js');example// &#123;// message: "hi",// say: [Function]// &#125; 如果模块输出的是一个函数，那就不能定义在exports对象上面，而要定义在module.exports变量上面。 module.exports = function () &#123; console.log("hello world")&#125;require('./example2.js')() 上面代码中，require命令调用自身，等于是执行module.exports，因此会输出 hello world。 加载规则require命令用于加载文件，后缀名默认为.js。 var foo = require('foo');// 等同于var foo = require('foo.js'); 根据参数的不同格式，require命令去不同路径寻找模块文件。 （1）如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。比如，require(&#39;/home/marco/foo.js&#39;)将加载/home/marco/foo.js。 （2）如果参数字符串以“./”开头，则表示加载的是一个位于相对路径（跟当前执行脚本的位置相比）的模块文件。比如，require(&#39;./circle&#39;)将加载当前脚本同一目录的circle.js。 （3）如果参数字符串不以“./“或”/“开头，则表示加载的是一个默认提供的核心模块（位于Node的系统安装目录中），或者一个位于各级node_modules目录的已安装模块（全局安装或局部安装）。 举例来说，脚本/home/user/projects/foo.js执行了require(&#39;bar.js&#39;)命令，Node会依次搜索以下文件。 /usr/local/lib/node/bar.js /home/user/projects/node_modules/bar.js /home/user/node_modules/bar.js /home/node_modules/bar.js /node_modules/bar.js 这样设计的目的是，使得不同的模块可以将所依赖的模块本地化。 （4）如果参数字符串不以“./“或”/“开头，而且是一个路径，比如require(&#39;example-module/path/to/file&#39;)，则将先找到example-module的位置，然后再以它为参数，找到后续路径。 （5）如果指定的模块文件没有发现，Node会尝试为文件名添加.js、.json、.node后，再去搜索。.js件会以文本格式的JavaScript脚本文件解析，.json文件会以JSON格式的文本文件解析，.node文件会以编译后的二进制文件解析。 （6）如果想得到require命令加载的确切文件名，使用require.resolve()方法。 目录的加载规则通常，我们会把相关的文件会放在一个目录里面，便于组织。这时，最好为该目录设置一个入口文件，让require方法可以通过这个入口文件，加载整个目录。 在目录中放置一个package.json文件，并且将入口文件写入main字段。下面是一个例子。 // package.json&#123; "name" : "some-library", "main" : "./lib/some-library.js" &#125; require发现参数字符串指向一个目录以后，会自动查看该目录的package.json文件，然后加载main字段指定的入口文件。如果package.json文件没有main字段，或者根本就没有package.json文件，则会加载该目录下的index.js文件或index.node文件。 模块的缓存第一次加载某个模块时，Node会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的module.exports属性。 require('./example.js');require('./example.js').message = "hello";require('./example.js').message// "hello" 上面代码中，连续三次使用require命令，加载同一个模块。第二次加载的时候，为输出的对象添加了一个message属性。但是第三次加载的时候，这个message属性依然存在，这就证明require命令并没有重新加载模块文件，而是输出了缓存。 如果想要多次执行某个模块，可以让该模块输出一个函数，然后每次require这个模块的时候，重新执行一下输出的函数。 所有缓存的模块保存在require.cache之中，如果想删除模块的缓存，可以像下面这样写。 // 删除指定模块的缓存delete require.cache[moduleName];// 删除所有模块的缓存Object.keys(require.cache).forEach(function(key) &#123; delete require.cache[key];&#125;) 注意，缓存是根据绝对路径识别模块的，如果同样的模块名，但是保存在不同的路径，require命令还是会重新加载该模块。 环境变量NODE_PATHNode执行一个脚本时，会先查看环境变量NODE_PATH。它是一组以冒号分隔的绝对路径。在其他位置找不到指定模块时，Node会去这些路径查找。 可以将NODE_PATH添加到.bashrc。 export NODE_PATH="/usr/local/lib/node" 所以，如果遇到复杂的相对路径，比如下面这样。 var myModule = require('../../../../lib/myModule'); 有两种解决方法，一是将该文件加入node_modules目录，二是修改NODE_PATH环境变量，package.json文件可以采用下面的写法。 &#123; "name": "node_path", "version": "1.0.0", "description": "", "main": "index.js", "scripts": &#123; "start": "NODE_PATH=lib node index.js" &#125;, "author": "", "license": "ISC"&#125; NODE_PATH是历史遗留下来的一个路径解决方案，通常不应该使用，而应该使用node_modules目录机制。 模块的循环加载如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。 // a.jsexports.x = 'a1';console.log('a.js ', require('./b.js').x);exports.x = 'a2';// b.jsexports.x = 'b1';console.log('b.js ', require('./a.js').x);exports.x = 'b2';// main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 上面代码是三个JavaScript文件。其中，a.js加载了b.js，而b.js又加载a.js。这时，Node返回a.js的不完整版本，所以执行结果如下。 $ node main.jsb.js a1a.js b2main.js a2main.js b2 修改main.js，再次加载a.js和b.js。 // main.jsconsole.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x);console.log('main.js ', require('./a.js').x);console.log('main.js ', require('./b.js').x); 执行上面代码，结果如下。 $ node main.jsb.js a1a.js b2main.js a2main.js b2main.js a2main.js b2 上面代码中，第二次加载a.js和b.js时，会直接从缓存读取exports属性，所以a.js和b.js内部的console.log语句都不会执行了。 require.mainrequire方法有一个main属性，可以用来判断模块是直接执行，还是被调用执行。 直接执行的时候（node module.js），require.main属性指向模块本身。 require.main === module// true 调用执行的时候（通过require加载该脚本执行），上面的表达式返回false。 模块的加载机制CommonJS模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个例子。 下面是一个模块文件lib.js。 // lib.jsvar counter = 3;function incCounter() &#123; counter++;&#125;module.exports = &#123; counter: counter, incCounter: incCounter,&#125;; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。 然后，加载上面的模块。 // main.jsvar counter = require('./lib').counter;var incCounter = require('./lib').incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。 require的内部处理流程require命令是CommonJS规范之中，用来加载其他模块的命令。它其实不是一个全局命令，而是指向当前模块的module.require命令，而后者又调用Node的内部命令Module._load。 Module._load = function(request, parent, isMain) &#123; // 1. 检查 Module._cache，是否缓存之中有指定模块 // 2. 如果缓存之中没有，就创建一个新的Module实例 // 3. 将它保存到缓存 // 4. 使用 module.load() 加载指定的模块文件， // 读取文件内容之后，使用 module.compile() 执行文件代码 // 5. 如果加载/解析过程报错，就从缓存删除该模块 // 6. 返回该模块的 module.exports&#125;; 上面的第4步，采用module.compile()执行指定模块的脚本，逻辑如下。 Module.prototype._compile = function(content, filename) &#123; // 1. 生成一个require函数，指向module.require // 2. 加载其他辅助方法到require // 3. 将文件内容放到一个函数之中，该函数可调用 require // 4. 执行该函数&#125;; 上面的第1步和第2步，require函数及其辅助方法主要如下。 require(): 加载外部模块 require.resolve()：将模块名解析到一个绝对路径 require.main：指向主模块 require.cache：指向所有缓存的模块 require.extensions：根据文件的后缀名，调用不同的执行函数 一旦require函数准备完毕，整个所要加载的脚本内容，就被放到一个新的函数之中，这样可以避免污染全局环境。该函数的参数包括require、module、exports，以及其他一些参数。 (function (exports, require, module, __filename, __dirname) &#123; // YOUR CODE INJECTED HERE!&#125;); Module._compile方法是同步执行的，所以Module._load要等它执行完成，才会向用户返回module.exports的值。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>模块化</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Express框架]]></title>
    <url>%2F2017%2F04%2F19%2FExpress%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[概述Express是目前最流行的基于Node.js的Web开发框架，可以快速地搭建一个完整功能的网站。 Express上手非常简单，首先新建一个项目目录，假定叫做hello-world。 $ mkdir hello-world 进入该目录，新建一个package.json文件，内容如下。 &#123; "name": "hello-world", "description": "hello world test app", "version": "0.0.1", "private": true, "dependencies": &#123; "express": "4.x" &#125;&#125; 上面代码定义了项目的名称、描述、版本等，并且指定需要4.0版本以上的Express。 然后，就可以安装了。 $ npm install 执行上面的命令以后，在项目根目录下，新建一个启动文件，假定叫做index.js。 var express = require('express');var app = express();app.use(express.static(__dirname + '/public'));app.listen(8080); 然后，运行上面的启动脚本。 $ node index 现在就可以访问http://localhost:8080，它会在浏览器中打开当前目录的public子目录（严格来说，是打开public目录的index.html文件）。如果public目录之中有一个图片文件my_image.png，那么可以用http://localhost:8080/my_image.png访问该文件。 你也可以在index.js之中，生成动态网页。 // index.jsvar express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello world!');&#125;);app.listen(3000); 然后，在命令行下运行启动脚本，就可以在浏览器中访问项目网站了。 $ node index 上面代码会在本机的3000端口启动一个网站，网页显示Hello World。 启动脚本index.js的app.get方法，用于指定不同的访问路径所对应的回调函数，这叫做“路由”（routing）。上面代码只指定了根目录的回调函数，因此只有一个路由记录。实际应用中，可能有多个路由记录。 // index.jsvar express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello world!');&#125;);app.get('/customer', function(req, res)&#123; res.send('customer page');&#125;);app.get('/admin', function(req, res)&#123; res.send('admin page');&#125;);app.listen(3000); 这时，最好就把路由放到一个单独的文件中，比如新建一个routes子目录。 // routes/index.jsmodule.exports = function (app) &#123; app.get('/', function (req, res) &#123; res.send('Hello world'); &#125;); app.get('/customer', function(req, res)&#123; res.send('customer page'); &#125;); app.get('/admin', function(req, res)&#123; res.send('admin page'); &#125;);&#125;; 然后，原来的index.js就变成下面这样。 // index.jsvar express = require('express');var app = express();var routes = require('./routes')(app);app.listen(3000); 运行原理底层：http模块Express框架建立在node.js内置的http模块上。http模块生成服务器的原始代码如下。 var http = require("http");var app = http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.end("Hello world!");&#125;);app.listen(3000, "localhost"); 上面代码的关键是http模块的createServer方法，表示生成一个HTTP服务器实例。该方法接受一个回调函数，该回调函数的参数，分别为代表HTTP请求和HTTP回应的request对象和response对象。 Express框架的核心是对http模块的再包装。上面的代码用Express改写如下。 var express = require('express');var app = express();app.get('/', function (req, res) &#123; res.send('Hello world!');&#125;);app.listen(3000); 比较两段代码，可以看到它们非常接近。原来是用http.createServer方法新建一个app实例，现在则是用Express的构造方法，生成一个Epress实例。两者的回调函数都是相同的。Express框架等于在http模块之上，加了一个中间层。 什么是中间件简单说，中间件（middleware）就是处理HTTP请求的函数。它最大的特点就是，一个中间件处理完，再传递给下一个中间件。App实例在运行过程中，会调用一系列的中间件。 每个中间件可以从App实例，接收三个参数，依次为request对象（代表HTTP请求）、response对象（代表HTTP回应），next回调函数（代表下一个中间件）。每个中间件都可以对HTTP请求（request对象）进行加工，并且决定是否调用next方法，将request对象再传给下一个中间件。 一个不进行任何操作、只传递request对象的中间件，就是下面这样。 function uselessMiddleware(req, res, next) &#123; next();&#125; 上面代码的next就是下一个中间件。如果它带有参数，则代表抛出一个错误，参数为错误文本。 function uselessMiddleware(req, res, next) &#123; next('出错了！');&#125; 抛出错误以后，后面的中间件将不再执行，直到发现一个错误处理函数为止。 use方法use是express注册中间件的方法，它返回一个函数。下面是一个连续调用两个中间件的例子。 var express = require("express");var http = require("http");var app = express();app.use(function(request, response, next) &#123; console.log("In comes a " + request.method + " to " + request.url); next();&#125;);app.use(function(request, response) &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); response.end("Hello world!\n");&#125;);http.createServer(app).listen(1337); 上面代码使用app.use方法，注册了两个中间件。收到HTTP请求后，先调用第一个中间件，在控制台输出一行信息，然后通过next方法，将执行权传给第二个中间件，输出HTTP回应。由于第二个中间件没有调用next方法，所以request对象就不再向后传递了。 use方法内部可以对访问路径进行判断，据此就能实现简单的路由，根据不同的请求网址，返回不同的网页内容。 var express = require("express");var http = require("http");var app = express();app.use(function(request, response, next) &#123; if (request.url == "/") &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); response.end("Welcome to the homepage!\n"); &#125; else &#123; next(); &#125;&#125;);app.use(function(request, response, next) &#123; if (request.url == "/about") &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); &#125; else &#123; next(); &#125;&#125;);app.use(function(request, response) &#123; response.writeHead(404, &#123; "Content-Type": "text/plain" &#125;); response.end("404 error!\n");&#125;);http.createServer(app).listen(1337); 上面代码通过request.url属性，判断请求的网址，从而返回不同的内容。注意，app.use方法一共登记了三个中间件，只要请求路径匹配，就不会将执行权交给下一个中间件。因此，最后一个中间件会返回404错误，即前面的中间件都没匹配请求路径，找不到所要请求的资源。 除了在回调函数内部判断请求的网址，use方法也允许将请求网址写在第一个参数。这代表，只有请求路径匹配这个参数，后面的中间件才会生效。无疑，这样写更加清晰和方便。 app.use('/path', someMiddleware); 上面代码表示，只对根目录的请求，调用某个中间件。 因此，上面的代码可以写成下面的样子。 var express = require("express");var http = require("http");var app = express();app.use("/home", function(request, response, next) &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); response.end("Welcome to the homepage!\n");&#125;);app.use("/about", function(request, response, next) &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); response.end("Welcome to the about page!\n");&#125;);app.use(function(request, response) &#123; response.writeHead(404, &#123; "Content-Type": "text/plain" &#125;); response.end("404 error!\n");&#125;);http.createServer(app).listen(1337); Express的方法all方法和HTTP动词方法针对不同的请求，Express提供了use方法的一些别名。比如，上面代码也可以用别名的形式来写。 var express = require("express");var http = require("http");var app = express();app.all("*", function(request, response, next) &#123; response.writeHead(200, &#123; "Content-Type": "text/plain" &#125;); next();&#125;);app.get("/", function(request, response) &#123; response.end("Welcome to the homepage!");&#125;);app.get("/about", function(request, response) &#123; response.end("Welcome to the about page!");&#125;);app.get("*", function(request, response) &#123; response.end("404!");&#125;);http.createServer(app).listen(1337); 上面代码的all方法表示，所有请求都必须通过该中间件，参数中的“*”表示对所有路径有效。get方法则是只有GET动词的HTTP请求通过该中间件，它的第一个参数是请求的路径。由于get方法的回调函数没有调用next方法，所以只要有一个中间件被调用了，后面的中间件就不会再被调用了。 除了get方法以外，Express还提供post、put、delete方法，即HTTP动词都是Express的方法。 这些方法的第一个参数，都是请求的路径。除了绝对匹配以外，Express允许模式匹配。 app.get("/hello/:who", function(req, res) &#123; res.end("Hello, " + req.params.who + ".");&#125;); 上面代码将匹配“/hello/alice”网址，网址中的alice将被捕获，作为req.params.who属性的值。需要注意的是，捕获后需要对网址进行检查，过滤不安全字符，上面的写法只是为了演示，生产中不应这样直接使用用户提供的值。 如果在模式参数后面加上问号，表示该参数可选。 app.get('/hello/:who?',function(req,res) &#123; if(req.params.id) &#123; res.end("Hello, " + req.params.who + "."); &#125; else &#123; res.send("Hello, Guest."); &#125;&#125;); 下面是一些更复杂的模式匹配的例子。 app.get('/forum/:fid/thread/:tid', middleware)// 匹配/commits/71dbb9c// 或/commits/71dbb9c..4c084f9这样的git格式的网址app.get(/^\/commits\/(\w+)(?:\.\.(\w+))?$/, function(req, res)&#123; var from = req.params[0]; var to = req.params[1] || 'HEAD'; res.send('commit range ' + from + '..' + to);&#125;); set方法set方法用于指定变量的值。 app.set("views", __dirname + "/views");app.set("view engine", "jade"); 上面代码使用set方法，为系统变量“views”和“view engine”指定值。 response对象（1）response.redirect方法 response.redirect方法允许网址的重定向。 response.redirect("/hello/anime");response.redirect("http://www.example.com");response.redirect(301, "http://www.example.com"); （2）response.sendFile方法 response.sendFile方法用于发送文件。 response.sendFile("/path/to/anime.mp4"); （3）response.render方法 response.render方法用于渲染网页模板。 app.get("/", function(request, response) &#123; response.render("index", &#123; message: "Hello World" &#125;);&#125;); 上面代码使用render方法，将message变量传入index模板，渲染成HTML网页。 requst对象（1）request.ip request.ip属性用于获得HTTP请求的IP地址。 （2）request.files request.files用于获取上传的文件。 搭建HTTPs服务器使用Express搭建HTTPs加密服务器，也很简单。 var fs = require('fs');var options = &#123; key: fs.readFileSync('E:/ssl/myserver.key'), cert: fs.readFileSync('E:/ssl/myserver.crt'), passphrase: '1234'&#125;;var https = require('https');var express = require('express');var app = express();app.get('/', function(req, res)&#123; res.send('Hello World Expressjs');&#125;);var server = https.createServer(options, app);server.listen(8084);console.log('Server is running on port 8084'); 项目开发实例编写启动脚本上一节使用express命令自动建立项目，也可以不使用这个命令，手动新建所有文件。 先建立一个项目目录（假定这个目录叫做demo）。进入该目录，新建一个package.json文件，写入项目的配置信息。 &#123; "name": "demo", "description": "My First Express App", "version": "0.0.1", "dependencies": &#123; "express": "3.x" &#125;&#125; 在项目目录中，新建文件app.js。项目的代码就放在这个文件里面。 var express = require('express');var app = express(); 上面代码首先加载express模块，赋给变量express。然后，生成express实例，赋给变量app。 接着，设定express实例的参数。 // 设定port变量，意为访问端口app.set('port', process.env.PORT || 3000);// 设定views变量，意为视图存放的目录app.set('views', path.join(__dirname, 'views'));// 设定view engine变量，意为网页模板引擎app.set('view engine', 'jade');app.use(express.favicon());app.use(express.logger('dev'));app.use(express.bodyParser());app.use(express.methodOverride());app.use(app.router);// 设定静态文件目录，比如本地文件// 目录为demo/public/images，访问// 网址则显示为http://localhost:3000/imagesapp.use(express.static(path.join(__dirname, 'public'))); 上面代码中的set方法用于设定内部变量，use方法用于调用express的中间件。 最后，调用实例方法listen，让其监听事先设定的端口（3000）。 app.listen(app.get('port')); 这时，运行下面的命令，就可以在浏览器访问http://127.0.0.1:3000。 node app.js 网页提示“Cannot GET /”，表示没有为网站的根路径指定可以显示的内容。所以，下一步就是配置路由。 配置路由所谓“路由”，就是指为不同的访问路径，指定不同的处理方法。 （1）指定根路径 在app.js之中，先指定根路径的处理方法。 app.get('/', function(req, res) &#123; res.send('Hello World');&#125;); 上面代码的get方法，表示处理客户端发出的GET请求。相应的，还有app.post、app.put、app.del（delete是JavaScript保留字，所以改叫del）方法。 get方法的第一个参数是访问路径，正斜杠（/）就代表根路径；第二个参数是回调函数，它的req参数表示客户端发来的HTTP请求，res参数代表发向客户端的HTTP回应，这两个参数都是对象。在回调函数内部，使用HTTP回应的send方法，表示向浏览器发送一个字符串。然后，运行下面的命令。 node app.js 此时，在浏览器中访问http://127.0.0.1:3000，网页就会显示“Hello World”。 如果需要指定HTTP头信息，回调函数就必须换一种写法，要使用setHeader方法与end方法。 app.get('/', function(req, res)&#123; var body = 'Hello World'; res.setHeader('Content-Type', 'text/plain'); res.setHeader('Content-Length', body.length); res.end(body);&#125;); （2）指定特定路径 上面是处理根目录的情况，下面再举一个例子。假定用户访问/api路径，希望返回一个JSON字符串。这时，get可以这样写。 app.get('/api', function(request, response) &#123; response.send(&#123;name:"张三",age:40&#125;);&#125;); 上面代码表示，除了发送字符串，send方法还可以直接发送对象。重新启动node以后，再访问路径/api，浏览器就会显示一个JSON对象。 &#123; "name": "张三", "age": 40&#125; 我们也可以把app.get的回调函数，封装成模块。先在routes目录下面建立一个api.js文件。 // routes/api.jsexports.index = function (req, res)&#123; res.json(200, &#123;name:"张三",age:40&#125;);&#125; 然后，在app.js中加载这个模块。 // app.jsvar api = require('./routes/api');app.get('/api', api.index); 现在访问时，就会显示与上一次同样的结果。 如果只向浏览器发送简单的文本信息，上面的方法已经够用；但是如果要向浏览器发送复杂的内容，还是应该使用网页模板。 静态网页模板在项目目录之中，建立一个子目录views，用于存放网页模板。 假定这个项目有三个路径：根路径（/）、自我介绍（/about）和文章（/article）。那么，app.js可以这样写： var express = require('express');var app = express(); app.get('/', function(req, res) &#123; res.sendfile('./views/index.html');&#125;); app.get('/about', function(req, res) &#123; res.sendfile('./views/about.html');&#125;); app.get('/article', function(req, res) &#123; res.sendfile('./views/article.html');&#125;); app.listen(3000); 上面代码表示，三个路径分别对应views目录中的三个模板：index.html、about.html和article.html。另外，向服务器发送信息的方法，从send变成了sendfile，后者专门用于发送文件。 假定index.html的内容如下： &lt;html&gt;&lt;head&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt; &lt;body&gt;&lt;h1&gt;Express Demo&lt;/h1&gt; &lt;footer&gt;&lt;p&gt; &lt;a href="/"&gt;首页&lt;/a&gt; - &lt;a href="/about"&gt;自我介绍&lt;/a&gt; - &lt;a href="/article"&gt;文章&lt;/a&gt;&lt;/p&gt;&lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 上面代码是一个静态网页。如果想要展示动态内容，就必须使用动态网页模板。 动态网页模板网站真正的魅力在于动态网页，下面我们来看看，如何制作一个动态网页的网站。 安装模板引擎Express支持多种模板引擎，这里采用Handlebars模板引擎的服务器端版本hbs模板引擎。 先安装hbs。 npm install hbs --save-dev 上面代码将hbs模块，安装在项目目录的子目录node_modules之中。save-dev参数表示，将依赖关系写入package.json文件。安装以后的package.json文件变成下面这样： // package.json文件&#123; "name": "demo", "description": "My First Express App", "version": "0.0.1", "dependencies": &#123; "express": "3.x" &#125;, "devDependencies": &#123; "hbs": "~2.3.1" &#125;&#125; 安装模板引擎之后，就要改写app.js。 // app.js文件var express = require('express');var app = express();// 加载hbs模块var hbs = require('hbs');// 指定模板文件的后缀名为htmlapp.set('view engine', 'html');// 运行hbs模块app.engine('html', hbs.__express);app.get('/', function (req, res)&#123; res.render('index');&#125;);app.get('/about', function(req, res) &#123; res.render('about');&#125;);app.get('/article', function(req, res) &#123; res.render('article');&#125;); 上面代码改用render方法，对网页模板进行渲染。render方法的参数就是模板的文件名，默认放在子目录views之中，后缀名已经在前面指定为html，这里可以省略。所以，res.render(‘index’) 就是指，把子目录views下面的index.html文件，交给模板引擎hbs渲染。 新建数据脚本渲染是指将数据代入模板的过程。实际运用中，数据都是保存在数据库之中的，这里为了简化问题，假定数据保存在一个脚本文件中。 在项目目录中，新建一个文件blog.js，用于存放数据。blog.js的写法符合CommonJS规范，使得它可以被require语句加载。 // blog.js文件var entries = [ &#123;"id":1, "title":"第一篇", "body":"正文", "published":"6/2/2013"&#125;, &#123;"id":2, "title":"第二篇", "body":"正文", "published":"6/3/2013"&#125;, &#123;"id":3, "title":"第三篇", "body":"正文", "published":"6/4/2013"&#125;, &#123;"id":4, "title":"第四篇", "body":"正文", "published":"6/5/2013"&#125;, &#123;"id":5, "title":"第五篇", "body":"正文", "published":"6/10/2013"&#125;, &#123;"id":6, "title":"第六篇", "body":"正文", "published":"6/12/2013"&#125;];exports.getBlogEntries = function ()&#123; return entries;&#125; exports.getBlogEntry = function (id)&#123; for(var i=0; i &lt; entries.length; i++)&#123; if(entries[i].id == id) return entries[i]; &#125;&#125; 新建网页模板接着，新建模板文件index.html。 &lt;!-- views/index.html文件 --&gt;&lt;h1&gt;文章列表&lt;/h1&gt; &#123;&#123;"&#123;&#123;"&#125;&#125;#each entries&#125;&#125; &lt;p&gt; &lt;a href="/article/&#123;&#123;"&#123;&#123;"&#125;&#125;id&#125;&#125;"&gt;&#123;&#123;"&#123;&#123;"&#125;&#125;title&#125;&#125;&lt;/a&gt;&lt;br/&gt; Published: &#123;&#123;"&#123;&#123;"&#125;&#125;published&#125;&#125; &lt;/p&gt;&#123;&#123;"&#123;&#123;"&#125;&#125;/each&#125;&#125; 模板文件about.html。 &lt;!-- views/about.html文件 --&gt;&lt;h1&gt;自我介绍&lt;/h1&gt; &lt;p&gt;正文&lt;/p&gt; 模板文件article.html。 &lt;!-- views/article.html文件 --&gt;&lt;h1&gt;&#123;&#123;"&#123;&#123;"&#125;&#125;blog.title&#125;&#125;&lt;/h1&gt;Published: &#123;&#123;"&#123;&#123;"&#125;&#125;blog.published&#125;&#125; &lt;p/&gt; &#123;&#123;"&#123;&#123;"&#125;&#125;blog.body&#125;&#125; 可以看到，上面三个模板文件都只有网页主体。因为网页布局是共享的，所以布局的部分可以单独新建一个文件layout.html。 &lt;!-- views/layout.html文件 --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&#123;&#123;"&#123;&#123;"&#125;&#125;title&#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &#123;&#123;"&#123;&#123;&#123;"&#125;&#125;body&#125;&#125;&#125; &lt;footer&gt; &lt;p&gt; &lt;a href="/"&gt;首页&lt;/a&gt; - &lt;a href="/about"&gt;自我介绍&lt;/a&gt; &lt;/p&gt; &lt;/footer&gt; &lt;/body&gt;&lt;/html&gt; 渲染模板最后，改写app.js文件。 // app.js文件var express = require('express');var app = express(); var hbs = require('hbs');// 加载数据模块var blogEngine = require('./blog'); app.set('view engine', 'html');app.engine('html', hbs.__express);app.use(express.bodyParser()); app.get('/', function(req, res) &#123; res.render('index',&#123;title:"最近文章", entries:blogEngine.getBlogEntries()&#125;);&#125;); app.get('/about', function(req, res) &#123; res.render('about', &#123;title:"自我介绍"&#125;);&#125;); app.get('/article/:id', function(req, res) &#123; var entry = blogEngine.getBlogEntry(req.params.id); res.render('article',&#123;title:entry.title, blog:entry&#125;);&#125;); app.listen(3000); 上面代码中的render方法，现在加入了第二个参数，表示模板变量绑定的数据。 现在重启node服务器，然后访问http://127.0.0.1:3000。 node app.js 可以看得，模板已经使用加载的数据渲染成功了。 指定静态文件目录模板文件默认存放在views子目录。这时，如果要在网页中加载静态文件（比如样式表、图片等），就需要另外指定一个存放静态文件的目录。 app.use(express.static('public')); 上面代码在文件app.js之中，指定静态文件存放的目录是public。于是，当浏览器发出非HTML文件请求时，服务器端就到public目录寻找这个文件。比如，浏览器发出如下的样式表请求： &lt;link href="/bootstrap/css/bootstrap.css" rel="stylesheet"&gt; 服务器端就到public/bootstrap/css/目录中寻找bootstrap.css文件。 Express.Router用法从Express 4.0开始，路由器功能成了一个单独的组件Express.Router。它好像小型的express应用程序一样，有自己的use、get、param和route方法。 基本用法首先，Express.Router是一个构造函数，调用后返回一个路由器实例。然后，使用该实例的HTTP动词方法，为不同的访问路径，指定回调函数；最后，挂载到某个路径。 var router = express.Router();router.get('/', function(req, res) &#123; res.send('首页');&#125;);router.get('/about', function(req, res) &#123; res.send('关于');&#125;);app.use('/', router); 上面代码先定义了两个访问路径，然后将它们挂载到根目录。如果最后一行改为app.use(‘/app’, router)，则相当于为/app和/app/about这两个路径，指定了回调函数。 这种路由器可以自由挂载的做法，为程序带来了更大的灵活性，既可以定义多个路由器实例，也可以为将同一个路由器实例挂载到多个路径。 router.route方法router实例对象的route方法，可以接受访问路径作为参数。 var router = express.Router();router.route('/api') .post(function(req, res) &#123; // ... &#125;) .get(function(req, res) &#123; Bear.find(function(err, bears) &#123; if (err) res.send(err); res.json(bears); &#125;); &#125;);app.use('/', router); router中间件use方法为router对象指定中间件，即在数据正式发给用户之前，对数据进行处理。下面就是一个中间件的例子。 router.use(function(req, res, next) &#123; console.log(req.method, req.url); next(); &#125;); 上面代码中，回调函数的next参数，表示接受其他中间件的调用。函数体中的next()，表示将数据传递给下一个中间件。 注意，中间件的放置顺序很重要，等同于执行顺序。而且，中间件必须放在HTTP动词方法之前，否则不会执行。 对路径参数的处理router对象的param方法用于路径参数的处理，可以 router.param('name', function(req, res, next, name) &#123; // 对name进行验证或其他处理…… console.log(name); req.name = name; next(); &#125;);router.get('/hello/:name', function(req, res) &#123; res.send('hello ' + req.name + '!');&#125;); 上面代码中，get方法为访问路径指定了name参数，param方法则是对name参数进行处理。注意，param方法必须放在HTTP动词方法之前。 app.route假定app是Express的实例对象，Express 4.0为该对象提供了一个route属性。app.route实际上是express.Router()的缩写形式，除了直接挂载到根路径。因此，对同一个路径指定get和post方法的回调函数，可以写成链式形式。 app.route('/login') .get(function(req, res) &#123; res.send('this is the login form'); &#125;) .post(function(req, res) &#123; console.log('processing'); res.send('processing the login form!'); &#125;); 上面代码的这种写法，显然非常简洁清晰。 上传文件首先，在网页插入上传文件的表单。 &lt;form action="/pictures/upload" method="POST" enctype="multipart/form-data"&gt; Select an image to upload: &lt;input type="file" name="image"&gt; &lt;input type="submit" value="Upload Image"&gt;&lt;/form&gt; 然后，服务器脚本建立指向/upload目录的路由。这时可以安装multer模块，它提供了上传文件的许多功能。 var express = require('express');var router = express.Router();var multer = require('multer');var uploading = multer(&#123; dest: __dirname + '../public/uploads/', // 设定限制，每次最多上传1个文件，文件大小不超过1MB limits: &#123;fileSize: 1000000, files:1&#125;,&#125;)router.post('/upload', uploading, function(req, res) &#123;&#125;)module.exports = router 上面代码是上传文件到本地目录。下面是上传到Amazon S3的例子。 首先，在S3上面新增CORS配置文件。 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;CORSConfiguration xmlns="http://s3.amazonaws.com/doc/2006-03-01/"&gt; &lt;CORSRule&gt; &lt;AllowedOrigin&gt;*&lt;/AllowedOrigin&gt; &lt;AllowedMethod&gt;GET&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;POST&lt;/AllowedMethod&gt; &lt;AllowedMethod&gt;PUT&lt;/AllowedMethod&gt; &lt;AllowedHeader&gt;*&lt;/AllowedHeader&gt; &lt;/CORSRule&gt;&lt;/CORSConfiguration&gt; 上面的配置允许任意电脑向你的bucket发送HTTP请求。 然后，安装aws-sdk。 $ npm install aws-sdk --save 下面是服务器脚本。 var express = require('express');var router = express.Router();var aws = require('aws-sdk');router.get('/', function(req, res) &#123; res.render('index')&#125;)var AWS_ACCESS_KEY = 'your_AWS_access_key'var AWS_SECRET_KEY = 'your_AWS_secret_key'var S3_BUCKET = 'images_upload'router.get('/sign', function(req, res) &#123; aws.config.update(&#123;accessKeyId: AWS_ACCESS_KEY, secretAccessKey: AWS_SECRET_KEY&#125;); var s3 = new aws.S3() var options = &#123; Bucket: S3_BUCKET, Key: req.query.file_name, Expires: 60, ContentType: req.query.file_type, ACL: 'public-read' &#125; s3.getSignedUrl('putObject', options, function(err, data)&#123; if(err) return res.send('Error with S3') res.json(&#123; signed_request: data, url: 'https://s3.amazonaws.com/' + S3_BUCKET + '/' + req.query.file_name &#125;) &#125;)&#125;)module.exports = router 上面代码中，用户访问/sign路径，正确登录后，会收到一个JSON对象，里面是S3返回的数据和一个暂时用来接收上传文件的URL，有效期只有60秒。 浏览器代码如下。 // HTML代码为// &lt;br&gt;Please select an image// &lt;input type="file" id="image"&gt;// &lt;br&gt;// &lt;img id="preview"&gt;document.getElementById("image").onchange = function() &#123; var file = document.getElementById("image").files[0] if (!file) return sign_request(file, function(response) &#123; upload(file, response.signed_request, response.url, function() &#123; document.getElementById("preview").src = response.url &#125;) &#125;)&#125;function sign_request(file, done) &#123; var xhr = new XMLHttpRequest() xhr.open("GET", "/sign?file_name=" + file.name + "&amp;file_type=" + file.type) xhr.onreadystatechange = function() &#123; if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; var response = JSON.parse(xhr.responseText) done(response) &#125; &#125; xhr.send()&#125;function upload(file, signed_request, url, done) &#123; var xhr = new XMLHttpRequest() xhr.open("PUT", signed_request) xhr.setRequestHeader('x-amz-acl', 'public-read') xhr.onload = function() &#123; if (xhr.status === 200) &#123; done() &#125; &#125; xhr.send(file)&#125; 上面代码首先监听file控件的change事件，一旦有变化，就先向服务器要求一个临时的上传URL，然后向该URL上传文件。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node应用程序开发]]></title>
    <url>%2F2017%2F04%2F19%2FNode%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[启动通常，我们在Shell启动Node脚本。 $ node /path/to/your/script.js 但是，这个Shell随着你退出Shell就自动结束了。 为了长期运行，Node应用程序可以在后台运行。 $ node /path/to/your/script.js &amp; 但是，在退出Shell以后，如果Node进程要在console输出内容，但console已经关了（即STDOUT已经不存在），这时进程就会退出。也没有办法重新启动。 为了让Node进程在后台长期启动，需要一个daemon（即常驻的服务进程）。有几种方法可以实现。 （1）forever forever是一个Node应用程序，用于一个子进程意外退出时，自动重启。 # 启动进程$ forever start example.js# 列出所有forever启动的正在运行的进程$ forever list# 停止进程$ forever stop example.js# 或者$ forever stop 0# 停止所有正在运行的进程$ forever stopall]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Buffer对象]]></title>
    <url>%2F2017%2F04%2F19%2FBuffer%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[概述Buffer对象是Node处理二进制数据的一个接口。它是Node原生提供的全局对象，可以直接使用，不需要require(&#39;buffer&#39;)。 JavaScript比较擅长处理字符串，对于处理二进制数据（比如TCP数据流），就不太擅长。Buffer对象就是为了解决这个问题而设计的。它是一个构造函数，生成的实例代表了V8引擎分配的一段内存，是一个类似数组的对象，成员都为0到255的整数值，即一个8位的字节。 // 生成一个256字节的Buffer实例var bytes = new Buffer(256);// 遍历每个字节，写入内容for (var i = 0; i &lt; bytes.length; i++) &#123; bytes[i] = i;&#125;// 生成一个buffer的view// 从240字节到256字节var end = bytes.slice(240, 256);end[0] // 240end[0] = 0;end[0] // 0 上面代码演示了如何生成Buffer对象实例，以及它的赋值和取值。 除了直接赋值，Buffer实例还可以拷贝生成。 var bytes = new Buffer(8);for (var i = 0; i &lt; bytes.length; i++) &#123; bytes[i] = i;&#125;var more = new Buffer(4);bytes.copy(more, 0, 4, 8);more[0] // 4 上面代码中，copy方法将bytes实例的4号成员到7号成员的这一段，都拷贝到了more实例从0号成员开始的区域。 Buffer对象与字符串的互相转换，需要指定编码格式。目前，Buffer对象支持以下编码格式。 ascii utf8 utf16le：UTF-16的小端编码，支持大于U+10000的四字节字符。 ucs2：utf16le的别名。 base64 hex：将每个字节转为两个十六进制字符。 与二进制数组的关系TypedArray构造函数可以接受Buffer实例作为参数，生成一个二进制数组。比如，new Uint32Array(new Buffer([1, 2, 3, 4]))，生成一个4个成员的二进制数组。注意，新数组的成员有四个，而不是只有单个成员（[0x1020304]或者[0x4030201]）。另外，这时二进制数组所对应的内存是从Buffer对象拷贝的，而不是共享的。二进制数组的buffer属性，保留指向原Buffer对象的指针。 二进制数组的操作，与Buffer对象的操作基本上是兼容的，只有轻微的差异。比如，二进制数组的slice方法返回原内存的拷贝，而Buffer对象的slice方法创造原内存的一个视图（view）。 Buffer构造函数Buffer作为构造函数，可以用new命令生成一个实例，它可以接受多种形式的参数。 // 参数是整数，指定分配多少个字节内存var hello = new Buffer(5);// 参数是数组，数组成员必须是整数值var hello = new Buffer([0x48, 0x65, 0x6c, 0x6c, 0x6f]);hello.toString() // 'Hello'// 参数是字符串（默认为utf8编码）var hello = new Buffer('Hello');hello.length // 5hello.toString() // "Hello"// 参数是字符串（不省略编码）var hello = new Buffer('Hello', 'utf8');// 参数是另一个Buffer实例，等同于拷贝后者var hello1 = new Buffer('Hello');var hello2 = new Buffer(hello1); 下面是读取用户命令行输入的例子。 var fs = require('fs');var buffer = new Buffer(1024);var readSize = fs.readSync(fs.openSync('/dev/tty', 'r'), buffer, 0, bufferSize);var chunk = buffer.toString('utf8', 0, readSize);console.log('INPUT: ' + chunk); 运行上面的程序结果如下。 # 输入任意内容，然后按回车键fooINPUT: foo 类的方法Buffer.isEncoding()Buffer.isEncoding方法返回一个布尔值，表示Buffer实例是否为指定编码。 Buffer.isEncoding('utf8')// true Buffer.isBuffer()Buffer.isBuffer方法接受一个对象作为参数，返回一个布尔值，表示该对象是否为Buffer实例。 Buffer.isBuffer(Date) // false Buffer.byteLength()Buffer.byteLength方法返回字符串实际占据的字节长度，默认编码方式为utf8。 Buffer.byteLength('Hello', 'utf8') // 5 Buffer.concat()Buffer.concat方法将一组Buffer对象合并为一个Buffer对象。 var i1 = new Buffer('Hello');var i2 = new Buffer(' ');var i3 = new Buffer('World');Buffer.concat([i1, i2, i3]).toString()// 'Hello World' 需要注意的是，如果Buffer.concat的参数数组只有一个成员，就直接返回该成员。如果有多个成员，就返回一个多个成员合并的新Buffer对象。 Buffer.concat方法还可以接受第二个参数，指定合并后Buffer对象的总长度。 var i1 = new Buffer('Hello');var i2 = new Buffer(' ');var i3 = new Buffer('World');Buffer.concat([i1, i2, i3], 10).toString()// 'Hello Worl' 省略第二个参数时，Node内部会计算出这个值，然后再据此进行合并运算。因此，显式提供这个参数，能提供运行速度。 实例属性lengthlength属性返回Buffer对象所占据的内存长度。注意，这个值与Buffer对象的内容无关。 buf = new Buffer(1234);buf.length // 1234buf.write("some string", 0, "ascii");buf.length // 1234 上面代码中，不管写入什么内容，length属性总是返回Buffer对象的空间长度。如果想知道一个字符串所占据的字节长度，可以将其传入Buffer.byteLength方法。 length属性是可写的，但是这会导致未定义的行为，不建议使用。如果想修改Buffer对象的长度，建议使用slice方法返回一个新的Buffer对象。 实例方法write()write方法可以向指定的Buffer对象写入数据。它的第一个参数是所写入的内容，第二个参数（可省略）是所写入的起始位置（默认从0开始），第三个参数（可省略）是编码方式，默认为utf8。 var buf = new Buffer(5);buf.write('He');buf.write('l', 2);buf.write('lo', 3);console.log(buf.toString());// "Hello" slice()slice方法返回一个按照指定位置、从原对象切割出来的Buffer实例。它的两个参数分别为切割的起始位置和终止位置。 var buf = new Buffer('just some data');var chunk = buf.slice(5, 9);chunk.toString()// "some" toString()toString方法将Buffer实例，按照指定编码（默认为utf8）转为字符串。 var hello = new Buffer('Hello');hello // &lt;Buffer 48 65 6c 6c 6f&gt;hello.toString() // "Hello" toString方法可以只返回指定位置内存的内容，它的第二个参数表示起始位置，第三个参数表示终止位置，两者都是从0开始计算。 var buf = new Buffer('just some data');console.log(buf.toString('ascii', 5, 9));// "some" toJSON()toJSON方法将Buffer实例转为JSON对象。如果JSON.stringify方法调用Buffer实例，默认会先调用toJSON方法。 var buf = new Buffer('test');var json = JSON.stringify(buf);json // '[116,101,115,116]'var copy = new Buffer(JSON.parse(json));copy // &lt;Buffer 74 65 73 74&gt;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path模块]]></title>
    <url>%2F2017%2F04%2F19%2FPath%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[path.join()path.join方法用于连接路径。该方法的主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是”/“，Windows系统是”\“。 var path = require('path');path.join(mydir, "foo"); 上面代码在Unix系统下，会返回路径mydir/foo。 path.resolve()path.resolve方法用于将相对路径转为绝对路径。 它可以接受多个参数，依次表示所要进入的路径，直到将最后一个参数转为绝对路径。如果根据参数无法得到绝对路径，就以当前所在路径作为基准。除了根目录，该方法的返回值都不带尾部的斜杠。 // 格式path.resolve([from ...], to)// 实例path.resolve('foo/bar', '/tmp/file/', '..', 'a/../subfile') 上面代码的实例，执行效果类似下面的命令。 $ cd foo/bar$ cd /tmp/file/$ cd ..$ cd a/../subfile$ pwd 更多例子。 path.resolve('/foo/bar', './baz')// '/foo/bar/baz'path.resolve('/foo/bar', '/tmp/file/')// '/tmp/file'path.resolve('wwwroot', 'static_files/png/', '../gif/image.gif')// 如果当前目录是/home/myself/node，返回// /home/myself/node/wwwroot/static_files/gif/image.gif 该方法忽略非字符串的参数。 accessSync()accessSync方法用于同步读取一个路径。 下面的代码可以用于判断一个目录是否存在。 function exists(pth, mode) &#123; try &#123; fs.accessSync(pth, mode); return true; &#125; catch (e) &#123; return false; &#125;&#125; path.relativepath.relative方法接受两个参数，这两个参数都应该是绝对路径。该方法返回第二个路径相对于第一个路径的那个相对路径。 path.relative('/data/orandea/test/aaa', '/data/orandea/impl/bbb')// '../../impl/bbb' 上面代码中，如果当前目录是/data/orandea/test/aaa，进入path.relative返回的相对路径，就会到达/data/orandea/impl/bbb。 如果path.relative方法的两个参数相同，则返回一个空字符串。 path.parse()path.parse()方法可以返回路径各部分的信息。 var myFilePath = '/someDir/someFile.json';path.parse(myFilePath).base// "someFile.json"path.parse(myFilePath).name// "someFile"path.parse(myFilePath).ext// ".json"]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fs模块]]></title>
    <url>%2F2017%2F04%2F19%2Ffs%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[fs是filesystem的缩写，该模块提供本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。但是，这个模块几乎对所有操作提供异步和同步两种操作方式，供开发者选择。 readFile()，readFileSync()readFile方法用于异步读取数据。 fs.readFile('./image.png', function (err, buffer) &#123; if (err) throw err; process(buffer);&#125;); readFile方法的第一个参数是文件的路径，可以是绝对路径，也可以是相对路径。注意，如果是相对路径，是相对于当前进程所在的路径（process.cmd()），而不是相对于当前脚本所在的路径。 readFile方法的第二个参数是读取完成后的回调函数。该函数的第一个参数是发生错误时的错误对象，第二个参数是代表文件内容的Buffer实例。 readFileSync方法用于同步读取文件，返回一个字符串。 var text = fs.readFileSync(fileName, 'utf8');// 将文件按行拆成数组text.split(/\r?\n/).forEach(function (line) &#123; // ...&#125;); readFileSync方法的第一个参数是文件路径，第二个参数可以是一个表示配置的对象，也可以是一个表示文本文件编码的字符串。默认的配置对象是{ encoding: null, flag: &#39;r&#39; }，即文件编码默认为null，读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回一个Buffer实例，否则返回的是一个字符串。 不同系统的行结尾字符不同，可以用下面的方法判断。 // 方法一，查询现有的行结尾字符var EOL = fileContents.indexOf('\r\n') &gt;= 0 ? '\r\n' : '\n';// 方法二，根据当前系统处理var EOL = (process.platform === 'win32' ? '\r\n' : '\n'); writeFile()，writeFileSync()writeFile方法用于异步写入文件。 fs.writeFile('message.txt', 'Hello Node.js', (err) =&gt; &#123; if (err) throw err; console.log('It\'s saved!');&#125;); 上面代码中，writeFile方法的第一个参数是写入的文件名，第二个参数是写入的字符串，第三个参数是回调函数。 回调函数前面，还可以再加一个参数，表示写入字符串的编码（默认是utf8）。 fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback); writeFileSync方法用于同步写入文件。 fs.writeFileSync(fileName, str, 'utf8'); 它的第一个参数是文件路径，第二个参数是写入文件的字符串，第三个参数是文件编码，默认为utf8。 exists(path, callback)exists方法用来判断给定路径是否存在，然后不管结果如何，都会调用回调函数。 fs.exists('/path/to/file', function (exists) &#123; util.debug(exists ? "it's there" : "no file!");&#125;); 上面代码表明，回调函数的参数是一个表示文件是否存在的布尔值。 需要注意的是，不要在open方法之前调用exists方法，open方法本身就能检查文件是否存在。 下面的例子是如果给定目录存在，就删除它。 if (fs.existsSync(outputFolder)) &#123; console.log('Removing ' + outputFolder); fs.rmdirSync(outputFolder);&#125; mkdir()，writeFile()，readFile()mkdir方法用于新建目录。 var fs = require('fs');fs.mkdir('./helloDir',0777, function (err) &#123; if (err) throw err;&#125;); mkdir接受三个参数，第一个是目录名，第二个是权限值，第三个是回调函数。 writeFile方法用于写入文件。 var fs = require('fs');fs.writeFile('./helloDir/message.txt', 'Hello Node', function (err) &#123; if (err) throw err; console.log('文件写入成功');&#125;); readFile方法用于读取文件内容。 var fs = require('fs');fs.readFile('./helloDir/message.txt','UTF-8' ,function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码使用readFile方法读取文件。readFile方法的第一个参数是文件名，第二个参数是文件编码，第三个参数是回调函数。可用的文件编码包括“ascii”、“utf8”和“base64”。如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法，将其转为字符串。 var fs = require('fs');fs.readFile('example_log.txt', function (err, logData) &#123; if (err) throw err; var text = logData.toString();&#125;); readFile方法是异步操作，所以必须小心，不要同时发起多个readFile请求。 for(var i = 1; i &lt;= 1000; i++) &#123; fs.readFile('./'+i+'.txt', function() &#123; // do something with the file &#125;);&#125; 上面代码会同时发起1000个readFile异步请求，很快就会耗尽系统资源。 mkdirSync()，writeFileSync()，readFileSync()这三个方法是建立目录、写入文件、读取文件的同步版本。 fs.mkdirSync('./helloDirSync',0777);fs.writeFileSync('./helloDirSync/message.txt', 'Hello Node');var data = fs.readFileSync('./helloDirSync/message.txt','UTF-8');console.log('file created with contents:');console.log(data); 对于流量较大的服务器，最好还是采用异步操作，因为同步操作时，只有前一个操作结束，才会开始后一个操作，如果某个操作特别耗时（常常发生在读写数据时），会导致整个程序停顿。 readdir()，readdirSync()readdir方法用于读取目录，返回一个所包含的文件和子目录的数组。 fs.readdir(process.cwd(), function (err, files) &#123; if (err) &#123; console.log(err); return; &#125; var count = files.length; var results = &#123;&#125;; files.forEach(function (filename) &#123; fs.readFile(filename, function (data) &#123; results[filename] = data; count--; if (count &lt;= 0) &#123; // 对所有文件进行处理 &#125; &#125;); &#125;);&#125;); readdirSync方法是readdir方法的同步版本。下面是同步列出目录内容的代码。 var files = fs.readdirSync(dir);files.forEach(function (filename) &#123; var fullname = path.join(dir,filename); var stats = fs.statSync(fullname); if (stats.isDirectory()) filename += '/'; process.stdout.write(filename + '\t' + stats.size + '\t' + stats.mtime + '\n' );&#125;); stat()stat方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。我们往往通过该方法，判断正在处理的到底是一个文件，还是一个目录。 var fs = require('fs');fs.readdir('/etc/', function (err, files) &#123; if (err) throw err; files.forEach( function (file) &#123; fs.stat('/etc/' + file, function (err, stats) &#123; if (err) throw err; if (stats.isFile()) &#123; console.log("%s is file", file); &#125; else if (stats.isDirectory ()) &#123; console.log("%s is a directory", file); &#125; console.log('stats: %s',JSON.stringify(stats)); &#125;); &#125;);&#125;); watchfile()，unwatchfile()watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 var fs = require('fs');fs.watchFile('./testFile.txt', function (curr, prev) &#123; console.log('the current mtime is: ' + curr.mtime); console.log('the previous mtime was: ' + prev.mtime);&#125;);fs.writeFile('./testFile.txt', "changed", function (err) &#123; if (err) throw err; console.log("file write complete"); &#125;); unwatchfile方法用于解除对文件的监听。 createReadStream()createReadStream方法往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。 var fs = require('fs');function readLines(input, func) &#123; var remaining = ''; input.on('data', function(data) &#123; remaining += data; var index = remaining.indexOf('\n'); var last = 0; while (index &gt; -1) &#123; var line = remaining.substring(last, index); last = index + 1; func(line); index = remaining.indexOf('\n', last); &#125; remaining = remaining.substring(last); &#125;); input.on('end', function() &#123; if (remaining.length &gt; 0) &#123; func(remaining); &#125; &#125;);&#125;function func(data) &#123; console.log('Line: ' + data);&#125;var input = fs.createReadStream('lines.txt');readLines(input, func); createWriteStream()createWriteStream方法创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作。 var out = fs.createWriteStream(fileName, &#123; encoding: 'utf8'&#125;);out.write(str);out.end(); createWriteStream方法和createReadStream方法配合，可以实现拷贝大型文件。 function fileCopy(filename1, filename2, done) &#123; var input = fs.createReadStream(filename1); var output = fs.createWriteStream(filename2); input.on('data', function(d) &#123; output.write(d); &#125;); input.on('error', function(err) &#123; throw err; &#125;); input.on('end', function() &#123; output.end(); if (done) done(); &#125;);&#125; 本地文件的读写能力，基本上是POSIX文件操作命令的简单包装。但是，这个模块几乎对所有操作提供异步和同步两种操作方式，供开发者选择。 readFile()，readFileSync()readFile方法用于异步读取数据。 fs.readFile('./image.png', function (err, buffer) &#123; if (err) throw err; process(buffer);&#125;); readFile方法的第一个参数是文件的路径，可以是绝对路径，也可以是相对路径。注意，如果是相对路径，是相对于当前进程所在的路径（process.cmd()），而不是相对于当前脚本所在的路径。 readFile方法的第二个参数是读取完成后的回调函数。该函数的第一个参数是发生错误时的错误对象，第二个参数是代表文件内容的Buffer实例。 readFileSync方法用于同步读取文件，返回一个字符串。 var text = fs.readFileSync(fileName, 'utf8');// 将文件按行拆成数组text.split(/\r?\n/).forEach(function (line) &#123; // ...&#125;); readFileSync方法的第一个参数是文件路径，第二个参数可以是一个表示配置的对象，也可以是一个表示文本文件编码的字符串。默认的配置对象是{ encoding: null, flag: &#39;r&#39; }，即文件编码默认为null，读取模式默认为r（只读）。如果第二个参数不指定编码（encoding），readFileSync方法返回一个Buffer实例，否则返回的是一个字符串。 不同系统的行结尾字符不同，可以用下面的方法判断。 // 方法一，查询现有的行结尾字符var EOL = fileContents.indexOf('\r\n') &gt;= 0 ? '\r\n' : '\n';// 方法二，根据当前系统处理var EOL = (process.platform === 'win32' ? '\r\n' : '\n'); writeFile()，writeFileSync()writeFile方法用于异步写入文件。 fs.writeFile('message.txt', 'Hello Node.js', (err) =&gt; &#123; if (err) throw err; console.log('It\'s saved!');&#125;); 上面代码中，writeFile方法的第一个参数是写入的文件名，第二个参数是写入的字符串，第三个参数是回调函数。 回调函数前面，还可以再加一个参数，表示写入字符串的编码（默认是utf8）。 fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback); writeFileSync方法用于同步写入文件。 fs.writeFileSync(fileName, str, 'utf8'); 它的第一个参数是文件路径，第二个参数是写入文件的字符串，第三个参数是文件编码，默认为utf8。 exists(path, callback)exists方法用来判断给定路径是否存在，然后不管结果如何，都会调用回调函数。 fs.exists('/path/to/file', function (exists) &#123; util.debug(exists ? "it's there" : "no file!");&#125;); 上面代码表明，回调函数的参数是一个表示文件是否存在的布尔值。 需要注意的是，不要在open方法之前调用exists方法，open方法本身就能检查文件是否存在。 下面的例子是如果给定目录存在，就删除它。 if (fs.existsSync(outputFolder)) &#123; console.log('Removing ' + outputFolder); fs.rmdirSync(outputFolder);&#125; mkdir()，writeFile()，readFile()mkdir方法用于新建目录。 var fs = require('fs');fs.mkdir('./helloDir',0777, function (err) &#123; if (err) throw err;&#125;); mkdir接受三个参数，第一个是目录名，第二个是权限值，第三个是回调函数。 writeFile方法用于写入文件。 var fs = require('fs');fs.writeFile('./helloDir/message.txt', 'Hello Node', function (err) &#123; if (err) throw err; console.log('文件写入成功');&#125;); readFile方法用于读取文件内容。 var fs = require('fs');fs.readFile('./helloDir/message.txt','UTF-8' ,function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 上面代码使用readFile方法读取文件。readFile方法的第一个参数是文件名，第二个参数是文件编码，第三个参数是回调函数。可用的文件编码包括“ascii”、“utf8”和“base64”。如果没有指定文件编码，返回的是原始的缓存二进制数据，这时需要调用buffer对象的toString方法，将其转为字符串。 var fs = require('fs');fs.readFile('example_log.txt', function (err, logData) &#123; if (err) throw err; var text = logData.toString();&#125;); readFile方法是异步操作，所以必须小心，不要同时发起多个readFile请求。 for(var i = 1; i &lt;= 1000; i++) &#123; fs.readFile('./'+i+'.txt', function() &#123; // do something with the file &#125;);&#125; 上面代码会同时发起1000个readFile异步请求，很快就会耗尽系统资源。 mkdirSync()，writeFileSync()，readFileSync()这三个方法是建立目录、写入文件、读取文件的同步版本。 fs.mkdirSync('./helloDirSync',0777);fs.writeFileSync('./helloDirSync/message.txt', 'Hello Node');var data = fs.readFileSync('./helloDirSync/message.txt','UTF-8');console.log('file created with contents:');console.log(data); 对于流量较大的服务器，最好还是采用异步操作，因为同步操作时，只有前一个操作结束，才会开始后一个操作，如果某个操作特别耗时（常常发生在读写数据时），会导致整个程序停顿。 readdir()，readdirSync()readdir方法用于读取目录，返回一个所包含的文件和子目录的数组。 fs.readdir(process.cwd(), function (err, files) &#123; if (err) &#123; console.log(err); return; &#125; var count = files.length; var results = &#123;&#125;; files.forEach(function (filename) &#123; fs.readFile(filename, function (data) &#123; results[filename] = data; count--; if (count &lt;= 0) &#123; // 对所有文件进行处理 &#125; &#125;); &#125;);&#125;); readdirSync方法是readdir方法的同步版本。下面是同步列出目录内容的代码。 var files = fs.readdirSync(dir);files.forEach(function (filename) &#123; var fullname = path.join(dir,filename); var stats = fs.statSync(fullname); if (stats.isDirectory()) filename += '/'; process.stdout.write(filename + '\t' + stats.size + '\t' + stats.mtime + '\n' );&#125;); stat()stat方法的参数是一个文件或目录，它产生一个对象，该对象包含了该文件或目录的具体信息。我们往往通过该方法，判断正在处理的到底是一个文件，还是一个目录。 var fs = require('fs');fs.readdir('/etc/', function (err, files) &#123; if (err) throw err; files.forEach( function (file) &#123; fs.stat('/etc/' + file, function (err, stats) &#123; if (err) throw err; if (stats.isFile()) &#123; console.log("%s is file", file); &#125; else if (stats.isDirectory ()) &#123; console.log("%s is a directory", file); &#125; console.log('stats: %s',JSON.stringify(stats)); &#125;); &#125;);&#125;); watchfile()，unwatchfile()watchfile方法监听一个文件，如果该文件发生变化，就会自动触发回调函数。 var fs = require('fs');fs.watchFile('./testFile.txt', function (curr, prev) &#123; console.log('the current mtime is: ' + curr.mtime); console.log('the previous mtime was: ' + prev.mtime);&#125;);fs.writeFile('./testFile.txt', "changed", function (err) &#123; if (err) throw err; console.log("file write complete"); &#125;); unwatchfile方法用于解除对文件的监听。 createReadStream()createReadStream方法往往用于打开大型的文本文件，创建一个读取操作的数据流。所谓大型文本文件，指的是文本文件的体积很大，读取操作的缓存装不下，只能分成几次发送，每次发送会触发一个data事件，发送结束会触发end事件。 var fs = require('fs');function readLines(input, func) &#123; var remaining = ''; input.on('data', function(data) &#123; remaining += data; var index = remaining.indexOf('\n'); var last = 0; while (index &gt; -1) &#123; var line = remaining.substring(last, index); last = index + 1; func(line); index = remaining.indexOf('\n', last); &#125; remaining = remaining.substring(last); &#125;); input.on('end', function() &#123; if (remaining.length &gt; 0) &#123; func(remaining); &#125; &#125;);&#125;function func(data) &#123; console.log('Line: ' + data);&#125;var input = fs.createReadStream('lines.txt');readLines(input, func); createWriteStream()createWriteStream方法创建一个写入数据流对象，该对象的write方法用于写入数据，end方法用于结束写入操作。 var out = fs.createWriteStream(fileName, &#123; encoding: 'utf8'&#125;);out.write(str);out.end(); createWriteStream方法和createReadStream方法配合，可以实现拷贝大型文件。 function fileCopy(filename1, filename2, done) &#123; var input = fs.createReadStream(filename1); var output = fs.createWriteStream(filename2); input.on('data', function(d) &#123; output.write(d); &#125;); input.on('error', function(err) &#123; throw err; &#125;); input.on('end', function() &#123; output.end(); if (done) done(); &#125;);&#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os模块]]></title>
    <url>%2F2017%2F04%2F19%2Fos%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[os模块提供与操作系统相关的方法。 APIos.EOLos.EOL属性是一个常量，返回当前操作系统的换行符（Windows系统是\r\n，其他系统是\n）。 const fs = require(`fs`);// badfs.readFile('./myFile.txt', 'utf8', (err, data) =&gt; &#123; data.split('\r\n').forEach(line =&gt; &#123; // do something &#125;);&#125;);// goodconst os = require('os');fs.readFile('./myFile.txt', 'utf8', (err, data) =&gt; &#123; data.split(os.EOL).forEach(line =&gt; &#123; // do something &#125;);&#125;); os.arch()os.arch方法返回当前计算机的架构。 require(`os`).arch()// "x64" os.tmpdir()os.tmpdir方法返回操作系统默认的临时文件目录。 Socket通信下面例子列出当前系列的所有IP地址。 var os = require('os');var interfaces = os.networkInterfaces();for (item in interfaces) &#123; console.log('Network interface name: ' + item); for (att in interfaces[item]) &#123; var address = interfaces[item][att]; console.log('Family: ' + address.family); console.log('IP Address: ' + address.address); console.log('Is Internal: ' + address.internal); console.log(''); &#125; console.log('==================================');&#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Child Process模块]]></title>
    <url>%2F2017%2F04%2F19%2FChild%20Process%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[child_process模块用于新建子进程。子进程的运行结果储存在系统缓存之中（最大200KB），等到子进程运行结束以后，主进程再用回调函数读取子进程的运行结果。 exec()exec方法用于执行bash命令，它的参数是一个命令字符串。 var exec = require('child_process').exec;var ls = exec('ls -l', function (error, stdout, stderr) &#123; if (error) &#123; console.log(error.stack); console.log('Error code: ' + error.code); &#125; console.log('Child Process STDOUT: ' + stdout);&#125;); 上面代码的exec方法用于新建一个子进程，然后缓存它的运行结果，运行结束后调用回调函数。 exec方法最多可以接受两个参数，第一个参数是所要执行的shell命令，第二个参数是回调函数，该函数接受三个参数，分别是发生的错误、标准输出的显示结果、标准错误的显示结果。 由于标准输出和标准错误都是流对象（stream），可以监听data事件，因此上面的代码也可以写成下面这样。 var exec = require('child_process').exec;var child = exec('ls -l');child.stdout.on('data', function(data) &#123; console.log('stdout: ' + data);&#125;);child.stderr.on('data', function(data) &#123; console.log('stdout: ' + data);&#125;);child.on('close', function(code) &#123; console.log('closing code: ' + code);&#125;); 上面的代码还表明，子进程本身有close事件，可以设置回调函数。 上面的代码还有一个好处。监听data事件以后，可以实时输出结果，否则只有等到子进程结束，才会输出结果。所以，如果子进程运行时间较长，或者是持续运行，第二种写法更好。 下面是另一个例子，假定有一个child.js文件。 // child.jsvar exec = require('child_process').exec;exec('node -v', function(error, stdout, stderr) &#123; console.log('stdout: ' + stdout); console.log('stderr: ' + stderr); if (error !== null) &#123; console.log('exec error: ' + error); &#125;&#125;); 运行后，该文件的输出结果如下。 $ node child.jsstdout: v0.11.14stderr: exec方法会直接调用bash（/bin/sh程序）来解释命令，所以如果有用户输入的参数，exec方法是不安全的。 var path = ";user input";child_process.exec('ls -l ' + path, function (err, data) &#123; console.log(data);&#125;); 上面代码表示，在bash环境下，ls -l; user input会直接运行。如果用户输入恶意代码，将会带来安全风险。因此，在有用户输入的情况下，最好不使用exec方法，而是使用execFile方法。 execSync()execSync是exec的同步执行版本。 它可以接受两个参数，第一个参数是所要执行的命令，第二个参数用来配置执行环境。 var execSync = require("child_process").execSync;var SEPARATOR = process.platform === 'win32' ? ';' : ':';var env = Object.assign(&#123;&#125;, process.env);env.PATH = path.resolve('./node_modules/.bin') + SEPARATOR + env.PATH;function myExecSync(cmd) &#123; var output = execSync(cmd, &#123; cwd: process.cwd(), env: env &#125;); console.log(output);&#125;myExecSync('eslint .'); 上面代码中，execSync方法的第二个参数是一个对象。该对象的cwd属性指定脚本的当前目录，env属性指定环境变量。上面代码将./node_modules/.bin目录，存入$PATH变量。这样就可以不加路径，引用项目内部的模块命令了，比如eslint命令实际执行的是./node_modules/.bin/eslint。 execFile()execFile方法直接执行特定的程序，参数作为数组传入，不会被bash解释，因此具有较高的安全性。 var child_process = require('child_process');var path = ".";child_process.execFile('/bin/ls', ['-l', path], function (err, result) &#123; console.log(result)&#125;); 上面代码中，假定path来自用户输入，如果其中包含了分号或反引号，ls程序不理解它们的含义，因此也就得不到运行结果，安全性就得到了提高。 spawn()spawn方法创建一个子进程来执行特定命令，用法与execFile方法类似，但是没有回调函数，只能通过监听事件，来获取运行结果。它属于异步执行，适用于子进程长时间运行的情况。 var child_process = require('child_process');var path = '.';var ls = child_process.spawn('/bin/ls', ['-l', path]);ls.stdout.on('data', function (data) &#123; console.log('stdout: ' + data);&#125;);ls.stderr.on('data', function (data) &#123; console.log('stderr: ' + data);&#125;);ls.on('close', function (code) &#123; console.log('child process exited with code ' + code);&#125;); spawn方法接受两个参数，第一个是可执行文件，第二个是参数数组。 spawn对象返回一个对象，代表子进程。该对象部署了EventEmitter接口，它的data事件可以监听，从而得到子进程的输出结果。 spawn方法与exec方法非常类似，只是使用格式略有区别。 child_process.exec(command, [options], callback)child_process.spawn(command, [args], [options]) fork()fork方法直接创建一个子进程，执行Node脚本，fork(&#39;./child.js&#39;) 相当于 spawn(&#39;node&#39;, [&#39;./child.js&#39;]) 。与spawn方法不同的是，fork会在父进程与子进程之间，建立一个通信管道，用于进程之间的通信。 var n = child_process.fork('./child.js');n.on('message', function(m) &#123; console.log('PARENT got message:', m);&#125;);n.send(&#123; hello: 'world' &#125;); 上面代码中，fork方法返回一个代表进程间通信管道的对象，对该对象可以监听message事件，用来获取子进程返回的信息，也可以向子进程发送信息。 child.js脚本的内容如下。 process.on('message', function(m) &#123; console.log('CHILD got message:', m);&#125;);process.send(&#123; foo: 'bar' &#125;); 上面代码中，子进程监听message事件，并向父进程发送信息。 send()使用 child_process.fork() 生成新进程之后，就可以用 child.send(message, [sendHandle]) 向新进程发送消息。新进程中通过监听message事件，来获取消息。 下面的例子是主进程的代码。 var cp = require('child_process');var n = cp.fork(__dirname + '/sub.js');n.on('message', function(m) &#123; console.log('PARENT got message:', m);&#125;);n.send(&#123; hello: 'world' &#125;); 下面是子进程sub.js代码。 process.on('message', function(m) &#123; console.log('CHILD got message:', m);&#125;);process.send(&#123; foo: 'bar' &#125;);]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stream接口]]></title>
    <url>%2F2017%2F04%2F19%2FStream%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[数据读写可以看作是事件模式（Event）的特例，不断发送的数据块好比一个个的事件。读数据是read事件，写数据是write事件，而数据块是事件附带的信息。Node 为这类情况提供了一个特殊接口Stream。 概述概念”数据流“（stream）是处理系统缓存的一种方式。操作系统采用数据块（chunk）的方式读取数据，每收到一次数据，就存入缓存。Node应用程序有两种缓存的处理方式，第一种是等到所有数据接收完毕，一次性从缓存读取，这就是传统的读取文件的方式；第二种是采用“数据流”的方式，收到一块数据，就读取一块，即在数据还没有接收完成时，就开始处理它。 第一种方式先将数据全部读入内存，然后处理，优点是符合直觉，流程非常自然，缺点是如果遇到大文件，要花很长时间，才能进入数据处理的步骤。第二种方式每次只读入数据的一小块，像“流水”一样，每当系统读入了一小块数据，就会触发一个事件，发出“新数据块”的信号。应用程序只要监听这个事件，就能掌握数据读取的进展，做出相应处理，这样就提高了程序的性能。 var fs = require('fs');fs.createReadStream('./data/customers.csv').pipe(process.stdout); 上面代码中，fs.createReadStream方法就是以”数据流“的方式读取文件，这可以在文件还没有读取完的情况下，就输出到标准输出。这显然对大文件的读取非常有利。 Unix操作系统从很早以前，就有“数据流”这个概念，它是不同进程之间传递数据的一种方式。管道命令（pipe）就起到在不同命令之间，连接数据流的作用。“数据流”相当于把较大的数据拆成很小的部分，一个命令只要部署了数据流接口，就可以把一个流的输出接到另一个流的输入。Node引入了这个概念，通过数据流接口为异步读写数据提供的统一接口，无论是硬盘数据、网络数据，还是内存数据，都可以采用这个接口读写。 数据流接口最大特点就是通过事件通信，具有readable、writable、drain、data、end、close等事件，既可以读取数据，也可以写入数据。读写数据时，每读入（或写入）一段数据，就会触发一次data事件，全部读取（或写入）完毕，触发end事件。如果发生错误，则触发error事件。 一个对象只要部署了数据流接口，就可以从它读取数据，或者写入数据。Node内部很多涉及IO处理的对象，都部署了Stream接口，下面就是其中的一些。 文件读写 HTTP 请求的读写 TCP 连接 标准输入输出 可读数据流Stream 接口分成三类。 可读数据流接口，用于对外提供数据。 可写数据流接口，用于写入数据。 双向数据流接口，用于读取和写入数据，比如Node的tcp sockets、zlib、crypto都部署了这个接口。 “可读数据流”用来产生数据。它表示数据的来源，只要一个对象提供“可读数据流”，就表示你可以从其中读取数据。 var Readable = require('stream').Readable;var rs = new Readable();rs.push('beep ');rs.push('boop\n');rs.push(null);rs.pipe(process.stdout); 上面代码产生了一个可写数据流，最后将其写入标注输出。可读数据流的push方法，用来将数据输入缓存。rs.push(null)中的null，用来告诉rs，数据输入完毕。 “可读数据流”有两种状态：流动态和暂停态。处于流动态时，数据会尽快地从数据源导向用户的程序；处于暂停态时，必须显式调用stream.read()等指令，“可读数据流”才会释放数据。刚刚新建的时候，“可读数据流”处于暂停态。 三种方法可以让暂停态转为流动态。 添加data事件的监听函数 调用resume方法 调用pipe方法将数据送往一个可写数据流 如果转为流动态时，没有data事件的监听函数，也没有pipe方法的目的地，那么数据将遗失。 以下两种方法可以让流动态转为暂停态。 不存在pipe方法的目的地时，调用pause方法 存在pipe方法的目的地时，移除所有data事件的监听函数，并且调用unpipe方法，移除所有pipe方法的目的地 注意，只移除data事件的监听函数，并不会自动引发数据流进入“暂停态”。另外，存在pipe方法的目的地时，调用pause方法，并不能保证数据流总是处于暂停态，一旦那些目的地发出数据请求，数据流有可能会继续提供数据。 每当系统有新的数据，该接口可以监听到data事件，从而回调函数。 var fs = require('fs');var readableStream = fs.createReadStream('file.txt');var data = '';readableStream.setEncoding('utf8');readableStream.on('data', function(chunk) &#123; data+=chunk;&#125;);readableStream.on('end', function() &#123; console.log(data);&#125;); 上面代码中，fs模块的createReadStream方法，是部署了Stream接口的文件读取方法。该方法对指定的文件，返回一个对象。该对象只要监听data事件，回调函数就能读到数据。 除了data事件，监听readable事件，也可以读到数据。 var fs = require('fs');var readableStream = fs.createReadStream('file.txt');var data = '';var chunk;readableStream.setEncoding('utf8');readableStream.on('readable', function() &#123; while ((chunk=readableStream.read()) !== null) &#123; data += chunk; &#125;&#125;);readableStream.on('end', function() &#123; console.log(data)&#125;); readable事件表示系统缓冲之中有可读的数据，使用read方法去读出数据。如果没有数据可读，read方法会返回null。 “可读数据流”除了read方法，还有以下方法。 Readable.pause() ：暂停数据流。已经存在的数据，也不再触发data事件，数据将保留在缓存之中，此时的数据流称为静态数据流。如果对静态数据流再次调用pause方法，数据流将重新开始流动，但是缓存中现有的数据，不会再触发data事件。 Readable.resume()：恢复暂停的数据流。 readable.unpipe()：从管道中移除目的地数据流。如果该方法使用时带有参数，会阻止“可读数据流”进入某个特定的目的地数据流。如果使用时不带有参数，则会移除所有的目的地数据流。 readable 属性一个数据流的readable属性返回一个布尔值。如果数据流是一个仍然打开的可读数据流，就返回true，否则返回false。 read()read方法从系统缓存读取并返回数据。如果读不到数据，则返回null。 该方法可以接受一个整数作为参数，表示所要读取数据的数量，然后会返回该数量的数据。如果读不到足够数量的数据，返回null。如果不提供这个参数，默认返回系统缓存之中的所有数据。 只在“暂停态”时，该方法才有必要手动调用。“流动态”时，该方法是自动调用的，直到系统缓存之中的数据被读光。 var readable = getReadableStreamSomehow();readable.on('readable', function() &#123; var chunk; while (null !== (chunk = readable.read())) &#123; console.log('got %d bytes of data', chunk.length); &#125;&#125;); 如果该方法返回一个数据块，那么它就触发了data事件。 _read()可读数据流的_read方法，可以将数据放入可读数据流。 var Readable = require('stream').Readable;var rs = Readable();var c = 97;rs._read = function () &#123; rs.push(String.fromCharCode(c++)); if (c &gt; 'z'.charCodeAt(0)) rs.push(null);&#125;;rs.pipe(process.stdout); 运行结果如下。 $ node read1.jsabcdefghijklmnopqrstuvwxyz setEncoding()调用该方法，会使得数据流返回指定编码的字符串，而不是缓存之中的二进制对象。比如，调用setEncoding(&#39;utf8&#39;)，数据流会返回UTF-8字符串，调用setEncoding(&#39;hex&#39;)，数据流会返回16进制的字符串。 setEncoding的参数是字符串的编码方法，比如utf8、ascii、base64等。 该方法会正确处理多字节的字符，而缓存的方法buf.toString(encoding)不会。所以如果想要从数据流读取字符串，应该总是使用该方法。 var readable = getReadableStreamSomehow();readable.setEncoding('utf8');readable.on('data', function(chunk) &#123; assert.equal(typeof chunk, 'string'); console.log('got %d characters of string data', chunk.length);&#125;); resume()resume方法会使得“可读数据流”继续释放data事件，即转为流动态。 // 新建一个readable数据流var readable = getReadableStreamSomehow();readable.resume();readable.on('end', function(chunk) &#123; console.log('数据流到达尾部，未读取任务数据');&#125;); 上面代码中，调用resume方法使得数据流进入流动态，只定义end事件的监听函数，不定义data事件的监听函数，表示不从数据流读取任何数据，只监听数据流到达尾部。 pause()pause方法使得流动态的数据流，停止释放data事件，转而进入暂停态。任何此时已经可以读到的数据，都将停留在系统缓存。 // 新建一个readable数据流var readable = getReadableStreamSomehow();readable.on('data', function(chunk) &#123; console.log('读取%d字节的数据', chunk.length); readable.pause(); console.log('接下来的1秒内不读取数据'); setTimeout(function() &#123; console.log('数据恢复读取'); readable.resume(); &#125;, 1000);&#125;); isPaused()该方法返回一个布尔值，表示“可读数据流”被客户端手动暂停（即调用了pause方法），目前还没有调用resume方法。 var readable = new stream.Readablereadable.isPaused() // === falsereadable.pause()readable.isPaused() // === truereadable.resume()readable.isPaused() // === false pipe()pipe方法是自动传送数据的机制，就像管道一样。它从“可读数据流”读出所有数据，将其写出指定的目的地。整个过程是自动的。 src.pipe(dst) pipe方法必须在可读数据流上调用，它的参数必须是可写数据流。 var fs = require('fs');var readableStream = fs.createReadStream('file1.txt');var writableStream = fs.createWriteStream('file2.txt');readableStream.pipe(writableStream); 上面代码使用pipe方法，将file1的内容写入file2。整个过程由pipe方法管理，不用手动干预，所以可以将传送数据写得很简洁。 pipe方法返回目的地的数据流，因此可以使用链式写法，将多个数据流操作连在一起。 a.pipe(b).pipe(c).pipe(d)// 等同于a.pipe(b);b.pipe(c);c.pipe(d); 下面是一个例子。 var fs = require('fs');var zlib = require('zlib');fs.createReadStream('input.txt.gz') .pipe(zlib.createGunzip()) .pipe(fs.createWriteStream('output.txt')); 上面代码采用链式写法，先读取文件，然后进行压缩，最后输出。 下面的写法模拟了Unix系统的cat命令，将标准输出写入标准输入。 process.stdin.pipe(process.stdout); 当来源地的数据流读取完成，默认会调用目的地的end方法，就不再能够写入。对pipe方法传入第二个参数{ end: false }，可以让目的地的数据流保持打开。 reader.pipe(writer, &#123; end: false &#125;);reader.on('end', function() &#123; writer.end('Goodbye\n');&#125;); 上面代码中，目的地数据流默认不会调用end方法，只能手动调用，因此“Goodbye”会被写入。 unpipe()该方法移除pipe方法指定的数据流目的地。如果没有参数，则移除所有的pipe方法目的地。如果有参数，则移除该参数指定的目的地。如果没有匹配参数的目的地，则不会产生任何效果。 var readable = getReadableStreamSomehow();var writable = fs.createWriteStream('file.txt');readable.pipe(writable);setTimeout(function() &#123; console.log('停止写入file.txt'); readable.unpipe(writable); console.log('手动关闭file.txt的写入数据流'); writable.end();&#125;, 1000); 上面代码写入file.txt的时间，只有1秒钟，然后就停止写入。 事件下面代码中，s是一个readable数据流，它可以监听以下事件。 s.on(&apos;data&apos;, f); // 收到新的数据时，data事件就会发生，触发f()s.on(&apos;end&apos;, f); // 数据读取完以后，不会再收到数据了，end事件发生，触发f()s.on(&apos;error&apos;, f); // 发生错误时，error事件发生，触发f()s.readable // =&gt; true if it is a readable stream that is still opens.pause(); // Pause &quot;data&quot; events. For throttling uploads, e.g.s.resume(); // Resume again（1）readablereadable事件在数据流能够向外提供数据时触发。```javascriptvar readable = getReadableStreamSomehow();readable.on(&apos;readable&apos;, function() &#123; // there is some data to read now&#125;); 下面是一个例子。 process.stdin.on('readable', function () &#123; var buf = process.stdin.read(); console.dir(buf);&#125;); 上面代码将标准输入的数据读出。 read方法接受一个整数作为参数，表示以多少个字节为单位进行读取。 process.stdin.on('readable', function () &#123; var buf = process.stdin.read(3); console.dir(buf);&#125;); 上面代码将以3个字节为单位进行输出内容。 （2）data 对于那些没有显式暂停的数据流，添加data事件监听函数，会将数据流切换到流动态，尽快向外提供数据。 var readable = getReadableStreamSomehow();readable.on('data', function(chunk) &#123; console.log('got %d bytes of data', chunk.length);&#125;); （3）end 无法再读取到数据时，会触发end事件。也就是说，只有当前数据被完全读取完，才会触发end事件，比如不停地调用read方法。 var readable = getReadableStreamSomehow();readable.on('data', function(chunk) &#123; console.log('got %d bytes of data', chunk.length);&#125;);readable.on('end', function() &#123; console.log('there will be no more data.');&#125;); （4）close 数据源关闭时，close事件被触发。并不是所有的数据流都支持这个事件。 （5）error 当读取数据发生错误时，error事件被触发。 继承可读数据流接口可读数据流又分成两种，一种是 pull 模式，自己拉数据，就好像用吸管吸水，只有你吸了，水才会上来；另一种是 push 模式，数据自动推送给你，就好像水从水龙头自动涌出来。如果监听data事件，那么自动激活 push 模式；如果自己从数据流读取数据，那就是在使用 pull 模式。 任何对象都可以部署可读数据流的接口。 var Readable = require('stream').Readable;var util = require('util');function MyObject(options) &#123; if (! (this instanceof MyObject)) return new MyObject(options); if (! options) options = &#123;&#125;; options.objectMode = true; Readable.call(this, options);&#125;util.inherits(MyObject, Readable);MyObject.prototype._read = function read() &#123; var self = this; someMethodGetData(function(err, data) &#123; if (err) self.emit('error', err); else self.push(data); &#125;);&#125;; 上面代码中，构造函数MyObject继承了读数据流的接口。options.objectMode设为true，是为了设置数据流处理的是对象，而不是字符串或者 buffer。此外，还要在MyObject.prototype上部署_read方法，每当数据流要读取数据，就会调用这个方法。在这个方法里面，我们取到数据，使用stream.push(data)将数据放进数据流。 然后，MyObject的实例就可以使用“读数据流”的接口了。 var myObj = new MyObject();myObj.on('data', function(data) &#123; console.log(data);&#125;); 上面是 push 模式，下面是 pull 模式。 var myObj = new MyObject();var data = myObj.read(); myObj也可以暂停/恢复读数据。 myObj.pause();setTimeout(function () &#123; myObj.resume();&#125;, 5000); 实例： fs 模块的读数据流fs模块的createReadStream方法，就可以创建一个读取数据的数据流。 var fs = require('fs');var stream = fs.createReadStream('readme.txt');stream.setEncoding('utf8'); 上面代码创建了一个文本文件readme.txt的数据流。由于这个数据流会当作文本处理，所以要用setEncoding方法设定编码。 然后，监听data事件，获取每一个数据块；监听end事件，当数据传送结束，再统一处理。 var data = '';stream.on('data', function(chunk) &#123; data += chunk;&#125;)stream.on('end', function() &#123; console.log('Data length: %d', data.length);&#125;); 监听readable事件，也可以取得与监听data事件同样的效果。 var data = '';stream.on('readable', function() &#123; var chunk; while(chunk = stream.read()) &#123; data += chunk; &#125;&#125;); 数据流还有pause和resume方法，可以暂停和恢复数据传送。 // 暂停stream.pause();// 1秒后恢复setTimeout(stream.resume(), 1000); 注意，数据流新建以后，默认状态是暂停，只有指定了data事件的回调函数，或者调用了resume方法，数据才会开发发送。 如果要同时使用readable与data事件，可以像下面这样写。 stream.pause();var pulledData = '';var pushedData = '';stream.on('readable', function() &#123; var chunk; while(chunk = stream.read()) &#123; pulledData += chunk; &#125;&#125;);stream.on('data', function(chunk) &#123; pushedData += chunk;&#125;); 上面代码中，显式调用pause方法，会使得readable事件释放一个data事件，否则data监听无效。 如果觉得data事件和end事件写起来太麻烦，Stream 接口还提供了pipe方法，自动处理这两个事件。数据流通过pipe方法，可以方便地导向其他具有Stream接口的对象。 var fs = require('fs');var zlib = require('zlib');fs.createReadStream('wow.txt') .pipe(zlib.createGzip()) .pipe(process.stdout); 上面代码先打开文本文件wow.txt，然后压缩，再导向标准输出。 fs.createReadStream('wow.txt') .pipe(zlib.createGzip()) .pipe(fs.createWriteStream('wow.gz')); 上面代码压缩文件wow.txt以后，又将其写回压缩文件。 下面代码新建一个Stream实例，然后指定写入事件和终止事件的回调函数，再将其接到标准输入之上。 var stream = require('stream');var Stream = stream.Stream;var ws = new Stream;ws.writable = true;ws.write = function(data) &#123; console.log("input=" + data);&#125;ws.end = function(data) &#123; console.log("bye");&#125;process.stdin.pipe(ws); 调用上面的脚本，会产生以下结果。 $ node pipe_out.jshelloinput=hello^dbye 上面代码调用脚本下，键入hello，会输出input=hello。然后按下ctrl-d，会输出bye。使用管道命令，可以看得更清楚。 $ echo hello | node pipe_out.jsinput=hellobye 可写数据流“可读数据流”用来对外释放数据，“可写数据流”则是用来接收数据。它允许你将数据写入某个目的地。它是数据写入的一种抽象，不同的数据目的地部署了这个接口以后，就可以用统一的方法写入。 以下是部署了可写数据流的一些场合。 客户端的http requests 服务器的http responses fs write streams zlib streams crypto streams tcp sockets child process stdin process.stdout, process.stderr 只要调用stream.write(o)，就能将数据写入可读数据流。stream.write(payload, callback)可以指定回调函数callback，一旦缓存中的数据释放（payload），就会调用这个回调函数。 部署“可写数据流”，必须继承stream.Writable，以及实现stream._write方法。下面是一个例子，数据库的写入接口部署“可写数据流”接口。 var Writable = require('stream').Writable;var util = require('util');module.exports = DatabaseWriteStream;function DatabaseWriteStream(options) &#123; if (! (this instanceof DatabaseWriteStream)) return new DatabaseWriteStream(options); if (! options) options = &#123;&#125;; options.objectMode = true; Writable.call(this, options);&#125;util.inherits(DatabaseWriteStream, Writable);DatabaseWriteStream.prototype._write = function write(doc, encoding, callback) &#123; insertIntoDatabase(JSON.stringify(doc), callback);&#125;; 上面代码中，_write方法执行实际的写入操作，它必须接受三个参数。 chunk：要写入的数据块 encoding：如果写入的是字符串，必须字符串的编码 callback：写入完成后或发生错误时的回调函数 下面是用法的例子。 var DbWriteStream = require('./db_write_stream');var db = DbWriteStream();var Thermometer = require('./thermometer');var thermomether = Thermometer();thermomether.on('data', function(temp) &#123; db.write(&#123;when: Date.now(), temperature: temp&#125;);&#125;); 下面是fs模块的可写数据流的例子。 var fs = require('fs');var readableStream = fs.createReadStream('file1.txt');var writableStream = fs.createWriteStream('file2.txt');readableStream.setEncoding('utf8');readableStream.on('data', function(chunk) &#123; writableStream.write(chunk);&#125;); 上面代码中，fs模块的createWriteStream方法针对特定文件，创建了一个“可写数据流”，本质上就是对写入操作部署了Stream接口。然后，“可写数据流”的write方法，可以将数据写入文件。 writable属性writable属性返回一个布尔值。如果数据流仍然打开，并且可写，就返回true，否则返回false。 s.writeable write()write方法用于向“可写数据流”写入数据。它接受两个参数，一个是写入的内容，可以是字符串，也可以是一个stream对象（比如可读数据流）或buffer对象（表示二进制数据），另一个是写入完成后的回调函数，它是可选的。 s.write(buffer); // 写入二进制数据s.write(string, encoding) // 写入字符串，编码默认为utf-8 write方法返回一个布尔值，表示本次数据是否处理完成。如果返回true，就表示可以写入新的数据了。如果等待写入的数据被缓存了，就返回false，表示此时不能立刻写入新的数据。不过，返回false的情况下，也可以继续传入新的数据等待写入。只是这时，新的数据不会真的写入，只会缓存在内存中。为了避免内存消耗，比较好的做法还是等待该方法返回true，然后再写入。 var fs = require('fs');var ws = fs.createWriteStream('message.txt');ws.write('beep ');setTimeout(function () &#123; ws.end('boop\n');&#125;, 1000); 上面代码调用end方法，数据就不再写入了。 cork()，uncork()cork方法可以强制等待写入的数据进入缓存。当调用uncork方法或end方法时，缓存的数据就会吐出。 setDefaultEncoding()setDefaultEncoding方法用于将写入的数据编码成新的格式。它返回一个布尔值，表示编码是否成功，如果返回false就表示编码失败。 end()end方法用于终止“可写数据流”。该方法可以接受三个参数，全部都是可选参数。第一个参数是最后所要写入的数据，可以是字符串，也可以是stream对象或buffer对象；第二个参数是写入编码；第三个参数是一个回调函数，finish事件发生时，会触发这个回调函数。 s.end() // 关闭可写数据流s.end(buffer) // 最后一段写入二进制数据，然后关闭可写数据流s.end(str, encoding) // 最后一段写入字符串，然后关闭可写数据流 下面是一个例子。 var file = fs.createWriteStream('example.txt');file.write('hello, ');file.end('world!'); 上面代码会在数据写入结束时，在尾部写入“world！”。 调用end方法之后，再写入数据会报错。 var file = fs.createWriteStream('example.txt');file.end('world!');file.write('hello, '); // 报错 事件（1）drain事件 writable.write(chunk)返回false以后，当缓存数据全部写入完成，可以继续写入时，会触发drain事件，表示缓存空了。 s.on('drain', f); 下面是一个例子。 function writeOneMillionTimes(writer, data, encoding, callback) &#123; var i = 1000000; write(); function write() &#123; var ok = true; do &#123; i -= 1; if (i === 0) &#123; writer.write(data, encoding, callback); &#125; else &#123; ok = writer.write(data, encoding); &#125; &#125; while (i &gt; 0 &amp;&amp; ok); if (i &gt; 0) &#123; writer.once('drain', write); &#125; &#125;&#125; 上面代码是一个写入100万次的例子，通过drain事件得到可以继续写入的通知。 （2）finish事件 调用end方法时，所有缓存的数据释放，触发finish事件。该事件的回调函数没有参数。 var writer = getWritableStreamSomehow();for (var i = 0; i &lt; 100; i ++) &#123; writer.write('hello, #' + i + '!\n');&#125;writer.end('this is the end\n');writer.on('finish', function() &#123; console.error('all writes are now complete.');&#125;); （3）pipe事件 “可写数据流”调用pipe方法，将数据流导向写入目的地时，触发该事件。 该事件的回调函数，接受发出该事件的“可读数据流”对象作为参数。 var writer = getWritableStreamSomehow();var reader = getReadableStreamSomehow();writer.on('pipe', function(src) &#123; console.error('something is piping into the writer'); assert.equal(src, reader);&#125;);reader.pipe(writer); （4）unpipe事件 “可读数据流”调用unpipe方法，将可写数据流移出写入目的地时，触发该事件。 该事件的回调函数，接受发出该事件的“可读数据流”对象作为参数。 var writer = getWritableStreamSomehow();var reader = getReadableStreamSomehow();writer.on('unpipe', function(src) &#123; console.error('something has stopped piping into the writer'); assert.equal(src, reader);&#125;);reader.pipe(writer);reader.unpipe(writer); （5）error事件 如果写入数据或pipe数据时发生错误，就会触发该事件。 该事件的回调函数，接受一个Error对象作为参数。 pipe 方法你可能会问为什么数据库要部署“可写数据流”接口，而不是直接使用原始的写入接口。答案就是为了可以使用pipe方法。 var DbWriteStream = require('./db_write_stream');var db = DbWriteStream();var Thermometer = require('./thermometer');var thermomether = Thermometer();thermomether.pipe(db);// 10秒后断开连接setTimeout(function () &#123; thermometer.unpipe(db);&#125;, 10e3); 当可读数据流与可写数据流通过readable.pipe(writable)结合在一起时，数据会自动调整到消费者的速率。在内部，pipe使用“可写数据流”的.write()方法的返回值，来决定是否是否暂停读数据：如果writable.write返回true，表明数据已经写入完毕，缓存已经空了；如果返回false，就表示可写数据流正在缓存写入的数据，这意味着可以读取数据。等到”可写数据流“排空，就会释放drain事件，告诉数据源可以恢复释放数据了。 转换数据流转换数据流用于将可读数据流释放的数据，转换成另一种格式，然后再发给可写数据流。 下面的例子是将一个JavaScript对象的数据流，转为JSON字符串的数据流。 // json_encode_stream.jsvar Transform = require('stream').Transform;var inherits = require('util').inherits;module.exports = JSONEncode;function JSONEncode(options) &#123; if ( ! (this instanceof JSONEncode)) return new JSONEncode(options); if (! options) options = &#123;&#125;; options.objectMode = true; Transform.call(this, options);&#125;inherits(JSONEncode, Transform);JSONEncode.prototype._transform = function _transform(obj, encoding, callback) &#123; try &#123; obj = JSON.stringify(obj); &#125; catch(err) &#123; return callback(err); &#125; this.push(obj); callback();&#125;; 上面代码中，_transform方法接受原始的JavaScript对象，将它们转为JSON字符串。 然后，可读数据流与可写数据流之间，就可以用转换数据流连起来。 var DbWriteStream = require('./db_write_stream');var db = DbWriteStream();var JSONEncodeStream = require('./json_encode_stream');var json = JSONEncodeStream();var Thermometer = require('../thermometer');var thermometer = Thermometer();thermometer.pipe(json).pipe(db); HTTP请求HTTP对象使用Stream接口，实现网络数据的读写。 var http = require('http');var server = http.createServer(function (req, res) &#123; // req is an http.IncomingMessage, which is a Readable Stream // res is an http.ServerResponse, which is a Writable Stream var body = ''; // we want to get the data as utf8 strings // If you don't set an encoding, then you'll get Buffer objects req.setEncoding('utf8'); // Readable streams emit 'data' events once a listener is added req.on('data', function (chunk) &#123; body += chunk; &#125;); // the end event tells you that you have entire body req.on('end', function () &#123; try &#123; var data = JSON.parse(body); &#125; catch (er) &#123; // uh oh! bad json! res.statusCode = 400; return res.end('error: ' + er.message); &#125; // write back something interesting to the user: res.write(typeof data); res.end(); &#125;);&#125;);server.listen(1337);// $ curl localhost:1337 -d '&#123;&#125;'// object// $ curl localhost:1337 -d '"foo"'// string// $ curl localhost:1337 -d 'not json'// error: Unexpected token o data事件表示读取或写入了一块数据。 req.on('data', function(buf)&#123; // Do something with the Buffer&#125;); 使用req.setEncoding方法，可以设定字符串编码。 req.setEncoding('utf8');req.on('data', function(str)&#123; // Do something with the String&#125;); end事件，表示读取或写入数据完毕。 var http = require('http');http.createServer(function(req, res)&#123; res.writeHead(200); req.on('data', function(data)&#123; res.write(data); &#125;); req.on('end', function()&#123; res.end(); &#125;);&#125;).listen(3000); 上面代码相当于建立了“回声”服务，将HTTP请求的数据体，用HTTP回应原样发送回去。 system模块提供了pump方法，有点像Linux系统的管道功能，可以将一个数据流，原封不动得转给另一个数据流。所以，上面的例子也可以用pump方法实现。 var http = require('http'), sys = require('sys');http.createServer(function(req, res)&#123; res.writeHead(200); sys.pump(req, res);&#125;).listen(3000); fs模块fs模块的createReadStream方法用于新建读取数据流，createWriteStream方法用于新建写入数据流。使用这两个方法，可以做出一个用于文件复制的脚本copy.js。 // copy.jsvar fs = require('fs');console.log(process.argv[2], '-&gt;', process.argv[3]);var readStream = fs.createReadStream(process.argv[2]);var writeStream = fs.createWriteStream(process.argv[3]);readStream.on('data', function (chunk) &#123; writeStream.write(chunk);&#125;);readStream.on('end', function () &#123; writeStream.end();&#125;);readStream.on('error', function (err) &#123; console.log("ERROR", err);&#125;);writeStream.on('error', function (err) &#123; console.log("ERROR", err);&#125;);d all your errors, you wouldn't need to use domains. 上面代码非常容易理解，使用的时候直接提供源文件路径和目标文件路径，就可以了。 node cp.js src.txt dest.txt Streams对象都具有pipe方法，起到管道作用，将一个数据流输入另一个数据流。所以，上面代码可以重写成下面这样： var fs = require('fs');console.log(process.argv[2], '-&gt;', process.argv[3]);var readStream = fs.createReadStream(process.argv[2]);var writeStream = fs.createWriteStream(process.argv[3]);readStream.on('open', function () &#123; readStream.pipe(writeStream);&#125;);readStream.on('end', function () &#123; writeStream.end();&#125;); 错误处理下面是压缩后发送文件的代码。 http.createServer(function (req, res) &#123; // set the content headers fs.createReadStream('filename.txt') .pipe(zlib.createGzip()) .pipe(res)&#125;) 上面的代码没有部署错误处理机制，一旦发生错误，就无法处理。所以，需要加上error事件的监听函数。 http.createServer(function (req, res) &#123; // set the content headers fs.createReadStream('filename.txt') .on('error', onerror) .pipe(zlib.createGzip()) .on('error', onerror) .pipe(res) function onerror(err) &#123; console.error(err.stack) &#125;&#125;) 上面的代码还是存在问题，如果客户端中断下载，写入的数据流就会收不到close事件，一直处于等待状态，从而造成内存泄漏。因此，需要使用on-finished模块用来处理这种情况。 http.createServer(function (req, res) &#123; var stream = fs.createReadStream('filename.txt') // set the content headers stream .on('error', onerror) .pipe(zlib.createGzip()) .on('error', onerror) .pipe(res) onFinished(res, function () &#123; // make sure the stream is always destroyed stream.destroy() &#125;)&#125;)]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[assert模块]]></title>
    <url>%2F2017%2F04%2F19%2Fassert%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[assert模块是Node的内置模块，主要用于断言。如果表达式不符合预期，就抛出一个错误。该模块提供11个方法，但只有少数几个是常用的。 assert()assert方法接受两个参数，当第一个参数对应的布尔值为true时，不会有任何提示，返回undefined。当第一个参数对应的布尔值为false时，会抛出一个错误，该错误的提示信息就是第二个参数设定的字符串。 // 格式assert(value, message)// 例子var assert = require('assert');function add (a, b) &#123; return a + b;&#125;var expected = add(1,2);assert( expected === 3, '预期1加2等于3'); 上面代码不会有任何输出，因为assert方法的第一个参数是true。 assert( expected === 4, '预期1加2等于3')// AssertionError: 预期1加2等于3 上面代码会抛出一个错误，因为assert方法的第一个参数是false。 assert.ok()ok是assert方法的另一个名字，与assert方法完全一样。 assert.equal()equal方法接受三个参数，第一个参数是实际值，第二个是预期值，第三个是错误的提示信息。 // 格式assert.equal(actual, expected, [message])assert.equal(true, value, message);// 等同于assert(value, message);// 例子var assert = require('assert');function add (a, b) &#123; return a + b;&#125;var expected = add(1,2);// 以下三句效果相同assert(expected == 3, '预期1+2等于3');assert.ok(expected == 3, '预期1+2等于3');assert.equal(expected, 3, '预期1+2等于3'); equal方法内部使用的是相等运算符（==），而不是严格运算符（===），进行比较运算。 assert.notEqual()notEqual方法的用法与equal方法类似，但只有在实际值等于预期值时，才会抛出错误。 // 格式assert.notEqual(actual, expected, [message])// 用法var assert = require('assert');function add (a, b) &#123; return a + b;&#125;var expected = add(1,2);// 以下三种写法效果相同assert(expected != 4, '预期不等于4');assert.ok(expected != 4, '预期不等于4');assert.notEqual(expected, 4, '预期不等于4'); notEqual方法内部使用不相等运算符（!=），而不是严格不相等运算符（!==），进行比较运算。 assert.deepEqual()deepEqual方法用来比较两个对象。只要它们的属性一一对应，且值都相等，就认为两个对象相等，否则抛出一个错误。 // 格式assert.deepEqual(actual, expected, [message])// 例子var assert = require('assert');var list1 = [1, 2, 3, 4, 5];var list2 = [1, 2, 3, 4, 5];assert.deepEqual(list1, list2, '预期两个数组应该有相同的属性');var person1 = &#123; "name":"john", "age":"21" &#125;;var person2 = &#123; "name":"john", "age":"21" &#125;;assert.deepEqual(person1, person2, '预期两个对象应该有相同的属性'); assert.notDeepEqual()notDeepEqual方法与deepEqual方法正好相反，用来断言两个对象是否不相等。 // 格式assert.notDeepEqual(actual, expected, [message])// 例子var assert = require('assert');var list1 = [1, 2, ,3, 4, 5];var list2 = [1, 2, 3, 4, 5];assert.notDeepEqual(list1, list2, '预期两个对象不相等');var person1 = &#123; "name":"john", "age":"21" &#125;;var person2 = &#123; "name":"jane", "age":"19" &#125;;// deepEqual checks the elements in the objects are identicalassert.notDeepEqual(person1, person2, '预期两个对象不相等'); assert.strictEqual()strictEqual方法使用严格相等运算符（===），比较两个表达式。 // 格式assert.strictEqual(actual, expected, [message])// 例子var assert = require('assert');assert.strictEqual(1, '1', '预期严格相等');// AssertionError: 预期严格相等 assert.notStrictEqual()assert.notStrictEqual方法使用严格不相等运算符（!==），比较两个表达式。 // 格式assert.notStrictEqual(actual, expected, [message])// 例子var assert = require('assert');assert.notStrictEqual(1, true, '预期严格不相等'); assert.throws()throws方法预期某个代码块会抛出一个错误，且抛出的错误符合指定的条件。 // 格式assert.throws(block, [error], [message])// 例一，抛出的错误符合某个构造函数assert.throws( function() &#123; throw new Error("Wrong value"); &#125;, Error, '不符合预期的错误类型');// 例二、抛出错误的提示信息符合正则表达式assert.throws( function() &#123; throw new Error("Wrong value"); &#125;, /value/, '不符合预期的错误类型');// 例三、抛出的错误符合自定义函数的校验assert.throws( function() &#123; throw new Error("Wrong value"); &#125;, function(err) &#123; if ( (err instanceof Error) &amp;&amp; /value/.test(err) ) &#123; return true; &#125; &#125;, '不符合预期的错误类型'); assert.doesNotThrow()doesNotThrow方法与throws方法正好相反，预期某个代码块不抛出错误。 // 格式assert.doesNotThrow(block, [message])// 用法assert.doesNotThrow( function() &#123; console.log("Nothing to see here"); &#125;, '预期不抛出错误'); assert.ifError()ifError方法断言某个表达式是否false，如果该表达式对应的布尔值等于true，就抛出一个错误。它对于验证回调函数的第一个参数十分有用，如果该参数为true，就表示有错误。 // 格式assert.ifError(value)// 用法function sayHello(name, callback) &#123; var error = false; var str = "Hello "+name; callback(error, str);&#125;// use the functionsayHello('World', function(err, value)&#123; assert.ifError(err); // ...&#125;) assert.fail()fail方法用于抛出一个错误。 // 格式assert.fail(actual, expected, message, operator)// 例子var assert = require('assert');assert.fail(21, 42, 'Test Failed', '##')// AssertionError: Test Failedassert.fail(21, 21, 'Test Failed', '##')// AssertionError: Test Failedassert.fail(21, 42, undefined, '##')// AssertionError: 21 ## 42 该方法共有四个参数，但是不管参数是什么值，它总是抛出一个错误。如果message参数对应的布尔值不为false，抛出的错误信息就是message，否则错误信息就是“实际值 + 分隔符 + 预期值”。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Koa框架]]></title>
    <url>%2F2017%2F04%2F19%2FKoa%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Koa是一个类似于Express的Web开发框架，创始人也是同一个人。它的主要特点是，使用了ES6的Generator函数，进行了架构的重新设计。也就是说，Koa的原理和内部结构很像Express，但是语法和内部结构进行了升级。 官方faq有这样一个问题：”为什么koa不是Express 4.0？“，回答是这样的：”Koa与Express有很大差异，整个设计都是不同的，所以如果将Express 3.0按照这种写法升级到4.0，就意味着重写整个程序。所以，我们觉得创造一个新的库，是更合适的做法。“ Koa应用一个Koa应用就是一个对象，包含了一个middleware数组，这个数组由一组Generator函数组成。这些函数负责对HTTP请求进行各种加工，比如生成缓存、指定代理、请求重定向等等。 var koa = require('koa');var app = koa();app.use(function *()&#123; this.body = 'Hello World';&#125;);app.listen(3000); 上面代码中，变量app就是一个Koa应用。它监听3000端口，返回一个内容为Hello World的网页。 app.use方法用于向middleware数组添加Generator函数。 listen方法指定监听端口，并启动当前应用。它实际上等同于下面的代码。 var http = require('http');var koa = require('koa');var app = koa();http.createServer(app.callback()).listen(3000); 中间件Koa的中间件很像Express的中间件，也是对HTTP请求进行处理的函数，但是必须是一个Generator函数。而且，Koa的中间件是一个级联式（Cascading）的结构，也就是说，属于是层层调用，第一个中间件调用第二个中间件，第二个调用第三个，以此类推。上游的中间件必须等到下游的中间件返回结果，才会继续执行，这点很像递归。 中间件通过当前应用的use方法注册。 app.use(function* (next)&#123; var start = new Date; // （1） yield next; // （2） var ms = new Date - start; // （3） console.log('%s %s - %s', this.method, this.url, ms); // （4）&#125;); 上面代码中，app.use方法的参数就是中间件，它是一个Generator函数，最大的特征就是function命令与参数之间，必须有一个星号。Generator函数的参数next，表示下一个中间件。 Generator函数内部使用yield命令，将程序的执行权转交给下一个中间件，即yield next，要等到下一个中间件返回结果，才会继续往下执行。上面代码中，Generator函数体内部，第一行赋值语句首先执行，开始计时，第二行yield语句将执行权交给下一个中间件，当前中间件就暂停执行。等到后面的中间件全部执行完成，执行权就回到原来暂停的地方，继续往下执行，这时才会执行第三行，计算这个过程一共花了多少时间，第四行将这个时间打印出来。 下面是一个两个中间件级联的例子。 app.use(function *() &#123; this.body = "header\n"; yield saveResults.call(this); this.body += "footer\n";&#125;);function *saveResults() &#123; this.body += "Results Saved!\n";&#125; 上面代码中，第一个中间件调用第二个中间件saveResults，它们都向this.body写入内容。最后，this.body的输出如下。 headerResults Saved!footer 只要有一个中间件缺少yield next语句，后面的中间件都不会执行，这一点要引起注意。 app.use(function *(next)&#123; console.log('&gt;&gt; one'); yield next; console.log('&lt;&lt; one');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; two'); this.body = 'two'; console.log('&lt;&lt; two');&#125;);app.use(function *(next)&#123; console.log('&gt;&gt; three'); yield next; console.log('&lt;&lt; three');&#125;); 上面代码中，因为第二个中间件少了yield next语句，第三个中间件并不会执行。 如果想跳过一个中间件，可以直接在该中间件的第一行语句写上return yield next。 app.use(function* (next) &#123; if (skip) return yield next;&#125;) 由于Koa要求中间件唯一的参数就是next，导致如果要传入其他参数，必须另外写一个返回Generator函数的函数。 function logger(format) &#123; return function *(next)&#123; var str = format .replace(':method', this.method) .replace(':url', this.url); console.log(str); yield next; &#125;&#125;app.use(logger(':method :url')); 上面代码中，真正的中间件是logger函数的返回值，而logger函数是可以接受参数的。 多个中间件的合并由于中间件的参数统一为next（意为下一个中间件），因此可以使用.call(this, next)，将多个中间件进行合并。 function *random(next) &#123; if ('/random' == this.path) &#123; this.body = Math.floor(Math.random()*10); &#125; else &#123; yield next; &#125;&#125;;function *backwards(next) &#123; if ('/backwards' == this.path) &#123; this.body = 'sdrawkcab'; &#125; else &#123; yield next; &#125;&#125;function *pi(next) &#123; if ('/pi' == this.path) &#123; this.body = String(Math.PI); &#125; else &#123; yield next; &#125;&#125;function *all(next) &#123; yield random.call(this, backwards.call(this, pi.call(this, next)));&#125;app.use(all); 上面代码中，中间件all内部，就是依次调用random、backwards、pi，后一个中间件就是前一个中间件的参数。 Koa内部使用koa-compose模块，进行同样的操作，下面是它的源码。 function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，middleware是中间件数组。前一个中间件的参数是后一个中间件，依次类推。如果最后一个中间件没有next参数，则传入一个空函数。 路由可以通过this.path属性，判断用户请求的路径，从而起到路由作用。 app.use(function* (next) &#123; if (this.path === '/') &#123; this.body = 'we are at home!'; &#125; else &#123; yield next; &#125;&#125;)// 等同于app.use(function* (next) &#123; if (this.path !== '/') return yield next; this.body = 'we are at home!';&#125;) 下面是多路径的例子。 let koa = require('koa')let app = koa()// normal routeapp.use(function* (next) &#123; if (this.path !== '/') &#123; return yield next &#125; this.body = 'hello world'&#125;);// /404 routeapp.use(function* (next) &#123; if (this.path !== '/404') &#123; return yield next; &#125; this.body = 'page not found'&#125;);// /500 routeapp.use(function* (next) &#123; if (this.path !== '/500') &#123; return yield next; &#125; this.body = 'internal server error'&#125;);app.listen(8080) 上面代码中，每一个中间件负责一个路径，如果路径不符合，就传递给下一个中间件。 复杂的路由需要安装koa-router插件。 var app = require('koa')();var Router = require('koa-router');var myRouter = new Router();myRouter.get('/', function *(next) &#123; this.response.body = 'Hello World!';&#125;);app.use(myRouter.routes());app.listen(3000); 上面代码对根路径设置路由。 Koa-router实例提供一系列动词方法，即一种HTTP动词对应一种方法。典型的动词方法有以下五种。 router.get() router.post() router.put() router.del() router.patch() 这些动词方法可以接受两个参数，第一个是路径模式，第二个是对应的控制器方法（中间件），定义用户请求该路径时服务器行为。 router.get('/', function *(next) &#123; this.body = 'Hello World!';&#125;); 上面代码中，router.get方法的第一个参数是根路径，第二个参数是对应的函数方法。 注意，路径匹配的时候，不会把查询字符串考虑在内。比如，/index?param=xyz匹配路径/index。 有些路径模式比较复杂，Koa-router允许为路径模式起别名。起名时，别名要添加为动词方法的第一个参数，这时动词方法变成接受三个参数。 router.get('user', '/users/:id', function *(next) &#123; // ...&#125;); 上面代码中，路径模式\users\:id的名字就是user。路径的名称，可以用来引用对应的具体路径，比如url方法可以根据路径名称，结合给定的参数，生成具体的路径。 router.url('user', 3);// =&gt; "/users/3"router.url('user', &#123; id: 3 &#125;);// =&gt; "/users/3" 上面代码中，user就是路径模式的名称，对应具体路径/users/:id。url方法的第二个参数3，表示给定id的值是3，因此最后生成的路径是/users/3。 Koa-router允许为路径统一添加前缀。 var router = new Router(&#123; prefix: '/users'&#125;);router.get('/', ...); // 等同于"/users"router.get('/:id', ...); // 等同于"/users/:id" 路径的参数通过this.params属性获取，该属性返回一个对象，所有路径参数都是该对象的成员。 // 访问 /programming/how-to-noderouter.get('/:category/:title', function *(next) &#123; console.log(this.params); // =&gt; &#123; category: 'programming', title: 'how-to-node' &#125;&#125;); param方法可以针对命名参数，设置验证条件。 router .get('/users/:user', function *(next) &#123; this.body = this.user; &#125;) .param('user', function *(id, next) &#123; var users = [ '0号用户', '1号用户', '2号用户']; this.user = users[id]; if (!this.user) return this.status = 404; yield next; &#125;) 上面代码中，如果/users/:user的参数user对应的不是有效用户（比如访问/users/3），param方法注册的中间件会查到，就会返回404错误。 redirect方法会将某个路径的请求，重定向到另一个路径，并返回301状态码。 router.redirect('/login', 'sign-in');// 等同于router.all('/login', function *() &#123; this.redirect('/sign-in'); this.status = 301;&#125;); redirect方法的第一个参数是请求来源，第二个参数是目的地，两者都可以用路径模式的别名代替。 context对象中间件当中的this表示上下文对象context，代表一次HTTP请求和回应，即一次访问/回应的所有信息，都可以从上下文对象获得。context对象封装了request和response对象，并且提供了一些辅助方法。每次HTTP请求，就会创建一个新的context对象。 app.use(function *()&#123; this; // is the Context this.request; // is a koa Request this.response; // is a koa Response&#125;); context对象的很多方法，其实是定义在ctx.request对象或ctx.response对象上面，比如，ctx.type和ctx.length对应于ctx.response.type和ctx.response.length，ctx.path和ctx.method对应于ctx.request.path和ctx.request.method。 context对象的全局属性。 request：指向Request对象 response：指向Response对象 req：指向Node的request对象 res：指向Node的response对象 app：指向App对象 state：用于在中间件传递信息。 this.state.user = yield User.find(id); 上面代码中，user属性存放在this.state对象上面，可以被另一个中间件读取。 context对象的全局方法。 throw()：抛出错误，直接决定了HTTP回应的状态码。 assert()：如果一个表达式为false，则抛出一个错误。 this.throw(403);this.throw('name required', 400);this.throw('something exploded');this.throw(400, 'name required');// 等同于var err = new Error('name required');err.status = 400;throw err; assert方法的例子。 // 格式ctx.assert(value, [msg], [status], [properties])// 例子this.assert(this.user, 401, 'User not found. Please login!'); 以下模块解析POST请求的数据。 co-body https://github.com/koajs/body-parser https://github.com/koajs/body-parsers var parse = require('co-body');// in Koa handlervar body = yield parse(this); 错误处理机制Koa提供内置的错误处理机制，任何中间件抛出的错误都会被捕捉到，引发向客户端返回一个500错误，而不会导致进程停止，因此也就不需要forever这样的模块重启进程。 app.use(function *() &#123; throw new Error();&#125;); 上面代码中，中间件内部抛出一个错误，并不会导致Koa应用挂掉。Koa内置的错误处理机制，会捕捉到这个错误。 当然，也可以额外部署自己的错误处理机制。 app.use(function *() &#123; try &#123; yield saveResults(); &#125; catch (err) &#123; this.throw(400, '数据无效'); &#125;&#125;); 上面代码自行部署了try…catch代码块，一旦产生错误，就用this.throw方法抛出。该方法可以将指定的状态码和错误信息，返回给客户端。 对于未捕获错误，可以设置error事件的监听函数。 app.on('error', function(err)&#123; log.error('server error', err);&#125;); error事件的监听函数还可以接受上下文对象，作为第二个参数。 app.on('error', function(err, ctx)&#123; log.error('server error', err, ctx);&#125;); 如果一个错误没有被捕获，koa会向客户端返回一个500错误“Internal Server Error”。 this.throw方法用于向客户端抛出一个错误。 this.throw(403);this.throw('name required', 400);this.throw(400, 'name required');this.throw('something exploded');this.throw('name required', 400)// 等同于var err = new Error('name required');err.status = 400;throw err; this.throw方法的两个参数，一个是错误码，另一个是报错信息。如果省略状态码，默认是500错误。 this.assert方法用于在中间件之中断言，用法类似于Node的assert模块。 this.assert(this.user, 401, 'User not found. Please login!'); 上面代码中，如果this.user属性不存在，会抛出一个401错误。 由于中间件是层级式调用，所以可以把try { yield next }当成第一个中间件。 app.use(function *(next) &#123; try &#123; yield next; &#125; catch (err) &#123; this.status = err.status || 500; this.body = err.message; this.app.emit('error', err, this); &#125;&#125;);app.use(function *(next) &#123; throw new Error('some error');&#125;) cookiecookie的读取和设置。 this.cookies.get('view');this.cookies.set('view', n); get和set方法都可以接受第三个参数，表示配置参数。其中的signed参数，用于指定cookie是否加密。如果指定加密的话，必须用app.keys指定加密短语。 app.keys = ['secret1', 'secret2'];this.cookies.set('name', '张三', &#123; signed: true &#125;); this.cookie的配置对象的属性如下。 signed：cookie是否加密。 expires：cookie何时过期 path：cookie的路径，默认是“/”。 domain：cookie的域名。 secure：cookie是否只有https请求下才发送。 httpOnly：是否只有服务器可以取到cookie，默认为true。 sessionvar session = require('koa-session');var koa = require('koa');var app = koa();app.keys = ['some secret hurr'];app.use(session(app));app.use(function *()&#123; var n = this.session.views || 0; this.session.views = ++n; this.body = n + ' views';&#125;)app.listen(3000);console.log('listening on port 3000'); Request对象Request对象表示HTTP请求。 （1）this.request.header 返回一个对象，包含所有HTTP请求的头信息。它也可以写成this.request.headers。 （2）this.request.method 返回HTTP请求的方法，该属性可读写。 （3）this.request.length 返回HTTP请求的Content-Length属性，取不到值，则返回undefined。 （4）this.request.path 返回HTTP请求的路径，该属性可读写。 （5）this.request.href 返回HTTP请求的完整路径，包括协议、端口和url。 this.request.href// http://example.com/foo/bar?q=1 （6）this.request.querystring 返回HTTP请求的查询字符串，不含问号。该属性可读写。 （7）this.request.search 返回HTTP请求的查询字符串，含问号。该属性可读写。 （8）this.request.host 返回HTTP请求的主机（含端口号）。 （9）this.request.hostname 返回HTTP的主机名（不含端口号）。 （10）this.request.type 返回HTTP请求的Content-Type属性。 var ct = this.request.type;// "image/png" （11）this.request.charset 返回HTTP请求的字符集。 this.request.charset// "utf-8" （12）this.request.query 返回一个对象，包含了HTTP请求的查询字符串。如果没有查询字符串，则返回一个空对象。该属性可读写。 比如，查询字符串color=blue&amp;size=small，会得到以下的对象。 &#123; color: 'blue', size: 'small'&#125; （13）this.request.fresh 返回一个布尔值，表示缓存是否代表了最新内容。通常与If-None-Match、ETag、If-Modified-Since、Last-Modified等缓存头，配合使用。 this.response.set('ETag', '123');// 检查客户端请求的内容是否有变化if (this.request.fresh) &#123; this.response.status = 304; return;&#125;// 否则就表示客户端的内容陈旧了，// 需要取出新内容this.response.body = yield db.find('something'); （14）this.request.stale 返回this.request.fresh的相反值。 （15）this.request.protocol 返回HTTP请求的协议，https或者http。 （16）this.request.secure 返回一个布尔值，表示当前协议是否为https。 （17）this.request.ip 返回发出HTTP请求的IP地址。 （18）this.request.subdomains 返回一个数组，表示HTTP请求的子域名。该属性必须与app.subdomainOffset属性搭配使用。app.subdomainOffset属性默认为2，则域名“tobi.ferrets.example.com”返回[“ferrets”, “tobi”]，如果app.subdomainOffset设为3，则返回[“tobi”]。 （19）this.request.is(types…) 返回指定的类型字符串，表示HTTP请求的Content-Type属性是否为指定类型。 // Content-Type为 text/html; charset=utf-8this.request.is('html'); // 'html'this.request.is('text/html'); // 'text/html'this.request.is('text/*', 'text/html'); // 'text/html'// Content-Type为 application/jsonthis.request.is('json', 'urlencoded'); // 'json'this.request.is('application/json'); // 'application/json'this.request.is('html', 'application/*'); // 'application/json' 如果不满足条件，返回false；如果HTTP请求不含数据，则返回undefined。 this.is('html'); // false 它可以用于过滤HTTP请求，比如只允许请求下载图片。 if (this.is('image/*')) &#123; // process&#125; else &#123; this.throw(415, 'images only!');&#125; （20）this.request.accepts(types) 检查HTTP请求的Accept属性是否可接受，如果可接受，则返回指定的媒体类型，否则返回false。 // Accept: text/htmlthis.request.accepts('html');// "html"// Accept: text/*, application/jsonthis.request.accepts('html');// "html"this.request.accepts('text/html');// "text/html"this.request.accepts('json', 'text');// =&gt; "json"this.request.accepts('application/json');// =&gt; "application/json"// Accept: text/*, application/jsonthis.request.accepts('image/png');this.request.accepts('png');// false// Accept: text/*;q=.5, application/jsonthis.request.accepts(['html', 'json']);this.request.accepts('html', 'json');// "json"// No Accept headerthis.request.accepts('html', 'json');// "html"this.request.accepts('json', 'html');// =&gt; "json" 如果accepts方法没有参数，则返回所有支持的类型（text/html,application/xhtml+xml,image/webp,application/xml,/）。 如果accepts方法的参数有多个参数，则返回最佳匹配。如果都不匹配则返回false，并向客户端抛出一个406”Not Acceptable“错误。 如果HTTP请求没有Accept字段，那么accepts方法返回它的第一个参数。 accepts方法可以根据不同Accept字段，向客户端返回不同的字段。 switch (this.request.accepts('json', 'html', 'text')) &#123; case 'json': break; case 'html': break; case 'text': break; default: this.throw(406, 'json, html, or text only');&#125; （21）this.request.acceptsEncodings(encodings) 该方法根据HTTP请求的Accept-Encoding字段，返回最佳匹配，如果没有合适的匹配，则返回false。 // Accept-Encoding: gzipthis.request.acceptsEncodings('gzip', 'deflate', 'identity');// "gzip"this.request.acceptsEncodings(['gzip', 'deflate', 'identity']);// "gzip" 注意，acceptEncodings方法的参数必须包括identity（意为不编码）。 如果HTTP请求没有Accept-Encoding字段，acceptEncodings方法返回所有可以提供的编码方法。 // Accept-Encoding: gzip, deflatethis.request.acceptsEncodings();// ["gzip", "deflate", "identity"] 如果都不匹配，acceptsEncodings方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （22）this.request.acceptsCharsets(charsets) 该方法根据HTTP请求的Accept-Charset字段，返回最佳匹配，如果没有合适的匹配，则返回false。 // Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets('utf-8', 'utf-7');// =&gt; "utf-8"this.request.acceptsCharsets(['utf-7', 'utf-8']);// =&gt; "utf-8" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 // Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5this.request.acceptsCharsets();// ["utf-8", "utf-7", "iso-8859-1"] 如果都不匹配，acceptsCharsets方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （23）this.request.acceptsLanguages(langs) 该方法根据HTTP请求的Accept-Language字段，返回最佳匹配，如果没有合适的匹配，则返回false。 // Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages('es', 'en');// "es"this.request.acceptsLanguages(['en', 'es']);// "es" 如果acceptsCharsets方法没有参数，则返回所有可接受的匹配。 // Accept-Language: en;q=0.8, es, ptthis.request.acceptsLanguages();// ["es", "pt", "en"] 如果都不匹配，acceptsLanguages方法返回false，并向客户端抛出一个406“Not Acceptable”错误。 （24）this.request.socket 返回HTTP请求的socket。 （25）this.request.get(field) 返回HTTP请求指定的字段。 Response对象Response对象表示HTTP回应。 （1）this.response.header 返回HTTP回应的头信息。 （2）this.response.socket 返回HTTP回应的socket。 （3）this.response.status 返回HTTP回应的状态码。默认情况下，该属性没有值。该属性可读写，设置时等于一个整数。 （4）this.response.message 返回HTTP回应的状态信息。该属性与this.response.message是配对的。该属性可读写。 （5）this.response.length 返回HTTP回应的Content-Length字段。该属性可读写，如果没有设置它的值，koa会自动从this.request.body推断。 （6）this.response.body 返回HTTP回应的信息体。该属性可读写，它的值可能有以下几种类型。 字符串：Content-Type字段默认为text/html或text/plain，字符集默认为utf-8，Content-Length字段同时设定。 二进制Buffer：Content-Type字段默认为application/octet-stream，Content-Length字段同时设定。 Stream：Content-Type字段默认为application/octet-stream。 JSON对象：Content-Type字段默认为application/json。 null（表示没有信息体） 如果this.response.status没设置，Koa会自动将其设为200或204。 （7）this.response.get(field) 返回HTTP回应的指定字段。 var etag = this.get('ETag'); 注意，get方法的参数是区分大小写的。 （8）this.response.set() 设置HTTP回应的指定字段。 this.set('Cache-Control', 'no-cache'); set方法也可以接受一个对象作为参数，同时为多个字段指定值。 this.set(&#123; 'Etag': '1234', 'Last-Modified': date&#125;); （9）this.response.remove(field) 移除HTTP回应的指定字段。 （10）this.response.type 返回HTTP回应的Content-Type字段，不包括“charset”参数的部分。 var ct = this.reponse.type;// "image/png" 该属性是可写的。 this.reponse.type = 'text/plain; charset=utf-8';this.reponse.type = 'image/png';this.reponse.type = '.png';this.reponse.type = 'png'; 设置type属性的时候，如果没有提供charset参数，Koa会判断是否自动设置。如果this.response.type设为html，charset默认设为utf-8；但如果this.response.type设为text/html，就不会提供charset的默认值。 （10）this.response.is(types…) 该方法类似于this.request.is()，用于检查HTTP回应的类型是否为支持的类型。 它可以在中间件中起到处理不同格式内容的作用。 var minify = require('html-minifier');app.use(function *minifyHTML(next)&#123; yield next; if (!this.response.is('html')) return; var body = this.response.body; if (!body || body.pipe) return; if (Buffer.isBuffer(body)) body = body.toString(); this.response.body = minify(body);&#125;); 上面代码是一个中间件，如果输出的内容类型为HTML，就会进行最小化处理。 （11）this.response.redirect(url, [alt]) 该方法执行302跳转到指定网址。 this.redirect('back');this.redirect('back', '/index.html');this.redirect('/login');this.redirect('http://google.com'); 如果redirect方法的第一个参数是back，将重定向到HTTP请求的Referrer字段指定的网址，如果没有该字段，则重定向到第二个参数或“/”网址。 如果想修改302状态码，或者修改body文字，可以采用下面的写法。 this.status = 301;this.redirect('/cart');this.body = 'Redirecting to shopping cart'; （12）this.response.attachment([filename]) 该方法将HTTP回应的Content-Disposition字段，设为“attachment”，提示浏览器下载指定文件。 （13）this.response.headerSent 该方法返回一个布尔值，检查是否HTTP回应已经发出。 （14）this.response.lastModified 该属性以Date对象的形式，返回HTTP回应的Last-Modified字段（如果该字段存在）。该属性可写。 this.response.lastModified = new Date(); （15）this.response.etag 该属性设置HTTP回应的ETag字段。 this.response.etag = crypto.createHash('md5').update(this.body).digest('hex'); 注意，不能用该属性读取ETag字段。 （16）this.response.vary(field) 该方法将参数添加到HTTP回应的Vary字段。 CSRF攻击CSRF攻击是指用户的session被劫持，用来冒充用户的攻击。 koa-csrf插件用来防止CSRF攻击。原理是在session之中写入一个秘密的token，用户每次使用POST方法提交数据的时候，必须含有这个token，否则就会抛出错误。 var koa = require('koa');var session = require('koa-session');var csrf = require('koa-csrf');var route = require('koa-route');var app = module.exports = koa();app.keys = ['session key', 'csrf example'];app.use(session(app));app.use(csrf());app.use(route.get('/token', token));app.use(route.post('/post', post));function* token () &#123; this.body = this.csrf;&#125;function* post() &#123; this.body = &#123;ok: true&#125;;&#125;app.listen(3000); POST请求含有token，可以是以下几种方式之一，koa-csrf插件就能获得token。 表单的_csrf字段 查询字符串的_csrf字段 HTTP请求头信息的x-csrf-token字段 HTTP请求头信息的x-xsrf-token字段 数据压缩koa-compress模块可以实现数据压缩。 app.use(require('koa-compress')())app.use(function* () &#123; this.type = 'text/plain' this.body = fs.createReadStream('filename.txt')&#125;) 源码解读每一个网站就是一个app，它由lib/application定义。 function Application() &#123; if (!(this instanceof Application)) return new Application; this.env = process.env.NODE_ENV || 'development'; this.subdomainOffset = 2; this.middleware = []; this.context = Object.create(context); this.request = Object.create(request); this.response = Object.create(response);&#125;var app = Application.prototype;exports = module.exports = Application; app.use()用于注册中间件，即将Generator函数放入中间件数组。 app.use = function(fn)&#123; if (!this.experimental) &#123; // es7 async functions are allowed assert(fn &amp;&amp; 'GeneratorFunction' == fn.constructor.name, 'app.use() requires a generator function'); &#125; debug('use %s', fn._name || fn.name || '-'); this.middleware.push(fn); return this;&#125;; app.listen()就是http.createServer(app.callback()).listen(...)的缩写。 app.listen = function()&#123; debug('listen'); var server = http.createServer(this.callback()); return server.listen.apply(server, arguments);&#125;;app.callback = function()&#123; var mw = [respond].concat(this.middleware); var fn = this.experimental ? compose_es7(mw) : co.wrap(compose(mw)); var self = this; if (!this.listeners('error').length) this.on('error', this.onerror); return function(req, res)&#123; res.statusCode = 404; var ctx = self.createContext(req, res); onFinished(res, ctx.onerror); fn.call(ctx).catch(ctx.onerror); &#125;&#125;; 上面代码中，app.callback()会返回一个函数，用来处理HTTP请求。它的第一行mw = [respond].concat(this.middleware)，表示将respond函数（这也是一个Generator函数）放入this.middleware，现在mw就变成了[respond, S1, S2, S3]。 compose(mw)将中间件数组转为一个层层调用的Generator函数。 function compose(middleware)&#123; return function *(next)&#123; if (!next) next = noop(); var i = middleware.length; while (i--) &#123; next = middleware[i].call(this, next); &#125; yield *next; &#125;&#125;function *noop()&#123;&#125; 上面代码中，下一个generator函数总是上一个Generator函数的参数，从而保证了层层调用。 var fn = co.wrap(gen)则是将Generator函数包装成一个自动执行的函数，并且返回一个Promise。 //co packageco.wrap = function (fn) &#123; return function () &#123; return co.call(this, fn.apply(this, arguments)); &#125;;&#125;; 由于co.wrap(compose(mw))执行后，返回的是一个Promise，所以可以对其使用catch方法指定捕捉错误的回调函数fn.call(ctx).catch(ctx.onerror)。 将所有的上下文变量都放进context对象。 app.createContext = function(req, res)&#123; var context = Object.create(this.context); var request = context.request = Object.create(this.request); var response = context.response = Object.create(this.response); context.app = request.app = response.app = this; context.req = request.req = response.req = req; context.res = request.res = response.res = res; request.ctx = response.ctx = context; request.response = response; response.request = request; context.onerror = context.onerror.bind(context); context.originalUrl = request.originalUrl = req.url; context.cookies = new Cookies(req, res, this.keys); context.accept = request.accept = accepts(req); context.state = &#123;&#125;; return context;&#125;; 真正处理HTTP请求的是下面这个Generator函数。 function *respond(next) &#123; yield *next; // allow bypassing koa if (false === this.respond) return; var res = this.res; if (res.headersSent || !this.writable) return; var body = this.body; var code = this.status; // ignore body if (statuses.empty[code]) &#123; // strip headers this.body = null; return res.end(); &#125; if ('HEAD' == this.method) &#123; if (isJSON(body)) this.length = Buffer.byteLength(JSON.stringify(body)); return res.end(); &#125; // status body if (null == body) &#123; this.type = 'text'; body = this.message || String(code); this.length = Buffer.byteLength(body); return res.end(body); &#125; // responses if (Buffer.isBuffer(body)) return res.end(body); if ('string' == typeof body) return res.end(body); if (body instanceof Stream) return body.pipe(res); // body: json body = JSON.stringify(body); this.length = Buffer.byteLength(body); res.end(body);&#125;]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm模块管理器]]></title>
    <url>%2F2017%2F04%2F19%2Fnpm%E6%A8%A1%E5%9D%97%E7%AE%A1%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介npm有两层含义。一层含义是Node的开放式模块登记和管理系统，网址为npmjs.org。另一层含义是Node默认的模块管理器，是一个命令行下的软件，用来安装和管理Node模块。 npm不需要单独安装。在安装Node的时候，会连带一起安装npm。但是，Node附带的npm可能不是最新版本，最好用下面的命令，更新到最新版本。 $ npm install npm@latest -g 上面的命令中，@latest表示最新版本，-g表示全局安装。所以，命令的主干是npm install npm，也就是使用npm安装自己。之所以可以这样，是因为npm本身与Node的其他模块没有区别。 然后，运行下面的命令，查看各种信息。 # 查看 npm 命令列表$ npm help# 查看各个命令的简单用法$ npm -l# 查看 npm 的版本$ npm -v# 查看 npm 的配置$ npm config list -l npm initnpm init用来初始化生成一个新的package.json文件。它会向用户提问一系列问题，如果你觉得不用修改默认配置，一路回车就可以了。 如果使用了-f（代表force）、-y（代表yes），则跳过提问阶段，直接生成一个新的package.json文件。 $ npm init -y npm setnpm set用来设置环境变量。 $ npm set init-author-name 'Your name'$ npm set init-author-email 'Your email'$ npm set init-author-url 'http://yourdomain.com'$ npm set init-license 'MIT' 上面命令等于为npm init设置了默认值，以后执行npm init的时候，package.json的作者姓名、邮件、主页、许可证字段就会自动写入预设的值。这些信息会存放在用户主目录的~/.npmrc文件，使得用户不用每个项目都输入。如果某个项目有不同的设置，可以针对该项目运行npm config。 $ npm set save-exact true 上面命令设置加入模块时，package.json将记录模块的确切版本，而不是一个可选的版本范围。 npm config$ npm config set prefix $dir 上面的命令将指定的$dir目录，设为模块的全局安装目录。如果当前有这个目录的写权限，那么运行npm install的时候，就不再需要sudo命令授权了。 $ npm config set save-prefix ~ 上面的命令使得npm install --save和npm install --save-dev安装新模块时，允许的版本范围从克拉符号（^）改成波浪号（~），即从允许小版本升级，变成只允许补丁包的升级。 $ npm config set init.author.name $name$ npm config set init.author.email $email 上面命令指定使用npm init时，生成的package.json文件的字段默认值。 npm infonpm info命令可以查看每个模块的具体信息。比如，查看underscore模块的信息。 $ npm info underscore&#123; name: 'underscore', description: 'JavaScript\'s functional programming helper library.', 'dist-tags': &#123; latest: '1.5.2', stable: '1.5.2' &#125;, repository: &#123; type: 'git', url: 'git://github.com/jashkenas/underscore.git' &#125;, homepage: 'http://underscorejs.org', main: 'underscore.js', version: '1.5.2', devDependencies: &#123; phantomjs: '1.9.0-1' &#125;, licenses: &#123; type: 'MIT', url: 'https://raw.github.com/jashkenas/underscore/master/LICENSE' &#125;, files: [ 'underscore.js', 'underscore-min.js', 'LICENSE' ], readmeFilename: 'README.md'&#125; 上面命令返回一个JavaScript对象，包含了underscore模块的详细信息。这个对象的每个成员，都可以直接从info命令查询。 $ npm info underscore descriptionJavaScript's functional programming helper library.$ npm info underscore homepagehttp://underscorejs.org$ npm info underscore version1.5.2 npm searchnpm search命令用于搜索npm仓库，它后面可以跟字符串，也可以跟正则表达式。 $ npm search &lt;搜索词&gt; 下面是一个例子。 $ npm search node-gyp// NAME DESCRIPTION// autogypi Autogypi handles dependencies for node-gyp projects.// grunt-node-gyp Run node-gyp commands from Grunt.// gyp-io Temporary solution to let node-gyp run `rebuild` under…// ... npm listnpm list命令以树型结构列出当前项目安装的所有模块，以及它们依赖的模块。 $ npm list 加上global参数，会列出全局安装的模块。 $ npm list -global npm list命令也可以列出单个模块。 $ npm list underscore npm install基本用法Node模块采用npm install命令安装。 每个模块可以“全局安装”，也可以“本地安装”。“全局安装”指的是将一个模块安装到系统目录中，各个项目都可以调用。一般来说，全局安装只适用于工具模块，比如eslint和gulp。“本地安装”指的是将一个模块下载到当前项目的node_modules子目录，然后只有在项目目录之中，才能调用这个模块。 # 本地安装$ npm install &lt;package name&gt;# 全局安装$ sudo npm install -global &lt;package name&gt;$ sudo npm install -g &lt;package name&gt; npm install也支持直接输入Github代码库地址。 $ npm install git://github.com/package/path.git$ npm install git://github.com/package/path.git#0.1.0 安装之前，npm install会先检查，node_modules目录之中是否已经存在指定模块。如果存在，就不再重新安装了，即使远程仓库已经有了一个新版本，也是如此。 如果你希望，一个模块不管是否安装过，npm 都要强制重新安装，可以使用-f或--force参数。 $ npm install &lt;packageName&gt; --force 如果你希望，所有模块都要强制重新安装，那就删除node_modules目录，重新执行npm install。 $ rm -rf node_modules$ npm install 安装不同版本install命令总是安装模块的最新版本，如果要安装模块的特定版本，可以在模块名后面加上@和版本号。 $ npm install sax@latest$ npm install sax@0.1.1$ npm install sax@"&gt;=0.1.0 &lt;0.2.0" 如果使用--save-exact参数，会在package.json文件指定安装模块的确切版本。 $ npm install readable-stream --save --save-exact install命令可以使用不同参数，指定所安装的模块属于哪一种性质的依赖关系，即出现在packages.json文件的哪一项中。 –save：模块名将被添加到dependencies，可以简化为参数-S。 –save-dev: 模块名将被添加到devDependencies，可以简化为参数-D。 $ npm install sax --save$ npm install node-tap --save-dev# 或者$ npm install sax -S$ npm install node-tap -D 如果要安装beta版本的模块，需要使用下面的命令。 # 安装最新的beta版$ npm install &lt;module-name&gt;@beta (latest beta)# 安装指定的beta版$ npm install &lt;module-name&gt;@1.3.1-beta.3 npm install默认会安装dependencies字段和devDependencies字段中的所有模块，如果使用--production参数，可以只安装dependencies字段的模块。 $ npm install --production# 或者$ NODE_ENV=production npm install 一旦安装了某个模块，就可以在代码中用require命令加载这个模块。 var backbone = require('backbone')console.log(backbone.VERSION) 避免系统权限默认情况下，Npm全局模块都安装在系统目录（比如/usr/local/lib/），普通用户没有写入权限，需要用到sudo命令。这不是很方便，我们可以在没有root权限的情况下，安装全局模块。 首先，在主目录下新建配置文件.npmrc，然后在该文件中将prefix变量定义到主目录下面。 prefix = /home/yourUsername/npm 然后在主目录下新建npm子目录。 $ mkdir ~/npm 此后，全局安装的模块都会安装在这个子目录中，npm也会到~/npm/bin目录去寻找命令。 最后，将这个路径在.bash_profile文件（或.bashrc文件）中加入PATH变量。 export PATH=~/npm/bin:$PATH npm update，npm uninstallnpm update命令可以更新本地安装的模块。 # 升级当前项目的指定模块$ npm update [package name]# 升级全局安装的模块$ npm update -global [package name] 它会先到远程仓库查询最新版本，然后查询本地版本。如果本地版本不存在，或者远程版本较新，就会安装。 使用-S或--save参数，可以在安装的时候更新package.json里面模块的版本号。 // 更新之前的package.jsondependencies: &#123; dep1: "^1.1.1"&#125;// 更新之后的package.jsondependencies: &#123; dep1: "^1.2.2"&#125; 注意，从npm v2.6.1 开始，npm update只更新顶层模块，而不更新依赖的依赖，以前版本是递归更新的。如果想取到老版本的效果，要使用下面的命令。 $ npm --depth 9999 update npm uninstall命令，卸载已安装的模块。 $ npm uninstall [package name]# 卸载全局模块$ npm uninstall [package name] -global npm runnpm不仅可以用于模块管理，还可以用于执行脚本。package.json文件有一个scripts字段，可以用于指定脚本命令，供npm直接调用。 &#123; "name": "myproject", "devDependencies": &#123; "jshint": "latest", "browserify": "latest", "mocha": "latest" &#125;, "scripts": &#123; "lint": "jshint **.js", "test": "mocha test/" &#125;&#125; 上面代码中，scripts字段指定了两项命令lint和test。命令行输入npm run-script lint或者npm run lint，就会执行jshint **.js，输入npm run-script test或者npm run test，就会执行mocha test/。npm run是npm run-script的缩写，一般都使用前者，但是后者可以更好地反应这个命令的本质。 npm run命令会自动在环境变量$PATH添加node_modules/.bin目录，所以scripts字段里面调用命令时不用加上路径，这就避免了全局安装NPM模块。 npm run如果不加任何参数，直接运行，会列出package.json里面所有可以执行的脚本命令。 npm内置了两个命令简写，npm test等同于执行npm run test，npm start等同于执行npm run start。 npm run会创建一个Shell，执行指定的命令，并临时将node_modules/.bin加入PATH变量，这意味着本地模块可以直接运行。 举例来说，你执行ESLint的安装命令。 $ npm i eslint --save-dev 运行上面的命令以后，会产生两个结果。首先，ESLint被安装到当前目录的node_modules子目录；其次，node_modules/.bin目录会生成一个符号链接node_modules/.bin/eslint，指向ESLint模块的可执行脚本。 然后，你就可以在package.json的script属性里面，不带路径的引用eslint这个脚本。 &#123; "name": "Test Project", "devDependencies": &#123; "eslint": "^1.10.3" &#125;, "scripts": &#123; "lint": "eslint ." &#125;&#125; 等到运行npm run lint的时候，它会自动执行./node_modules/.bin/eslint .。 如果直接运行npm run不给出任何参数，就会列出scripts属性下所有命令。 $ npm runAvailable scripts in the user-service package: lint jshint **.js test mocha test/ 下面是另一个package.json文件的例子。 "scripts": &#123; "watch": "watchify client/main.js -o public/app.js -v", "build": "browserify client/main.js -o public/app.js", "start": "npm run watch &amp; nodemon server.js", "test": "node test/all.js"&#125;, 上面代码在scripts项，定义了四个别名，每个别名都有对应的脚本命令。 $ npm run watch$ npm run build$ npm run start$ npm run test 其中，start和test属于特殊命令，可以省略run。 $ npm start$ npm test 如果希望一个操作的输出，是另一个操作的输入，可以借用Linux系统的管道命令，将两个操作连在一起。 "build-js": "browserify browser/main.js | uglifyjs -mc &gt; static/bundle.js" 但是，更方便的写法是引用其他npm run命令。 "build": "npm run build-js &amp;&amp; npm run build-css" 上面的写法是先运行npm run build-js，然后再运行npm run build-css，两个命令中间用&amp;&amp;连接。如果希望两个命令同时平行执行，它们中间可以用&amp;连接。 下面是一个流操作的例子。 "devDependencies": &#123; "autoprefixer": "latest", "cssmin": "latest"&#125;,"scripts": &#123; "build:css": "autoprefixer -b 'last 2 versions' &lt; assets/styles/main.css | cssmin &gt; dist/main.css"&#125; 写在scripts属性中的命令，也可以在node_modules/.bin目录中直接写成bash脚本。下面是一个bash脚本。 #!/bin/bashcd site/mainbrowserify browser/main.js | uglifyjs -mc &gt; static/bundle.js 假定上面的脚本文件名为build.sh，并且权限为可执行，就可以在scripts属性中引用该文件。 "build-js": "bin/build.sh" 参数npm run命令还可以添加参数。 "scripts": &#123; "test": "mocha test/"&#125; 上面代码指定npm test，实际运行mocha test/。如果要通过npm test命令，将参数传到mocha，则参数之前要加上两个连词线。 $ npm run test -- anothertest.js# 等同于$ mocha test/ anothertest.js 上面命令表示，mocha要运行所有test子目录的测试脚本，以及另外一个测试脚本anothertest.js。 npm run本身有一个参数-s，表示关闭npm本身的输出，只输出脚本产生的结果。 // 输出npm命令头$ npm run test// 不输出npm命令头$ npm run -s test scripts脚本命令最佳实践scripts字段的脚本命令，有一些最佳实践，可以方便开发。首先，安装npm-run-all模块。 $ npm install npm-run-all --save-dev 这个模块用于运行多个scripts脚本命令。 # 继发执行$ npm-run-all build:html build:js# 等同于$ npm run build:html &amp;&amp; npm run build:js# 并行执行$ npm-run-all --parallel watch:html watch:js# 等同于$ npm run watch:html &amp; npm run watch:js# 混合执行$ npm-run-all clean lint --parallel watch:html watch:js# 等同于$ npm-run-all clean lint$ npm-run-all --parallel watch:html watch:js# 通配符$ npm-run-all --parallel watch:* （1）start脚本命令 start脚本命令，用于启动应用程序。 "start": "npm-run-all --parallel dev serve" 上面命令并行执行dev脚本命令和serve脚本命令，等同于下面的形式。 $ npm run dev &amp; npm run serve 如果start脚本没有配置，npm start命令默认执行下面的脚本，前提是模块的根目录存在一个server.js文件。 $ node server.js （2）dev脚本命令 dev脚本命令，规定开发阶段所要做的处理，比如构建网页资源。 "dev": "npm-run-all dev:*" 上面命令用于继发执行所有dev的子命令。 "predev:sass": "node-sass --source-map src/css/hoodie.css.map --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令将sass文件编译为css文件，并生成source map文件。 "dev:sass": "node-sass --source-map src/css/hoodie.css.map --watch --output-style nested src/sass/base.scss src/css/hoodie.css" 上面命令会监视sass文件的变动，只要有变动，就自动将其编译为css文件。 "dev:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers \"&gt; 5%\" --output src/css/hoodie.css src/css/hoodie.css" 上面命令为css文件加上浏览器前缀，限制条件是只考虑市场份额大于5%的浏览器。 （3）serve脚本命令 serve脚本命令用于启动服务。 "serve": "live-server dist/ --port=9090" 上面命令启动服务，用的是live-server模块，将服务启动在9090端口，展示dist子目录。 live-server模块有三个功能。 启动一个HTTP服务器，展示指定目录的index.html文件，通过该文件加载各种网络资源，这是file://协议做不到的。 添加自动刷新功能。只要指定目录之中，文件有任何变化，它就会刷新页面。 npm run serve命令执行以后，自动打开浏览器。、 以前，上面三个功能需要三个模块来完成：http-server、live-reload和opener，现在只要live-server一个模块就够了。 （4）test脚本命令 test脚本命令用于执行测试。 "test": "npm-run-all test:*","test:lint": "sass-lint --verbose --config .sass-lint.yml src/sass/*" 上面命令规定，执行测试时，运行lint脚本，检查脚本之中的语法错误。 （5）prod脚本命令 prod脚本命令，规定进入生产环境时需要做的处理。 "prod": "npm-run-all prod:*","prod:sass": "node-sass --output-style compressed src/sass/base.scss src/css/prod/hoodie.min.css","prod:autoprefix": "postcss --use autoprefixer --autoprefixer.browsers "&gt; 5%" --output src/css/prod/hoodie.min.css src/css/prod/hoodie.min.css" 上面命令将sass文件转为css文件，并加上浏览器前缀。 （6）help脚本命令 help脚本命令用于展示帮助信息。 "help": "markdown-chalk --input DEVELOPMENT.md" 上面命令之中，markdown-chalk模块用于将指定的markdown文件，转为彩色文本显示在终端之中。 （7）docs脚本命令 docs脚本命令用于生成文档。 "docs": "kss-node --source src/sass --homepage ../../styleguide.md" 上面命令使用kss-node模块，提供源码的注释生成markdown格式的文档。 pre- 和 post- 脚本npm run为每条命令提供了pre-和post-两个钩子（hook）。以npm run lint为例，执行这条命令之前，npm会先查看有没有定义prelint和postlint两个钩子，如果有的话，就会先执行npm run prelint，然后执行npm run lint，最后执行npm run postlint。 &#123; "name": "myproject", "devDependencies": &#123; "eslint": "latest" "karma": "latest" &#125;, "scripts": &#123; "lint": "eslint --cache --ext .js --ext .jsx src", "test": "karma start --log-leve=error karma.config.js --single-run=true", "pretest": "npm run lint", "posttest": "echo 'Finished running tests'" &#125;&#125; 上面代码是一个package.json文件的例子。如果执行npm test，会按下面的顺序执行相应的命令。 pretest test posttest 如果执行过程出错，就不会执行排在后面的脚本，即如果prelint脚本执行出错，就不会接着执行lint和postlint脚本。 下面是一个例子。 &#123; "test": "karma start", "test:lint": "eslint . --ext .js --ext .jsx", "pretest": "npm run test:lint"&#125; 上面代码中，在运行npm run test之前，会自动检查代码，即运行npm run test:lint命令。 下面是一些常见的pre-和post-脚本。 prepublish：发布一个模块前执行。 postpublish：发布一个模块后执行。 preinstall：用户执行npm install命令时，先执行该脚本。 postinstall：用户执行npm install命令时，安装结束后执行该脚本，通常用于将下载的源码编译成用户需要的格式，比如有些模块需要在用户机器上跟本地的C++模块一起编译。 preuninstall：卸载一个模块前执行。 postuninstall：卸载一个模块后执行。 preversion：更改模块版本前执行。 postversion：更改模块版本后执行。 pretest：运行npm test命令前执行。 posttest：运行npm test命令后执行。 prestop：运行npm stop命令前执行。 poststop：运行npm stop命令后执行。 prestart：运行npm start命令前执行。 poststart：运行npm start命令后执行。 prerestart：运行npm restart命令前执行。 postrestart：运行npm restart命令后执行。 对于最后一个npm restart命令，如果没有设置restart脚本，prerestart和postrestart会依次执行stop和start脚本。 另外，不能在pre脚本之前再加pre，即prepretest脚本不起作用。 注意，即使Npm可以自动运行pre和post脚本，也可以手动执行它们。 $ npm run prepublish 下面是post install的例子。 &#123; "postinstall": "node lib/post_install.js"&#125; 上面的这个命令，主要用于处理从Git仓库拉下来的源码。比如，有些源码是用TypeScript写的，可能需要转换一下。 下面是publish钩子的一个例子。 &#123; "dist:modules": "babel ./src --out-dir ./dist-modules", "gh-pages": "webpack", "gh-pages:deploy": "gh-pages -d gh-pages", "prepublish": "npm run dist:modules", "postpublish": "npm run gh-pages &amp;&amp; npm run gh-pages:deploy"&#125; 上面命令在运行npm run publish时，会先执行Babel编译，然后调用Webpack构建，最后发到Github Pages上面。 以上都是npm相关操作的钩子，如果安装某些模块，还能支持Git相关的钩子。下面以husky模块为例。 $ npm install husky --save-dev 安装以后，就能在package.json添加precommit、prepush等钩子。 &#123; "scripts": &#123; "lint": "eslint yourJsFiles.js", "precommit": "npm run test &amp;&amp; npm run lint", "prepush": "npm run test &amp;&amp; npm run lint", "...": "..." &#125;&#125; 类似作用的模块还有pre-commit、precommit-hook等。 内部变量scripts字段可以使用一些内部变量，主要是package.json的各种字段。 比如，package.json的内容是{&quot;name&quot;:&quot;foo&quot;, &quot;version&quot;:&quot;1.2.5&quot;}，那么变量npm_package_name的值是foo，变量npm_package_version的值是1.2.5。 &#123; "scripts":&#123; "bundle": "mkdir -p build/$npm_package_version/" &#125;&#125; 运行npm run bundle以后，将会生成build/1.2.5/子目录。 config字段也可以用于设置内部字段。 "name": "fooproject","config": &#123; "reporter": "xunit"&#125;,"scripts": &#123; "test": "mocha test/ --reporter $npm_package_config_reporter"&#125; 上面代码中，变量npm_package_config_reporter对应的就是reporter。 通配符npm的通配符的规则如下。 * 匹配0个或多个字符 ? 匹配1个字符 [...] 匹配某个范围的字符。如果该范围的第一个字符是!或^，则匹配不在该范围的字符。 !(pattern|pattern|pattern) 匹配任何不符合给定的模式 ?(pattern|pattern|pattern) 匹配0个或1个给定的模式 +(pattern|pattern|pattern) 匹配1个或多个给定的模式 *(a|b|c) 匹配0个或多个给定的模式 @(pattern|pat*|pat?erN) 只匹配给定模式之一 ** 如果出现在路径部分，表示0个或多个子目录。 npm link开发NPM模块的时候，有时我们会希望，边开发边试用，比如本地调试的时候，require(&#39;myModule&#39;)会自动加载本机开发中的模块。Node规定，使用一个模块时，需要将其安装到全局的或项目的node_modules目录之中。对于开发中的模块，解决方法就是在全局的node_modules目录之中，生成一个符号链接，指向模块的本地目录。 npm link就能起到这个作用，会自动建立这个符号链接。 请设想这样一个场景，你开发了一个模块myModule，目录为src/myModule，你自己的项目myProject要用到这个模块，项目目录为src/myProject。首先，在模块目录（src/myModule）下运行npm link命令。 src/myModule$ npm link 上面的命令会在NPM的全局模块目录内，生成一个符号链接文件，该文件的名字就是package.json文件中指定的模块名。 /path/to/global/node_modules/myModule -&gt; src/myModule 这个时候，已经可以全局调用myModule模块了。但是，如果我们要让这个模块安装在项目内，还要进行下面的步骤。 切换到项目目录，再次运行npm link命令，并指定模块名。 src/myProject$ npm link myModule 上面命令等同于生成了本地模块的符号链接。 src/myProject/node_modules/myModule -&gt; /path/to/global/node_modules/myModule 然后，就可以在你的项目中，加载该模块了。 var myModule = require('myModule'); 这样一来，myModule的任何变化，都可以直接反映在myProject项目之中。但是，这样也出现了风险，任何在myProject目录中对myModule的修改，都会反映到模块的源码中。 如果你的项目不再需要该模块，可以在项目目录内使用npm unlink命令，删除符号链接。 src/myProject$ npm unlink myModule npm binnpm bin命令显示相对于当前目录的，Node模块的可执行脚本所在的目录（即.bin目录）。 # 项目根目录下执行$ npm bin./node_modules/.bin npm addusernpm adduser用于在npmjs.com注册一个用户。 $ npm adduserUsername: YOUR_USER_NAMEPassword: YOUR_PASSWORDEmail: YOUR_EMAIL@domain.com npm publishnpm publish用于将当前模块发布到npmjs.com。执行之前，需要向npmjs.com申请用户名。 $ npm adduser 如果已经注册过，就使用下面的命令登录。 $ npm login 登录以后，就可以使用npm publish命令发布。 $ npm publish 如果当前模块是一个beta版，比如1.3.1-beta.3，那么发布的时候需要使用tag参数，将其发布到指定标签，默认的发布标签是latest。 $ npm publish --tag beta 如果发布私有模块，模块初始化的时候，需要加上scope参数。只有npm的付费用户才能发布私有模块。 $ npm init --scope=&lt;yourscope&gt; 如果你的模块是用ES6写的，那么发布的时候，最好转成ES5。首先，需要安装Babel。 $ npm install --save-dev babel-cli@6 babel-preset-es2015@6 然后，在package.json里面写入build脚本。 "scripts": &#123; "build": "babel source --presets babel-preset-es2015 --out-dir distribution", "prepublish": "npm run build"&#125; 运行上面的脚本，会将source目录里面的ES6源码文件，转为distribution目录里面的ES5源码文件。然后，在项目根目录下面创建两个文件.npmignore和.gitignore，分别写入以下内容。 // .npmignoresource// .gitignorenode_modulesdistribution npm deprecate如果想废弃某个版本的模块，可以使用npm deprecate命令。 $ npm deprecate my-thing@"&lt; 0.2.3" "critical bug fixed in v0.2.3" 运行上面的命令以后，小于0.2.3版本的模块的package.json都会写入一行警告，用户安装这些版本时，这行警告就会在命令行显示。 npm owner模块的维护者可以发布新版本。npm owner命令用于管理模块的维护者。 # 列出指定模块的维护者$ npm owner ls &lt;package name&gt;# 新增维护者$ npm owner add &lt;user&gt; &lt;package name&gt;# 删除维护者$ npm owner rm &lt;user&gt; &lt;package name&gt; 其他命令npm home，npm reponpm home命令可以打开一个模块的主页，npm repo命令则是打开一个模块的代码仓库。 $ npm home $package$ npm repo $package 这两个命令不需要模块先安装。 npm outdatednpm outdated命令检查当前项目所依赖的模块，是否已经有新版本。 $ npm outdated 它会输出当前版本（current version）、应当安装的版本（wanted version）和最新发布的版本（latest version）。 npm prunenpm prune检查当前项目的node_modules目录中，是否有package.json里面没有提到的模块，然后将所有这些模块输出在命令行。 $ npm prune npm shrinkwrapnpm shrinkwrap的作用是锁定当前项目的以来模块的版本。 $ npm shrinkwrap 运行该命令后，会在当前项目的根目录下生成一个npm-shrinkwrap.json文件，内容是node_modules目录下所有已经安装模块的版本。 下次运行npm install命令时，npm发现当前目录下有npm-shrinkwrap.json文件，就会只安装里面提到的模块，且版本也会保持一致。]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Events模块]]></title>
    <url>%2F2017%2F04%2F19%2FEvents%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[回调函数模式让 Node 可以处理异步操作。但是，为了适应回调函数，异步操作只能有两个状态：开始和结束。对于那些多状态的异步操作（状态1，状态2，状态3，……），回调函数就会无法处理，你不得不将异步操作拆开，分成多个阶段。每个阶段结束时，调用下一个回调函数。 为了解决这个问题，Node 提供 Event Emitter 接口。通过事件，解决多状态异步操作的响应问题。 概述Event Emitter 是一个接口，可以在任何对象上部署。这个接口由events模块提供。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter(); events模块的EventEmitter是一个构造函数，可以用来生成事件发生器的实例emitter。 然后，事件发生器的实例方法on用来监听事件，实例方法emit用来发出事件。 emitter.on('someEvent', function () &#123; console.log('event has occured');&#125;);function f() &#123; console.log('start'); emitter.emit('someEvent'); console.log('end');&#125;f()// start// event has occured// end 上面代码中，EventEmitter对象实例emitter就是消息中心。通过on方法为someEvent事件指定回调函数，通过emit方法触发someEvent事件。 上面代码还表明，EventEmitter对象的事件触发和监听是同步的，即只有事件的回调函数执行以后，函数f才会继续执行。 Event Emitter 接口的部署Event Emitter 接口可以部署在任意对象上，使得这些对象也能订阅和发布消息。 var EventEmitter = require('events').EventEmitter;function Dog(name) &#123; this.name = name;&#125;Dog.prototype.__proto__ = EventEmitter.prototype;// 另一种写法// Dog.prototype = Object.create(EventEmitter.prototype);var simon = new Dog('simon');simon.on('bark', function () &#123; console.log(this.name + ' barked');&#125;);setInterval(function () &#123; simon.emit('bark');&#125;, 500); 上面代码新建了一个构造函数Dog，然后让其继承EventEmitter，因此Dog就拥有了EventEmitter的接口。最后，为Dog的实例指定bark事件的监听函数，再使用EventEmitter的emit方法，触发bark事件。 Node 内置模块util的inherits方法，提供了另一种继承 Event Emitter 接口的方法。 var util = require('util');var EventEmitter = require('events').EventEmitter;var Radio = function (station) &#123; var self = this; setTimeout(function() &#123; self.emit('open', station); &#125;, 0); setTimeout(function() &#123; self.emit('close', station); &#125;, 5000); this.on('newListener', function(listener) &#123; console.log('Event Listener: ' + listener); &#125;);&#125;;util.inherits(Radio, EventEmitter);module.exports = Radio; 上面代码中，Radio是一个构造函数，它的实例继承了EventEmitter接口。下面是使用这个模块的例子。 var Radio = require('./radio.js');var station = &#123; freq: '80.16', name: 'Rock N Roll Radio',&#125;;var radio = new Radio(station);radio.on('open', function(station) &#123; console.log('"%s" FM %s 打开', station.name, station.freq); console.log('♬ ♫♬');&#125;);radio.on('close', function(station) &#123; console.log('"%s" FM %s 关闭', station.name, station.freq);&#125;); Event Emitter 的实例方法Event Emitter 的实例方法如下。 emitter.on(name, f) 对事件name指定监听函数f emitter.addListener(name, f) addListener是on方法的别名 emitter.once(name, f) 与on方法类似，但是监听函数f是一次性的，使用后自动移除 emitter.listeners(name) 返回一个数组，成员是事件name所有监听函数 emitter.removeListener(name, f) 移除事件name的监听函数f emitter.removeAllListeners(name) 移除事件name的所有监听函数 emit()EventEmitter实例对象的emit方法，用来触发事件。它的第一个参数是事件名称，其余参数都会依次传入回调函数。 var EventEmitter = require('events').EventEmitter;var myEmitter = new EventEmitter();var connection = function (id) &#123; console.log('client id: ' + id);&#125;;myEmitter.on('connection', connection);myEmitter.emit('connection', 6);// client id: 6 once()该方法类似于on方法，但是回调函数只触发一次。 var EventEmitter = require('events').EventEmitter;var myEmitter = new EventEmitter;myEmitter.once('message', function(msg)&#123; console.log('message: ' + msg);&#125;);myEmitter.emit('message', 'this is the first message');myEmitter.emit('message', 'this is the second message');myEmitter.emit('message', 'welcome to nodejs'); 上面代码触发了三次message事件，但是回调函数只会在第一次调用时运行。 下面代码指定，一旦服务器连通，只调用一次的回调函数。 server.once('connection', function (stream) &#123; console.log('Ah, we have our first user!');&#125;); 该方法返回一个EventEmitter对象，因此可以链式加载监听函数。 removeListener()该方法用于移除回调函数。它接受两个参数，第一个是事件名称，第二个是回调函数名称。这就是说，不能用于移除匿名函数。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter;emitter.on('message', console.log);setInterval(function()&#123; emitter.emit('message', 'foo bar');&#125;, 300);setTimeout(function()&#123; emitter.removeListener('message', console.log);&#125;, 1000); 上面代码每300毫秒触发一次message事件，直到1000毫秒后取消监听。 另一个例子是使用removeListener方法模拟once方法。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter;function onlyOnce () &#123; console.log("You'll never see this again"); emitter.removeListener("firstConnection", onlyOnce);&#125;emitter.on("firstConnection", onlyOnce); setMaxListeners()Node默认允许同一个事件最多可以指定10个回调函数。 emitter.on('someEvent', function () &#123; console.log('event 1'); &#125;);emitter.on('someEvent', function () &#123; console.log('event 2'); &#125;);emitter.on('someEvent', function () &#123; console.log('event 3'); &#125;); 超过10个回调函数，会发出一个警告。这个门槛值可以通过setMaxListeners方法改变。 emitter.setMaxListeners(20); removeAllListeners()该方法用于移除某个事件的所有回调函数。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter;// some code hereemitter.removeAllListeners("firstConnection"); 如果不带参数，则表示移除所有事件的所有回调函数。 emitter.removeAllListeners(); listeners()listeners方法接受一个事件名称作为参数，返回该事件所有回调函数组成的数组。 var EventEmitter = require('events').EventEmitter;var ee = new EventEmitter;function onlyOnce () &#123; console.log(ee.listeners("firstConnection")); ee.removeListener("firstConnection", onlyOnce); console.log(ee.listeners("firstConnection"));&#125;ee.on("firstConnection", onlyOnce)ee.emit("firstConnection");ee.emit("firstConnection");// [ [Function: onlyOnce] ]// [] 上面代码显示两次回调函数组成的数组，第一次只有一个回调函数onlyOnce，第二次是一个空数组，因为removeListener方法取消了回调函数。 错误捕获事件处理过程中抛出的错误，可以使用try...catch捕获。 var EventEmitter = require('events').EventEmitter;var emitter = new EventEmitter();emitter.on('beep', function () &#123; console.log('beep');&#125;);emitter.on('beep', function () &#123; throw Error('oops!');&#125;);emitter.on('beep', function () &#123; console.log('beep again');&#125;);console.log('before emit');try &#123; emitter.emit('beep');&#125; catch(err) &#123; console.error('caught while emitting:', err.message);&#125;console.log('after emit'); 上面的代码，beep一共绑定了三个监听函数。其中，第二个监听函数会抛出错误。执行上面的代码，会得到下面的结果。 before emitbeepcaught while emitting: oops!after emit 可以看到，第二个监听函数抛出的错误被try...catch代码块捕获了。一旦被捕获，该事件后面的监听函数都不会再执行了。 如果不使用try...catch，可以让进程监听uncaughtException事件。 process.on('uncaughtException', function (err) &#123; console.error('uncaught exception:', err.stack || err); // 关闭资源 closeEverything(function(err) &#123; if (err) console.error('Error while closing everything:', err.stack || err); // 退出进程 process.exit(1); &#125;);&#125;); 事件类型Events模块默认支持两个事件。 newListener事件：添加新的回调函数时触发。 removeListener事件：移除回调时触发。 ee.on("newListener", function (evtName) &#123; console.log("New Listener: " + evtName);&#125;);ee.on("removeListener", function (evtName) &#123; console.log("Removed Listener: " + evtName);&#125;);function foo() &#123;&#125;ee.on("save-user", foo);ee.removeListener("save-user", foo);// New Listener: removeListener// New Listener: save-user// Removed Listener: save-user 上面代码会触发两次newListener事件，以及一次removeListener事件。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http模块]]></title>
    <url>%2F2017%2F04%2F19%2FHttp%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[http.STATUS_CODEShttp.STATUS_CODES是一个对象，属性名都是状态码，属性值则是该状态码的简短解释。 require('http').STATUS_CODES['301']// "Moved Permanently" 基本用法处理GET请求http模块主要用于搭建HTTP服务。使用Node搭建HTTP服务器非常简单。 var http = require('http');http.createServer(function (request, response)&#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.write("Hello World"); response.end();&#125;).listen(8080, '127.0.0.1');console.log('Server running on port 8080.');// 另一种写法function onRequest(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;http.createServer(onRequest).listen(process.env.PORT); 上面代码第一行var http = require(&quot;http&quot;)，表示加载http模块。然后，调用http模块的createServer方法，创造一个服务器实例。 ceateServer方法接受一个函数作为参数，该函数的request参数是一个对象，表示客户端的HTTP请求；response参数也是一个对象，表示服务器端的HTTP回应。response.writeHead方法用来写入HTTP回应的头信息；response.end方法用来写入HTTP回应的具体内容，以及回应完成后关闭本次对话。最后的listen(8080)表示启动服务器实例，监听本机的8080端口。 将上面这几行代码保存成文件app.js，然后执行该脚本，服务器就开始运行了。 $ node app.js 这时命令行窗口将显示一行提示“Server running at port 8080.”。打开浏览器，访问http://localhost:8080，网页显示“Hello world!”。 上面的例子是收到请求后生成网页，也可以事前写好网页，存在文件中，然后利用fs模块读取网页文件，将其返回。 var http = require('http');var fs = require('fs');http.createServer(function (request, response)&#123; fs.readFile('data.txt', function readData(err, data) &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.end(data); &#125;); // 或者 fs.createReadStream(`$&#123;__dirname&#125;/index.html`).pipe(response);&#125;).listen(8080, '127.0.0.1');console.log('Server running on port 8080.'); 下面的修改则是根据不同网址的请求，显示不同的内容，已经相当于做出一个网站的雏形了。 var http = require('http');http.createServer(function(req, res) &#123; // 主页 if (req.url == "/") &#123; res.writeHead(200, &#123; "Content-Type": "text/html" &#125;); res.end("Welcome to the homepage!"); &#125; // About页面 else if (req.url == "/about") &#123; res.writeHead(200, &#123; "Content-Type": "text/html" &#125;); res.end("Welcome to the about page!"); &#125; // 404错误 else &#123; res.writeHead(404, &#123; "Content-Type": "text/plain" &#125;); res.end("404 error! File not found."); &#125;&#125;).listen(8080, "localhost"); request 对象createServer方法的回调函数的第一个参数是一个request对象，拥有以下属性。 url：发出请求的网址。 method：HTTP请求的方法。 headers：HTTP请求的所有HTTP头信息。 下面的例子是获取请求的路径名。 var url = require('url');var pathname = url.parse(request.url).pathname; setEncoding()方法用于设置请求的编码。 request.setEncoding("utf8"); addListener()方法用于为请求添加监听事件的回调函数。 var querystring = require('querystring');var postData = '';request.addListener('data', function (postDataChunk) &#123; postData += postDataChunk;&#125;);request.addListener('end', function () &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.write("You've sent the text: " + querystring.parse(postData).text); response.end();&#125;); 处理异步操作遇到异步操作时，会先处理后面的请求，等到当前请求有了结果以后，再返回结果。 var exec = require("child_process").exec;exec('ls -lah', function (error, stdout, stderr) &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); response.write(stdout); response.end();&#125;); 处理POST请求当客户端采用POST方法发送数据时，服务器端可以对data和end两个事件，设立监听函数。 var http = require('http');http.createServer(function (req, res) &#123; var content = ""; req.on('data', function (chunk) &#123; content += chunk; &#125;); req.on('end', function () &#123; res.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); res.write("You've sent: " + content); res.end(); &#125;);&#125;).listen(8080); data事件会在数据接收过程中，每收到一段数据就触发一次，接收到的数据被传入回调函数。end事件则是在所有数据接收完成后触发。 对上面代码稍加修改，就可以做出文件上传的功能。 "use strict";var http = require('http');var fs = require('fs');var destinationFile, fileSize, uploadedBytes;http.createServer(function (request, response) &#123; response.writeHead(200); destinationFile = fs.createWriteStream("destination.md"); request.pipe(destinationFile); fileSize = request.headers['content-length']; uploadedBytes = 0; request.on('data', function (d) &#123; uploadedBytes += d.length; var p = (uploadedBytes / fileSize) * 100; response.write("Uploading " + parseInt(p, 0) + " %\n"); &#125;); request.on('end', function () &#123; response.end("File Upload Complete"); &#125;);&#125;).listen(3030, function () &#123; console.log("server started");&#125;); 发出请求get()get方法用于发出get请求。 function getTestPersonaLoginCredentials(callback) &#123; return http.get(&#123; host: 'personatestuser.org', path: '/email' &#125;, function(response) &#123; var body = ''; response.on('data', function(d) &#123; body += d; &#125;); response.on('end', function() &#123; var parsed = JSON.parse(body); callback(&#123; email: parsed.email, password: parsed.pass &#125;); &#125;); &#125;);&#125;, request()request方法用于发出HTTP请求，它的使用格式如下。 http.request(options[, callback]) request方法的options参数，可以是一个对象，也可以是一个字符串。如果是字符串，就表示这是一个URL，Node内部就会自动调用url.parse()，处理这个参数。 options对象可以设置如下属性。 host：HTTP请求所发往的域名或者IP地址，默认是localhost。 hostname：该属性会被url.parse()解析，优先级高于host。 port：远程服务器的端口，默认是80。 localAddress：本地网络接口。 socketPath：Unix网络套接字，格式为host:port或者socketPath。 method：指定HTTP请求的方法，格式为字符串，默认为GET。 path：指定HTTP请求的路径，默认为根路径（/）。可以在这个属性里面，指定查询字符串，比如/index.html?page=12。如果这个属性里面包含非法字符（比如空格），就会抛出一个错误。 headers：一个对象，包含了HTTP请求的头信息。 auth：一个代表HTTP基本认证的字符串user:password。 agent：控制缓存行为，如果HTTP请求使用了agent，则HTTP请求默认为Connection: keep-alive，它的可能值如下： undefined（默认）：对当前host和port，使用全局Agent。 Agent：一个对象，会传入agent属性。 false：不缓存连接，默认HTTP请求为Connection: close。 keepAlive：一个布尔值，表示是否保留socket供未来其他请求使用，默认等于false。 keepAliveMsecs：一个整数，当使用KeepAlive的时候，设置多久发送一个TCP KeepAlive包，使得连接不要被关闭。默认等于1000，只有keepAlive设为true的时候，该设置才有意义。 request方法的callback参数是可选的，在response事件发生时触发，而且只触发一次。 http.request()返回一个http.ClientRequest类的实例。它是一个可写数据流，如果你想通过POST方法发送一个文件，可以将文件写入这个ClientRequest对象。 下面是发送POST请求的一个例子。 var postData = querystring.stringify(&#123; 'msg' : 'Hello World!'&#125;);var options = &#123; hostname: 'www.google.com', port: 80, path: '/upload', method: 'POST', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Content-Length': postData.length &#125;&#125;;var req = http.request(options, function(res) &#123; console.log('STATUS: ' + res.statusCode); console.log('HEADERS: ' + JSON.stringify(res.headers)); res.setEncoding('utf8'); res.on('data', function (chunk) &#123; console.log('BODY: ' + chunk); &#125;);&#125;);req.on('error', function(e) &#123; console.log('problem with request: ' + e.message);&#125;);// write data to request bodyreq.write(postData);req.end(); 注意，上面代码中，req.end()必须被调用，即使没有在请求体内写入任何数据，也必须调用。因为这表示已经完成HTTP请求。 发送过程的任何错误（DNS错误、TCP错误、HTTP解析错误），都会在request对象上触发error事件。 Server()Server方法用于新建一个服务器实例。 var http = require('http');var fs = require('fs');var server = new http.Server();server.listen(8000);server.on('request', function (request, response) &#123; // 解析请求的URL var url = require('url').parse(request.url); if (url.pathname === '/test/1') &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain; charset=UTF-8'&#125;); response.write('Hello'); response.end(); &#125; else if (url.pathname === '/test/2') &#123; response.writeHead(200, &#123;'Content-Type': 'text/plain; charset=UTF-8'&#125;); response.write(request.method + ' ' + request.url + ' HTTP/' + request.httpVersion + '\r\n'); for (var h in request.headers) &#123; response.write(h + ': ' + request.headers[h] + '\r\n'); &#125; response.write('\r\n'); request.on('data', function(chunk) &#123; response.write(chunk); &#125;); request.on('end', function(chunk) &#123; response.end(); &#125;); &#125; else &#123; var filename = url.pathname.substring(1); var type; switch(filename.substring(filename.lastIndexOf('.') + 1)) &#123; case 'html': case 'htm': type = 'text/html; charset=UTF-8'; break; case 'js': type = 'application/javascript; charset=UTF-8'; break; case 'css': type = 'text/css; charset=UTF-8'; break; case 'txt' : type = 'text/plain; charset=UTF-8'; break; case 'manifest': type = 'text/cache-manifest; charset=UTF-8'; break; default: type = 'application/octet-stream'; break; &#125; fs.readFile(filename, function (err, content) &#123; if (err) &#123; response.writeHead(404, &#123; 'Content-Type': 'text/plain; charset=UTF-8'&#125;); response.write(err.message); response.end(); &#125; else &#123; response.writeHead(200, &#123;'Content-Type': type&#125;); response.write(content); response.end(); &#125; &#125;); &#125;&#125;); listen方法用于启动服务器，它可以接受多种参数。 var server = new http.Server();// 端口server.listen(8000);// 端口，主机server.listen(8000, 'localhost');// 对象server.listen(&#123; port: 8000, host: 'localhost',&#125;) 以上三种写法都是合法的。 搭建HTTPs服务器搭建HTTPs服务器需要有SSL证书。对于向公众提供服务的网站，SSL证书需要向证书颁发机构购买；对于自用的网站，可以自制。 自制SSL证书需要OpenSSL，具体命令如下。 $ openssl genrsa -out key.pem$ openssl req -new -key key.pem -out csr.pem$ openssl x509 -req -days 9999 -in csr.pem -signkey key.pem -out cert.pem$ rm csr.pem 上面的命令生成两个文件：ert.pem（证书文件）和 key.pem（私钥文件）。有了这两个文件，就可以运行HTTPs服务器了。 Node内置Https支持。 var server = https.createServer(&#123; key: privateKey, cert: certificate, ca: certificateAuthorityCertificate&#125;, app); Node.js提供一个https模块，专门用于处理加密访问。 var https = require('https');var fs = require('fs');var options = &#123; key: fs.readFileSync('key.pem'), cert: fs.readFileSync('cert.pem')&#125;;var a = https.createServer(options, function (req, res) &#123; res.writeHead(200); res.end("hello world\n");&#125;).listen(8000); 上面代码显示，HTTPs服务器与HTTP服务器的最大区别，就是createServer方法多了一个options参数。运行以后，就可以测试是否能够正常访问。 curl -k https://localhost:8000 模块属性（1）HTTP请求的属性 headers：HTTP请求的头信息。 url：请求的路径。 模块方法（1）http模块的方法 createServer(callback)：创造服务器实例。 （2）服务器实例的方法 listen(port)：启动服务器监听指定端口。 （3）HTTP回应的方法 setHeader(key, value)：指定HTTP头信息。 write(str)：指定HTTP回应的内容。 end()：发送HTTP回应。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cluster模块]]></title>
    <url>%2F2017%2F04%2F19%2FCluster%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[概述基本用法Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。 cluster模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。worker之间采用进程间通信交换消息，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个worker进程之间的负载。运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP连接分配给指定的worker进程。 var cluster = require('cluster');var os = require('os');if (cluster.isMaster)&#123; for (var i = 0, n = os.cpus().length; i &lt; n; i += 1)&#123; cluster.fork(); &#125;&#125; else &#123; http.createServer(function(req, res) &#123; res.writeHead(200); res.end("hello world\n"); &#125;).listen(8000);&#125; 上面代码先判断当前进程是否为主进程（cluster.isMaster），如果是的，就按照CPU的核数，新建若干个worker进程；如果不是，说明当前进程是worker进程，则在该进程启动一个服务器程序。 上面这段代码有一个缺点，就是一旦work进程挂了，主进程无法知道。为了解决这个问题，可以在主进程部署online事件和exit事件的监听函数。 var cluster = require('cluster');if(cluster.isMaster) &#123; var numWorkers = require('os').cpus().length; console.log('Master cluster setting up ' + numWorkers + ' workers...'); for(var i = 0; i &lt; numWorkers; i++) &#123; cluster.fork(); &#125; cluster.on('online', function(worker) &#123; console.log('Worker ' + worker.process.pid + ' is online'); &#125;); cluster.on('exit', function(worker, code, signal) &#123; console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal); console.log('Starting a new worker'); cluster.fork(); &#125;);&#125; 上面代码中，主进程一旦监听到worker进程的exit事件，就会重启一个worker进程。worker进程一旦启动成功，可以正常运行了，就会发出online事件。 worker对象worker对象是cluster.fork()的返回值，代表一个worker进程。 它的属性和方法如下。 （1）worker.id worker.id返回当前worker的独一无二的进程编号。这个编号也是cluster.workers中指向当前进程的索引值。 （2）worker.process 所有的worker进程都是用child_process.fork()生成的。child_process.fork()返回的对象，就被保存在worker.process之中。通过这个属性，可以获取worker所在的进程对象。 （3）worker.send() 该方法用于在主进程中，向子进程发送信息。 if (cluster.isMaster) &#123; var worker = cluster.fork(); worker.send('hi there');&#125; else if (cluster.isWorker) &#123; process.on('message', function(msg) &#123; process.send(msg); &#125;);&#125; 上面代码的作用是，worker进程对主进程发出的每个消息，都做回声。 在worker进程中，要向主进程发送消息，使用process.send(message)；要监听主进程发出的消息，使用下面的代码。 process.on('message', function(message) &#123; console.log(message);&#125;); 发出的消息可以字符串，也可以是JSON对象。下面是一个发送JSON对象的例子。 worker.send(&#123; type: 'task 1', from: 'master', data: &#123; // the data that you want to transfer &#125;&#125;); cluster.workers对象该对象只有主进程才有，包含了所有worker进程。每个成员的键值就是一个worker进程对象，键名就是该worker进程的worker.id属性。 function eachWorker(callback) &#123; for (var id in cluster.workers) &#123; callback(cluster.workers[id]); &#125;&#125;eachWorker(function(worker) &#123; worker.send('big announcement to all workers');&#125;); 上面代码用来遍历所有worker进程。 当前socket的data事件，也可以用id属性识别worker进程。 socket.on('data', function(id) &#123; var worker = cluster.workers[id];&#125;); cluster模块的属性与方法isMaster，isWorkerisMaster属性返回一个布尔值，表示当前进程是否为主进程。这个属性由process.env.NODE_UNIQUE_ID决定，如果process.env.NODE_UNIQUE_ID为未定义，就表示该进程是主进程。 isWorker属性返回一个布尔值，表示当前进程是否为work进程。它与isMaster属性的值正好相反。 fork()fork方法用于新建一个worker进程，上下文都复制主进程。只有主进程才能调用这个方法。 该方法返回一个worker对象。 kill()kill方法用于终止worker进程。它可以接受一个参数，表示系统信号。 如果当前是主进程，就会终止与worker.process的联络，然后将系统信号法发向worker进程。如果当前是worker进程，就会终止与主进程的通信，然后退出，返回0。 在以前的版本中，该方法也叫做 worker.destroy() 。 listening事件worker进程调用listening方法以后，“listening”事件就传向该进程的服务器，然后传向主进程。 该事件的回调函数接受两个参数，一个是当前worker对象，另一个是地址对象，包含网址、端口、地址类型（IPv4、IPv6、Unix socket、UDP）等信息。这对于那些服务多个网址的Node应用程序非常有用。 cluster.on('listening', function (worker, address) &#123; console.log("A worker is now connected to " + address.address + ":" + address.port);&#125;); 不中断地重启Node服务思路重启服务需要关闭后再启动，利用cluster模块，可以做到先启动一个worker进程，再把原有的所有work进程关闭。这样就能实现不中断地重启Node服务。 首先，主进程向worker进程发出重启信号。 workers[wid].send(&#123;type: 'shutdown', from: 'master'&#125;); worker进程监听message事件，一旦发现内容是shutdown，就退出。 process.on('message', function(message) &#123; if(message.type === 'shutdown') &#123; process.exit(0); &#125;&#125;); 下面是一个关闭所有worker进程的函数。 function restartWorkers() &#123; var wid, workerIds = []; for(wid in cluster.workers) &#123; workerIds.push(wid); &#125; workerIds.forEach(function(wid) &#123; cluster.workers[wid].send(&#123; text: 'shutdown', from: 'master' &#125;); setTimeout(function() &#123; if(cluster.workers[wid]) &#123; cluster.workers[wid].kill('SIGKILL'); &#125; &#125;, 5000); &#125;);&#125;; 实例下面是一个完整的实例，先是主进程的代码master.js。 var cluster = require('cluster');console.log('started master with ' + process.pid);// 新建一个worker进程cluster.fork();process.on('SIGHUP', function () &#123; console.log('Reloading...'); var new_worker = cluster.fork(); new_worker.once('listening', function () &#123; // 关闭所有其他worker进程 for(var id in cluster.workers) &#123; if (id === new_worker.id.toString()) continue; cluster.workers[id].kill('SIGTERM'); &#125; &#125;);&#125;); 上面代码中，主进程监听SIGHUP事件，如果发生该事件就关闭其他所有worker进程。之所以是SIGHUP事件，是因为nginx服务器监听到这个信号，会创造一个新的worker进程，重新加载配置文件。另外，关闭worker进程时，主进程发送SIGTERM信号，这是因为Node允许多个worker进程监听同一个端口。 下面是worker进程的代码server.js。 var cluster = require('cluster');if (cluster.isMaster) &#123; require('./master'); return;&#125;var express = require('express');var http = require('http');var app = express();app.get('/', function (req, res) &#123; res.send('ha fsdgfds gfds gfd!');&#125;);http.createServer(app).listen(8080, function () &#123; console.log('http://localhost:8080');&#125;); 使用时代码如下。 $ node server.jsstarted master with 10538http://localhost:8080 然后，向主进程连续发出两次SIGHUP信号。 $ kill -SIGHUP 10538$ kill -SIGHUP 10538 主进程会连续两次新建一个worker进程，然后关闭所有其他worker进程，显示如下。 Reloading...http://localhost:8080Reloading...http://localhost:8080 最后，向主进程发出SIGTERM信号，关闭主进程。 $ kill 10538 PM2模块PM2模块是cluster模块的一个包装层。它的作用是尽量将cluster模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。 // app.jsvar http = require('http');http.createServer(function(req, res) &#123; res.writeHead(200); res.end("hello world");&#125;).listen(8080); 上面代码是标准的Node架设Web服务器的方式，然后用PM2从命令行启动这段代码。 $ pm2 start app.js -i 4 上面代码的i参数告诉PM2，这段代码应该在cluster_mode启动，且新建worker进程的数量是4个。如果i参数的值是0，那么当前机器有几个CPU内核，PM2就会启动几个worker进程。 如果一个worker进程由于某种原因挂掉了，会立刻重启该worker进程。 # 重启所有worker进程$ pm2 reload all 每个worker进程都有一个id，可以用下面的命令查看单个worker进程的详情。 $ pm2 show &lt;worker id&gt; 正确情况下，PM2采用fork模式新建worker进程，即主进程fork自身，产生一个worker进程。pm2 reload命令则会用spawn方式启动，即一个接一个启动worker进程，一个新的worker启动成功，再杀死一个旧的worker进程。采用这种方式，重新部署新版本时，服务器就不会中断服务。 $ pm2 reload &lt;脚本文件名&gt; 关闭worker进程的时候，可以部署下面的代码，让worker进程监听shutdown消息。一旦收到这个消息，进行完毕收尾清理工作再关闭。 process.on('message', function(msg) &#123; if (msg === 'shutdown') &#123; close_all_connections(); delete_logs(); server.close(); process.exit(0); &#125;&#125;);]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB的应用]]></title>
    <url>%2F2017%2F04%2F19%2FMongoDB%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MongoDB是目前最流行的noSQL数据库之一，它是专为Node开发的。 MongoDB的一条记录叫做文档（document），它是一个包含多个字段的数据结构，很类似于JSON格式。 下面是文档的一个例子。 &#123; "_id" : ObjectId("54c955492b7c8eb21818bd09"), "address" : &#123; "street" : "2 Avenue", "zipcode" : "10075", "building" : "1480", "coord" : [ -73.9557413, 40.7720266 ] &#125;, "borough" : "Manhattan", "cuisine" : "Italian", "grades" : [ &#123; "date" : ISODate("2014-10-01T00:00:00Z"), "grade" : "A", "score" : 11 &#125;, &#123; "date" : ISODate("2014-01-16T00:00:00Z"), "grade" : "B", "score" : 17 &#125; ], "name" : "Vella", "restaurant_id" : "41704620"&#125; 文档储存在集合（collection）之中，类似于关系型数据库的表。在一个集合之中，记录的格式并不需要相同。每个集合之中的每个文档，必须有一个_id字段作为主键。 基本用法安装完MongoDB数据库以后，使用mongod命令启动MongoDB。 $ mongod# 或者指定配置文件$ mongod --config /etc/mongodb.conf 然后，安装Node驱动库。 $ npm install mongodb 脚本里引用MongoDB客户端的代码如下。 var MongoClient = require('mongodb').MongoClient;var assert = require('assert');var url = 'mongodb://localhost:27017/test';MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); console.log('Connected correctly to server.'); db.close();&#125;); 插入数据var insertDocument = function(db, callback) &#123; db.collection('restaurants').insertOne( &#123; "address" : &#123; "street" : "2 Avenue", "zipcode" : "10075", "building" : "1480", "coord" : [ -73.9557413, 40.7720266 ] &#125;, "borough" : "Manhattan", "cuisine" : "Italian", "grades" : [ &#123; "date" : new Date("2014-10-01T00:00:00Z"), "grade" : "A", "score" : 11 &#125;, &#123; "date" : new Date("2014-01-16T00:00:00Z"), "grade" : "B", "score" : 17 &#125; ], "name" : "Vella", "restaurant_id" : "41704620" &#125;, function(err, result) &#123; assert.equal(err, null); console.log("Inserted a document into the restaurants collection."); callback(); &#125;);&#125;; 执行这个操作。 MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); insertDocument(db, function() &#123; db.close(); &#125;);&#125;); 查询操作取出一个collection里面的所有文档。 var findRestaurants = function(db, callback) &#123; var cursor =db.collection('restaurants').find( ); cursor.each(function(err, doc) &#123; assert.equal(err, null); if (doc !== null) &#123; console.dir(doc); &#125; else &#123; callback(); &#125; &#125;);&#125;; 执行上面的函数。 MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); findRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 查询语句的写法如下。 &#123; &lt;field1&gt;: &lt;value1&gt;, &lt;field2&gt;: &lt;value2&gt;, ... &#125; 下面是一个指定查询条件的例子。 var findRestaurants = function(db, callback) &#123; var cursor =db.collection('restaurants').find( &#123; "borough": "Manhattan" &#125; ); cursor.each(function(err, doc) &#123; assert.equal(err, null); if (doc != null) &#123; console.dir(doc); &#125; else &#123; callback(); &#125; &#125;);&#125;; 执行上面的函数。 MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); findRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 查询的时候，可以指定嵌套属性。 var cursor =db.collection('restaurants').find( &#123; "address.zipcode": "10075" &#125; ); 查询条件还可以指定数组的一个值。 var cursor =db.collection('restaurants').find( &#123; "grades.grade": "B" &#125; ); 查询条件可以指定运算符。 // 大于var cursor =db.collection('restaurants').find( &#123; "grades.score": &#123; $gt: 30 &#125; &#125; );// 小于var cursor =db.collection('restaurants').find( &#123; "grades.score": &#123; $lt: 10 &#125; &#125; ); 查询条件可以指定逻辑运算符。 // AND 运算var cursor =db.collection('restaurants').find( &#123; "cuisine": "Italian", "address.zipcode": "10075" &#125;);// OR 运算var cursor =db.collection('restaurants').find( &#123; $or: [ &#123; "cuisine": "Italian" &#125;, &#123; "address.zipcode": "10075" &#125; ] &#125;); sort方法用于排序，1代表升序，-1代表降序。 var cursor =db.collection('restaurants').find().sort( &#123; "borough": 1, "address.zipcode": 1 &#125; ); 更新数据更新指定文档。updateOne方法返回更新的文档的数目。 var updateRestaurants = function(db, callback) &#123; db.collection('restaurants').updateOne( &#123; "name" : "Juni" &#125;, &#123; $set: &#123; "cuisine": "American (New)" &#125;, $currentDate: &#123; "lastModified": true &#125; &#125;, function(err, results) &#123; console.log(results); callback(); &#125;);&#125;;MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); updateRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 更新嵌入的字段。 db.collection('restaurants').updateOne( &#123; "restaurant_id" : "41156888" &#125;, &#123; $set: &#123; "address.street": "East 31st Street" &#125; &#125;, function(err, results) &#123; console.log(results); callback(); &#125;); 更新多个字段。 db.collection('restaurants').updateMany( &#123; "address.zipcode": "10016", cuisine: "Other" &#125;, &#123; $set: &#123; cuisine: "Category To Be Determined" &#125;, $currentDate: &#123; "lastModified": true &#125; &#125; , function(err, results) &#123; console.log(results); callback();&#125;); 替换整个文档，除了_id字段。 db.collection('restaurants').replaceOne( &#123; "restaurant_id" : "41704620" &#125;, &#123; "name" : "Vella 2", "address" : &#123; "coord" : [ -73.9557413, 40.7720266 ], "building" : "1480", "street" : "2 Avenue", "zipcode" : "10075" &#125; &#125;, function(err, results) &#123; console.log(results); callback(); &#125;); _id字段不能更新。 删除数据删除符合条件的所有文档。 var removeRestaurants = function(db, callback) &#123; db.collection('restaurants').deleteMany( &#123; "borough": "Manhattan" &#125;, function(err, results) &#123; console.log(results); callback(); &#125; );&#125;;MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); removeRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 删除单一文档。 db.collection('restaurants').deleteOne( &#123; "borough": "Queens" &#125;, function(err, results) &#123; console.log(results); callback(); &#125; ); 删除所有文档。 db.collection('restaurants').deleteMany( &#123;&#125;, function(err, results) &#123; console.log(results); callback(); &#125;); 删除整个集合。 db.collection('restaurants').drop( function(err, response) &#123; console.log(response) callback(); &#125;); 聚合操作var aggregateRestaurants = function(db, callback) &#123; db.collection('restaurants').aggregate( [ &#123; $group: &#123; "_id": "$borough", "count": &#123; $sum: 1 &#125; &#125; &#125; ]).toArray(function(err, result) &#123; assert.equal(err, null); console.log(result); callback(result); &#125;);&#125;;MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); aggregateRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 上面的代码产生下面的结果。 [ &#123; _id: 'Missing', count: 51 &#125;, &#123; _id: 'Staten Island', count: 969 &#125;, &#123; _id: 'Manhattan', count: 10259 &#125;, &#123; _id: 'Brooklyn', count: 6086 &#125;, &#123; _id: 'Queens', count: 5656 &#125;, &#123; _id: 'Bronx', count: 2338 &#125; ] 带有过滤条件的聚合。 db.collection('restaurants').aggregate( [ &#123; $match: &#123; "borough": "Queens", "cuisine": "Brazilian" &#125; &#125;, &#123; $group: &#123; "_id": "$address.zipcode" , "count": &#123; $sum: 1 &#125; &#125; &#125; ]).toArray(function(err, result) &#123; assert.equal(err, null); console.log(result); callback(result); &#125;); 索引生成一个单字段的索引，1表示升序，-1表示降序。 var indexRestaurants = function(db, callback) &#123; db.collection('restaurants').createIndex( &#123; "cuisine": 1 &#125;, null, function(err, results) &#123; console.log(results); callback(); &#125; );&#125;;MongoClient.connect(url, function(err, db) &#123; assert.equal(null, err); indexRestaurants(db, function() &#123; db.close(); &#125;);&#125;); 生成多个字段的索引。 db.collection('restaurants').createIndex( &#123; "cuisine": 1, "address.zipcode": -1 &#125;, null, function(err, results) &#123; console.log(results); callback(); &#125; ); 命令行操作输入数据。 $ mongoimport --db test --collection restaurants --drop --file primer-dataset.json Mongoose多种中间件可以用于连接node.js与MongoDB，目前比较常用的Mongoose。 首先，在项目目录将Mongoose安装为本地模块。 npm install mongoose --save 然后，就可以在node.js脚本中连接MongoDB数据库了。 var mongoose = require('mongoose');// 连接字符串格式为mongodb://主机/数据库名mongoose.connect('mongodb://localhost/mydatabase'); 注意，运行上面这个脚本时，必须确保MongoDB处于运行中。 数据库连接后，可以对open和error事件指定监听函数。 var db = mongoose.connection;db.on('error', function callback () &#123; console.log("Connection error");&#125;);db.once('open', function callback () &#123; console.log("Mongo working!");&#125;); mongoose.Schema方法用来定义数据集的格式（schema），mongoose.model方法将格式分配给指定的数据集。 var Schema = mongoose.Schema;var userSchema = new Schema(&#123; name : String, age : Number, DOB : Date, isAlive : Boolean&#125;);var User = mongoose.model('User', userSchema);var arvind = new User(&#123; name : 'Arvind', age : 99, DOB : '01/01/1915', isAlive : true&#125;);arvind.save(function (err, data) &#123; if (err)&#123; console.log(err); &#125; else &#123; console.log('Saved : ', data ); &#125;&#125;);]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Net模块和DNS模块]]></title>
    <url>%2F2017%2F04%2F19%2FNet%E6%A8%A1%E5%9D%97%E5%92%8CDNS%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[net模块用于底层的网络通信。 下面是一段简单的监听2000端口的代码。 var net = require('net');var server = net.createServer();server.listen(2000, function () &#123; console.log('Listening on port 2000'); &#125;);server.on('connection', function (stream) &#123; console.log('Accepting connection from', stream.remoteAddress); stream.on('data', function (data) &#123; stream.write(data); &#125;); stream.on('end', function (data) &#123; console.log('Connection closed'); &#125;);&#125;); isIP()isIP方法用于判断某个字符串是否为IP地址。 require('net').isIP('10.0.0.1') // 4require('net').isIP('cats') // 0 服务器端Socket接口来看一个简单的Telnet服务的例子。 var net = require('net');var port = 1081;var logo = fs.readFileSync('logo.txt');var ps1 = '\n\n&gt;&gt;&gt; ';net.createServer( function ( socket ) &#123; socket.write( logo ); socket.write( ps1 ); socket.on( 'data', recv.bind( null, socket ) );&#125; ).listen( port ); 上面代码，在1081端口架设了一个服务。可以用telnet访问这个服务。 $ telnet localhost 1081 一旦telnet连入以后，就会显示提示符&gt;&gt;&gt;，输入命令以后，就会调用回调函数recv。 function recv( socket, data ) &#123; if ( data === 'quit' ) &#123; socket.end( 'Bye!\n' ); return; &#125; request( &#123; uri: baseUrl + data &#125;, function ( error, response, body ) &#123; if ( body &amp;&amp; body.length ) &#123; $ = cheerio.load( body ); socket.write( $( '#mw-content-text p' ).first().text() + '\n' ); &#125; else &#123; socket.write( 'Error: ' + response.statusCode ); &#125; socket.write( ps1 ); &#125; );&#125; 上面代码中，如果输入的命令是quit，然后就退出telnet。如果是其他命令，就发起远程请求读取数据，并显示在屏幕上。 下面代码是另一个例子，用到了更多的接口。 var serverPort = 9099;var net = require('net');var server = net.createServer(function(client) &#123; console.log('client connected'); console.log('client IP Address: ' + client.remoteAddress); console.log('is IPv6: ' + net.isIPv6(client.remoteAddress)); console.log('total server connections: ' + server.connections); // Waiting for data from the client. client.on('data', function(data) &#123; console.log('received data: ' + data.toString()); // Write data to the client socket. client.write('hello from server'); &#125;); // Closed socket event from the client. client.on('end', function() &#123; console.log('client disconnected'); &#125;);&#125;);server.on('error',function(err)&#123; console.log(err); server.close();&#125;);server.listen(serverPort, function() &#123; console.log('server started on port ' + serverPort);&#125;); 上面代码中，createServer方法建立了一个服务端，一旦收到客户端发送的数据，就发出回应，同时还监听客户端是否中断通信。最后，listen方法打开服务端。 客户端Socket接口客户端Socket接口用来向服务器发送数据。 var serverPort = 9099;var server = 'localhost';var net = require('net');console.log('connecting to server...');var client = net.connect(&#123;server:server,port:serverPort&#125;,function()&#123; console.log('client connected'); // send data console.log('send data to server'); client.write('greeting from client socket');&#125;);client.on('data', function(data) &#123; console.log('received data: ' + data.toString()); client.end();&#125;);client.on('error',function(err)&#123; console.log(err);&#125;);client.on('end', function() &#123; console.log('client disconnected');&#125;); 上面代码连接服务器之后，就向服务器发送数据，然后监听服务器返回的数据。 DNS模块DNS模块用于解析域名。resolve4方法用于IPv4环境，resolve6方法用于IPv6环境，lookup方法在以上两种环境都可以使用，返回IP地址（address）和当前环境（IPv4或IPv6）。 var dns = require('dns');dns.resolve4('www.pecollege.net', function (err, addresses) &#123; if (err) console.log(err); console.log('addresses: ' + JSON.stringify(addresses));&#125;);dns.lookup('www.pecollege.net', function (err, address, family) &#123; if (err) console.log(err); console.log('addresses: ' + JSON.stringify(address)); console.log('family: ' + JSON.stringify(family));&#125;);]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[process对象]]></title>
    <url>%2F2017%2F04%2F19%2Fprocess%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[process对象是Node的一个全局对象，提供当前Node进程的信息。它可以在脚本的任意位置使用，不必通过require命令加载。该对象部署了EventEmitter接口。 进程的退出码进程退出时，会返回一个整数值，表示退出时的状态。这个整数值就叫做退出码。下面是常见的Node进程退出码。 0，正常退出 1，发生未捕获错误 5，V8执行错误 8，不正确的参数 128 + 信号值，如果Node接受到退出信号（比如SIGKILL或SIGHUP），它的退出码就是128加上信号值。由于128的二进制形式是10000000, 所以退出码的后七位就是信号值。 Bash可以使用环境变量$?，获取上一步操作的退出码。 $ node nonexist.jsError: Cannot find 'nonexist.js'$ echo $?1 上面代码中，Node执行一个不存在的脚本文件，结果报错，退出码就是1。 属性process对象提供一系列属性，用于返回系统信息。 process.argv：返回当前进程的命令行参数数组。 process.env：返回一个对象，成员为当前Shell的环境变量，比如process.env.HOME。 process.installPrefix：node的安装路径的前缀，比如/usr/local，则node的执行文件目录为/usr/local/bin/node。 process.pid：当前进程的进程号。 process.platform：当前系统平台，比如Linux。 process.title：默认值为“node”，可以自定义该值。 process.version：Node的版本，比如v0.10.18。 下面是主要属性的介绍。 stdout，stdin，stderr以下属性指向系统I/O。 （1）stdout stdout属性指向标准输出（文件描述符1）。它的write方法等同于console.log，可用在标准输出向用户显示内容。 console.log = function(d) &#123; process.stdout.write(d + '\n');&#125;; 下面代码表示将一个文件导向标准输出。 var fs = require('fs');fs.createReadStream('wow.txt') .pipe(process.stdout); 上面代码中，由于process.stdout和process.stdin与其他进程的通信，都是流（stream）形式，所以必须通过pipe管道命令中介。 var fs = require('fs');var zlib = require('zlib');fs.createReadStream('wow.txt') .pipe(zlib.createGzip()) .pipe(process.stdout); 上面代码通过pipe方法，先将文件数据压缩，然后再导向标准输出。 （2）stdin stdin代表标准输入（文件描述符0）。 process.stdin.pipe(process.stdout) 上面代码表示将标准输入导向标准输出。 由于stdin和stdout都部署了stream接口，所以可以使用stream接口的方法。 process.stdin.setEncoding('utf8');process.stdin.on('readable', function() &#123; var chunk = process.stdin.read(); if (chunk !== null) &#123; process.stdout.write('data: ' + chunk); &#125;&#125;);process.stdin.on('end', function() &#123; process.stdout.write('end');&#125;); （3）stderr stderr属性指向标准错误（文件描述符2）。 argv，execPath，execArgvargv属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。 请看下面的例子，新建一个脚本文件argv.js。 // argv.jsconsole.log("argv: ",process.argv); 在命令行下调用这个脚本，会得到以下结果。 $ node argv.js a b c[ 'node', '/path/to/argv.js', 'a', 'b', 'c' ] 上面代码表示，argv返回数组的成员依次是命令行的各个部分，真正的参数实际上是从process.argv[2]开始。要得到真正的参数部分，可以把argv.js改写成下面这样。 // argv.jsvar myArgs = process.argv.slice(2);console.log(myArgs); execPath属性返回执行当前脚本的Node二进制文件的绝对路径。 &gt; process.execPath'/usr/local/bin/node'&gt; execArgv属性返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。 # script.js的代码为# console.log(process.execArgv);$ node --harmony script.js --version process.envprocess.env属性返回一个对象，包含了当前Shell的所有环境变量。比如，process.env.HOME返回用户的主目录。 通常的做法是，新建一个环境变量NODE_ENV，用它确定当前所处的开发阶段，生产阶段设为production，开发阶段设为develop或staging，然后在脚本中读取process.env.NODE_ENV即可。 运行脚本时，改变环境变量，可以采用下面的写法。 $ export NODE_ENV=production &amp;&amp; node app.js# 或者$ NODE_ENV=production node app.js 方法process对象提供以下方法： process.chdir()：切换工作目录到指定目录。 process.cwd()：返回运行当前脚本的工作目录的路径。 process.exit()：退出当前进程。 process.getgid()：返回当前进程的组ID（数值）。 process.getuid()：返回当前进程的用户ID（数值）。 process.nextTick()：指定回调函数在当前执行栈的尾部、下一次Event Loop之前执行。 process.on()：监听事件。 process.setgid()：指定当前进程的组，可以使用数字ID，也可以使用字符串ID。 process.setuid()：指定当前进程的用户，可以使用数字ID，也可以使用字符串ID。 process.cwd()，process.chdir()cwd方法返回进程的当前目录（绝对路径），chdir方法用来切换目录。 &gt; process.cwd()'/home/aaa'&gt; process.chdir('/home/bbb')&gt; process.cwd()'/home/bbb' 注意，process.cwd()与__dirname的区别。前者进程发起时的位置，后者是脚本的位置，两者可能是不一致的。比如，node ./code/program.js，对于process.cwd()来说，返回的是当前目录（.）；对于__dirname来说，返回是脚本所在目录，即./code/program.js。 process.nextTick()process.nextTick将任务放到当前一轮事件循环（Event Loop）的尾部。 process.nextTick(function () &#123; console.log('下一次Event Loop即将开始!');&#125;); 上面代码可以用setTimeout(f,0)改写，效果接近，但是原理不同。 setTimeout(function () &#123; console.log('已经到了下一轮Event Loop！');&#125;, 0) setTimeout(f,0)是将任务放到下一轮事件循环的头部，因此nextTick会比它先执行。另外，nextTick的效率更高，因为不用检查是否到了指定时间。 根据Node的事件循环的实现，基本上，进入下一轮事件循环后的执行顺序如下。 setTimeout(f,0) 各种到期的回调函数 process.nextTickpush(), sort(), reverse(), and splice() process.exit() process.exit方法用来退出当前进程。它可以接受一个数值参数，如果参数大于0，表示执行失败；如果等于0表示执行成功。 if (err) &#123; process.exit(1);&#125; else &#123; process.exit(0);&#125; process.exit()执行时，会触发exit事件。 process.on()process对象部署了EventEmitter接口，可以使用on方法监听各种事件，并指定回调函数。 process.on('uncaughtException', function(err)&#123; console.error('got an error: %s', err.message); process.exit(1);&#125;);setTimeout(function()&#123; throw new Error('fail');&#125;, 100); 上面代码是process监听Node的一个全局性事件uncaughtException，只要有错误没有捕获，就会触发这个事件。 process支持的事件还有下面这些。 data事件：数据输出输入时触发 SIGINT事件：接收到系统信号SIGINT时触发，主要是用户按Ctrl + c时触发。 SIGTERM事件：系统发出进程终止信号SIGTERM时触发 exit事件：进程退出前触发 process.on('SIGINT', function () &#123; console.log('Got a SIGINT. Goodbye cruel world'); process.exit(0);&#125;);// 也可以忽略这个信号process.on('SIGINT', function() &#123; console.log("Ignored Ctrl-C");&#125;); 使用时，向该进程发出系统信号，就会导致进程退出。 $ kill -s SIGINT [process_id] SIGTERM信号表示内核要求当前进程停止，进程可以自行停止，也可以忽略这个信号。 var http = require('http');var server = http.createServer(function (req, res) &#123; // ...&#125;);process.on('SIGTERM', function () &#123; server.close(function () &#123; process.exit(0); &#125;);&#125;); 上面代码表示，进程接到SIGTERM信号之后，关闭服务器，然后退出进程。需要注意的是，这时进程不会马上退出，而是要回应完最后一个请求，处理完所有回调函数，然后再退出。 exit事件在Node进程退出前触发。 process.on('exit', function() &#123; console.log('Goodbye');&#125;); process.kill()process.kill方法用来对指定ID的线程发送信号，默认为SIGINT信号。 process.kill(process.pid, 'SIGTERM'); 上面代码用于杀死当前进程。 process.on('SIGTERM', function()&#123; console.log('terminating'); process.exit(1);&#125;);setTimeout(function()&#123; console.log('sending SIGTERM to process %d', process.pid); process.kill(process.pid, 'SIGTERM');&#125;, 500);setTimeout(function()&#123; console.log('never called');&#125;, 1000); 上面代码中，500毫秒后向当前进程发送SIGTERM信号（终结进程），因此1000毫秒后的指定事件不会被触发。 事件exit事件当前进程退出时，会触发exit事件，可以对该事件指定回调函数。 process.on('exit', function () &#123; fs.writeFileSync('/tmp/myfile', '需要保存到硬盘的信息');&#125;); 下面是一个例子，进程退出时，显示一段日志。 process.on("exit", code =&gt; console.log("exiting with code: " + code)) 注意，此时回调函数只能执行同步操作，不能包含异步操作，因为执行完回调函数，进程就会退出，无法监听到回调函数的操作结果。 process.on('exit', function(code) &#123; // 不会执行 setTimeout(function() &#123; console.log('This will not run'); &#125;, 0);&#125;); 上面代码在exit事件的回调函数里面，指定了一个下一轮事件循环，所要执行的操作。这是无效的，不会得到执行。 beforeExit事件beforeExit事件在Node清空了Event Loop以后，再没有任何待处理的任务时触发。正常情况下，如果没有任何待处理的任务，Node进程会自动退出，设置beforeExit事件的监听函数以后，就可以提供一个机会，再部署一些任务，使得Node进程不退出。 beforeExit事件与exit事件的主要区别是，beforeExit的监听函数可以部署异步任务，而exit不行。 此外，如果是显式终止程序（比如调用process.exit()），或者因为发生未捕获的错误，而导致进程退出，这些场合不会触发beforeExit事件。因此，不能使用该事件替代exit事件。 uncaughtException事件当前进程抛出一个没有被捕捉的错误时，会触发uncaughtException事件。 process.on('uncaughtException', function (err) &#123; console.error('An uncaught error occurred!'); console.error(err.stack); throw new Error('未捕获错误');&#125;); 部署uncaughtException事件的监听函数，是免于Node进程终止的最后措施，否则Node就要执行process.exit()。出于除错的目的，并不建议发生错误后，还保持进程运行。 抛出错误之前部署的异步操作，还是会继续执行。只有完成以后，Node进程才会退出。 process.on('uncaughtException', function(err) &#123; console.log('Caught exception: ' + err);&#125;);setTimeout(function() &#123; console.log('本行依然执行');&#125;, 500);// 下面的表达式抛出错误nonexistentFunc(); 上面代码中，抛出错误之后，此前setTimeout指定的回调函数亦然会执行。 信号事件操作系统内核向Node进程发出信号，会触发信号事件。实际开发中，主要对SIGTERM和SIGINT信号部署监听函数，这两个信号在非Windows平台会导致进程退出，但是只要部署了监听函数，Node进程收到信号后就不会退出。 // 读取标准输入，这主要是为了不让当前进程退出process.stdin.resume();process.on('SIGINT', function() &#123; console.log('SIGINT信号，按Control-D退出');&#125;); 上面代码部署了SIGINT信号的监听函数，当用户按下Ctrl-C后，会显示提示文字。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为您详细比较三个CSS预处理器（框架）：Sass、LESS和Stylus]]></title>
    <url>%2F2017%2F04%2F13%2F%E4%B8%BA%E6%82%A8%E8%AF%A6%E7%BB%86%E6%AF%94%E8%BE%83%E4%B8%89%E4%B8%AACSS%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89%EF%BC%9ASass%E3%80%81LESS%E5%92%8CStylus%2F</url>
    <content type="text"><![CDATA[CSS 预处理器技术已经非常的成熟，而且也涌现出了越来越多的 CSS 的预处理器框架。本文向你介绍使用最为普遍的三款 CSS 预处理器框架，分别是 Sass、Less CSS、Stylus。 首先我们来简单介绍下什么是 CSS 预处理器，CSS 预处理器是一种语言用来为 CSS 增加一些编程的的特性，无需考虑浏览器的兼容性问题，例如你可以在 CSS 中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧，可以让你的 CSS 更见简洁，适应性更强，代码更直观等诸多好处。 不要再停留在石器时代了，下面让我们开始 CSS 预处理器之旅。 我们将会从语法、变量、嵌套、混入(Mixin)、继承、导入、函数和操作符等方面分别对这三个框架进行比较介绍。 语法在使用 CSS 预处理器之前最重要的是理解语法，幸运的是基本上大多数预处理器的语法跟 CSS 都差不多。 首先 Sass 和 Less 都使用的是标准的 CSS 语法，因此你可以很方便的将已有的 CSS 代码转为预处理器代码，默认 Sass 使用 .sass 扩展名，而 Less 使用 .less 扩展名。 Less与Sass语法h1 &#123; color: #0982C1;&#125; 你注意到了，这是一个再普通不过的，不过 Sass 同时也支持老的语法，就是不包含花括号和分号的方式：h1 color: #0982c1 Stylus语法Stylus 支持的语法要更多样性一点，它默认使用 .styl 的文件扩展名，下面是 Stylus 支持的语法：h1 &#123; color: #0982C1;&#125;h1 color: #0982C1; h1 color #0982C1 你也可以在同一个样式单中使用不同的变量，例如下面的写法也不会报错：h1 &#123; color #0982c1&#125;h2 font-size: 1.2em 变量你可以在 CSS 预处理器中声明变量，并在整个样式单中使用，支持任何类型的变量，例如颜色、数值（不管是否包括单位）、文本。然后你可以任意引用该变量。 Sass变量Sass 的变量必须是 $ 开始，然后变量名和值使用冒号隔开，跟 CSS 的属性一致： $mainColor: #0982c1;$siteWidth: 1024px;$borderStyle: dotted; body &#123; color: $mainColor; border: 1px $borderStyle $mainColor; max-width: $siteWidth;&#125; Less变量Less 的变量名使用 @ 符号开始：@mainColor: #0982c1;@siteWidth: 1024px;@borderStyle: dotted; body &#123; color: @mainColor; border: 1px @borderStyle @mainColor; max-width: @siteWidth;&#125; Stylus变量Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。mainColor = #0982c1siteWidth = 1024px$borderStyle = dotted body color mainColor border 1px $borderStyle mainColor max-width siteWidth 上面的三种不同的 CSS 预处理器的写法，最终都将产生相同的结果： body &#123; color: #0982c1; border: 1px dotted #0982c1; max-width: 1024px;&#125; 你可以想象，加入你的 CSS 中使用了某个颜色的地方多达数十次，那么要修改颜色时你必须找到这数十次的地方并一一修改，而有了 CSS 预处理器，修改一个地方就够了！ 嵌套如果我们需要在CSS中相同的 parent 中引用多个元素，这将是非常乏味的，你需要一遍又一遍地写 parent。例如：section &#123; margin: 10px;&#125;section nav &#123; height: 25px;&#125;section nav a &#123; color: #0982C1;&#125;section nav a:hover &#123; text-decoration: underline;&#125; 而如果用 CSS 预处理器，就可以少些很多单词，而且父子节点关系一目了然。我们这里提到的三个 CSS 框架都是允许嵌套语法：section &#123; margin: 10px; nav &#123; height: 25px; a &#123; color: #0982C1; &amp;amp;:hover &#123; text-decoration: underline; &#125; &#125; &#125;&#125; 最终生成的 CSS 结果是：section &#123; margin: 10px;&#125;section nav &#123; height: 25px;&#125;section nav a &#123; color: #0982C1;&#125;section nav a:hover &#123; text-decoration: underline;&#125; 非常之方便！ Mixins (混入)Mixins 有点像是函数或者是宏，当你某段 CSS 经常需要在多个元素中使用时，你可以为这些共用的 CSS 定义一个 Mixin，然后你只需要在需要引用这些 CSS 地方调用该 Mixin 即可。 Sass的混入语法/* Sass mixin error with (optional) argument $borderWidth which defaults to 2px if not specified */@mixin error($borderWidth: 2px) &#123; border: $borderWidth solid #F00; color: #F00;&#125; .generic-error &#123; padding: 20px; margin: 4px; @ include error(); /* Applies styles from mixin error */&#125;.login-error &#123; left: 12px; position: absolute; top: 20px; @ include error(5px); /* Applies styles from mixin error with argument $borderWidth equal to 5px*/&#125; Less的混入语法/* LESS mixin error with (optional) argument @borderWidth which defaults to 2px if not specified */.error(@borderWidth: 2px) &#123; border: @borderWidth solid #F00; color: #F00;&#125; .generic-error &#123; padding: 20px; margin: 4px; .error(); /* Applies styles from mixin error */&#125;.login-error &#123; left: 12px; position: absolute; top: 20px; .error(5px); /* Applies styles from mixin error with argument @borderWidth equal to 5px */&#125; Stylus的混入语法/* Stylus mixin error with (optional) argument borderWidth which defaults to 2px if not specified */error(borderWidth= 2px) &#123; border: borderWidth solid #F00; color: #F00;&#125; .generic-error &#123; padding: 20px; margin: 4px; error(); /* Applies styles from mixin error */&#125;.login-error &#123; left: 12px; position: absolute; top: 20px; error(5px); /* Applies styles from mixin error with argument borderWidth equal to 5px */&#125; 最终它们都将编译成如下的 CSS 样式：.generic-error &#123; padding: 20px; margin: 4px; border: 2px solid #f00; color: #f00;&#125;.login-error &#123; left: 12px; position: absolute; top: 20px; border: 5px solid #f00; color: #f00;&#125; 继承当我们需要为多个元素定义相同样式的时候，我们可以考虑使用继承的做法。例如我们经常需要：p,ul,ol &#123; /* styles here */&#125; Sass和Stylus的继承.block &#123; margin: 10px 5px; padding: 2px;&#125; p &#123; @extend .block; /* Inherit styles from '.block' */ border: 1px solid #EEE;&#125;ul, ol &#123; @extend .block; /* Inherit styles from '.block' */ color: #333; text-transform: uppercase;&#125; 在这里首先定义 .block 块，然后让 p 、ul 和 ol 元素继承 .block ，最终生成的 CSS 如下：.block, p, ul, ol &#123; margin: 10px 5px; padding: 2px;&#125;p &#123; border: 1px solid #EEE;&#125;ul, ol &#123; color: #333; text-transform: uppercase;&#125; Less的继承.block &#123; margin: 10px 5px; padding: 2px;&#125; p &#123; .block; /* Inherit styles from '.block' */ border: 1px solid #EEE;&#125;ul, ol &#123; .block; /* Inherit styles from '.block' */ color: #333; text-transform: uppercase;&#125; 生成的 CSS 如下：.block &#123; margin: 10px 5px; padding: 2px;&#125;p &#123; margin: 10px 5px; padding: 2px; border: 1px solid #EEE;&#125;ul,ol &#123; margin: 10px 5px; padding: 2px; color: #333; text-transform: uppercase;&#125; 你所看到的上面的代码中，.block 的样式将会被插入到相应的你想要继承的选择器中，但需要注意的是优先级的问题。 导入 (Import)导入使用的后缀不要用css，用以上我们提到的三种对应格式。不然和css的导入相同，会增加http请求次数。 reset.xxx body &#123; background: #EEE;&#125; main.xxx@ import "reset"; p &#123; background: #0982C1;&#125; 最终的main.css：body &#123; background: #EEE;&#125;p &#123; background: #0982C1;&#125; 颜色函数CSS 预处理器一般都会内置一些颜色处理函数用来对颜色值进行处理，例如加亮、变暗、颜色梯度等。 Sasslighten($color, 10%); /* returns a color 10% lighter than $color */darken($color, 10%); /* returns a color 10% darker than $color */ saturate($color, 10%); /* returns a color 10% more saturated than $color */desaturate($color, 10%); /* returns a color 10% less saturated than $color */ grayscale($color); /* returns grayscale of $color */complement($color); /* returns complement color of $color */invert($color); /* returns inverted color of $color */ mix($color1, $color2, 50%); /* mix $color1 with $color2 with a weight of 50% */ 上面只是简单列了 Sass 的一些基本颜色处理函数，完整的列表请看 Sass Documentation 下面是一个具体的例子：$color: #0982C1; h1 &#123; background: $color; border: 3px solid darken($color, 50%);&#125; Lesslighten(@color, 10%); /* returns a color 10% lighter than @color */darken(@color, 10%); /* returns a color 10% darker than @color */ saturate(@color, 10%); /* returns a color 10% more saturated than @color */desaturate(@color, 10%); /* returns a color 10% less saturated than @color */ spin(@color, 10); /* returns a color with a 10 degree larger in hue than @color */spin(@color, -10); /* returns a color with a 10 degree smaller hue than @color */ mix(@color1, @color2); /* return a mix of @color1 and @color2 */ LESS 完整的颜色函数列表请看 LESS Documentation LESS 使用颜色函数的例子：@color: #0982C1; h1 &#123; background: @color; border: 3px solid darken(@color, 50%);&#125; Styluslighten(color, 10%); /* returns a color 10% lighter than 'color' */darken(color, 10%); /* returns a color 10% darker than 'color' */ saturate(color, 10%); /* returns a color 10% more saturated than 'color' */desaturate(color, 10%); /* returns a color 10% less saturated than 'color' */ 完整的颜色函数列表请阅读 Stylus Documentation 实例：color = #0982C1 h1 background color border 3px solid darken(color, 50%) 运算符你可以直接在 CSS 预处理器中进行样式的计算，例如：body &#123; margin: (14px/2); top: 50px + 100px; right: 100px - 50px; left: 10 * 10;&#125; 一些跟具体浏览器相关的处理这是宣传使用预处理的原因之一，并且是一个很好的理由，这样可以节省的大量的时间和汗水。创建一个mixin来处理不同浏览器的CSS写法是很简单的，节省了大量的重复工作和痛苦的代码编辑。 Sass@mixin border-radius($values) &#123; -webkit-border-radius: $values; -moz-border-radius: $values; border-radius: $values;&#125; div &#123; @ include border-radius(10px);&#125; Less.border-radius(@values) &#123; -webkit-border-radius: @values; -moz-border-radius: @values; border-radius: @values;&#125; div &#123; .border-radius(10px);&#125; Stylusborder-radius(values) &#123; -webkit-border-radius: values; -moz-border-radius: values; border-radius: values;&#125; div &#123; border-radius(10px);&#125; 编译结果： div &#123; -webkit-border-radius: 10px; -moz-border-radius: 10px; border-radius: 10px;&#125; 3D文本要生成具有 3D 效果的文本可以使用 text-shadows ，唯一的问题就是当要修改颜色的时候就非常的麻烦，而通过 mixin 和颜色函数可以很轻松的实现： ##Sass @mixin text3d($color) &#123; color: $color; text-shadow: 1px 1px 0px darken($color, 5%), 2px 2px 0px darken($color, 10%), 3px 3px 0px darken($color, 15%), 4px 4px 0px darken($color, 20%), 4px 4px 2px #000;&#125; h1 &#123; font-size: 32pt; @ include text3d(#0982c1);&#125; Less.text3d(@color) &#123; color: @color; text-shadow: 1px 1px 0px darken(@color, 5%), 2px 2px 0px darken(@color, 10%), 3px 3px 0px darken(@color, 15%), 4px 4px 0px darken(@color, 20%), 4px 4px 2px #000;&#125; span &#123; font-size: 32pt; .text3d(#0982c1);&#125; Stylustext3d(color) color: csscolor text-shadow: 1px 1px 0px darken(color, 5%), 2px 2px 0px darken(color, 10%), 3px 3px 0px darken(color, 15%), 4px 4px 0px darken(color, 20%), 4px 4px 2px #000span font-size: 32pt text3d(#0982c1) 生成的 CSS span &#123; font-size: 32pt; color: #0982c1; text-shadow: 1px 1px 0px #097bb7, 2px 2px 0px #0875ae, 3px 3px 0px #086fa4, 4px 4px 0px #07689a, 4px 4px 2px #000;&#125; 列 (Columns)使用数值操作和变量可以很方便的实现适应屏幕大小的布局处理。 Sass$siteWidth: 1024px;$gutterWidth: 20px;$sidebarWidth: 300px; body &#123; margin: 0 auto; width: $siteWidth;&#125;.content &#123; float: left; width: $siteWidth - ($sidebarWidth+$gutterWidth);&#125;.sidebar &#123; float: left; margin-left: $gutterWidth; width: $sidebarWidth;&#125; Less@siteWidth: 1024px;@gutterWidth: 20px;@sidebarWidth: 300px; body &#123; margin: 0 auto; width: @siteWidth;&#125;.content &#123; float: left; width: @siteWidth - (@sidebarWidth+@gutterWidth);&#125;.sidebar &#123; float: left; margin-left: @gutterWidth; width: @sidebarWidth;&#125; Stylus siteWidth = 1024px;gutterWidth = 20px;sidebarWidth = 300px; body &#123; margin: 0 auto; width: siteWidth;&#125;.content &#123; float: left; width: siteWidth - (sidebarWidth+gutterWidth);&#125;.sidebar &#123; float: left; margin-left: gutterWidth; width: sidebarWidth;&#125; 实际效果 body &#123; margin: 0 auto; width: 1024px;&#125;.content &#123; float: left; width: 704px;&#125;.sidebar &#123; float: left; margin-left: 20px; width: 300px;&#125; 错误报告如果你经常 CSS 你会发现很难找到 CSS 中错误的地方，这也是预处理框架的好处，它会报告错误，你可以从这篇文章中学习如何让 CSS 框架错误报告。 注释以上三种框架都支持形如 / / 的多行注释以及 // 的单行注释。其中//注释会在编译时被删除。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ionic笔记]]></title>
    <url>%2F2017%2F04%2F10%2Fionic%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下Ionic。 简介ionic 是一个强大的 HTML5 应用程序开发框架(HTML5 Hybrid Mobile App Framework )。 可以帮助您使用 Web 技术，比如 HTML、CSS 和 Javascript 构建接近原生体验的移动应用程序。 ionic 主要关注外观和体验，以及和你的应用程序的 UI 交互，特别适合用于基于 Hybird 模式的 HTML5 移动应用程序开发。 ionic是一个轻量的手机UI库，具有速度快，界面现代化、美观等特点。为了解决其他一些UI库在手机上运行缓慢的问题，它直接放弃了IOS6和Android4.1以下的版本支持，来获取更好的使用体验。 安装常规安装CDN、github下载、官网下载的等。下载后的目录：css/ =&gt; 样式文件fonts/ =&gt; 字体文件js/ =&gt; Javascript文件version.json =&gt; 版本更新说明 接下来，我们只需要在项目中引入以上目录中的 css/ionic.min.css 和 js/ionic.bundle.min.js 文件即可创建 ionic 应用。 命令行安装确保配置好对应环境（安卓为例）： node git java_jdk android_sdk # 安装$ npm install -g cordova ionic# 更新$ npm update -g cordova ionic# 创建一个模板$ ionic start myApp tabs# 进入对应目录$ cd myApp# 添加平台$ ionic platform add android# 打包$ ionic build android# 运行在模拟器中$ ionic emulate android# 一般打包完我们用数据线链接手机，输入一下命令$ adb devices // 测试设备是否链接成功# 将打包的APK自动安装到手机$ ionic run android 基本的模板目录index.html //入口文件-css-js app.js //主模块 services.js controllers.js routes.js-img-lib -ionic- templates index.html内容示例&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no, width=device-width"&gt; &lt;title&gt;&lt;/title&gt; &lt;link rel="manifest" href="manifest.json"&gt; &lt;!-- un-comment this code to enable service worker &lt;script&gt; if ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('service-worker.js') .then(() =&gt; console.log('service worker installed')) .catch(err =&gt; console.log('Error', err)); &#125; &lt;/script&gt;--&gt; &lt;link href="lib/ionic/css/ionic.css" rel="stylesheet"&gt; &lt;link href="css/style.css" rel="stylesheet"&gt; &lt;!-- IF using Sass (run gulp sass first), then uncomment below and remove the CSS includes above &lt;link href="css/ionic.app.css" rel="stylesheet"&gt; --&gt; &lt;!-- ionic/angularjs js --&gt; &lt;script src="lib/ionic/js/ionic.bundle.js"&gt;&lt;/script&gt; &lt;!-- cordova script (this will be a 404 during development) --&gt; &lt;script src="cordova.js"&gt;&lt;/script&gt; &lt;!-- your app's js --&gt; &lt;script src="js/app.js"&gt;&lt;/script&gt; &lt;script src="js/controllers.js"&gt;&lt;/script&gt; &lt;script src="js/services.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="starter"&gt; &lt;!-- The nav bar that will be updated as we navigate between views. --&gt; &lt;ion-nav-bar class="bar-stable"&gt; &lt;ion-nav-back-button&gt; &lt;/ion-nav-back-button&gt; &lt;/ion-nav-bar&gt; &lt;!-- The views will be rendered in the &lt;ion-nav-view&gt; directive below Templates are in the /templates folder (but you could also have templates inline in this html file if you'd like). --&gt; &lt;ion-nav-view&gt;&lt;/ion-nav-view&gt;&lt;/body&gt;&lt;/html&gt; tabs.html&lt;ion-tabs class="tabs-icon-top tabs-color-active-positive"&gt; &lt;!-- Dashboard Tab --&gt; &lt;ion-tab title="Status" icon-off="ion-ios-pulse" icon-on="ion-ios-pulse-strong" href="#/tab/dash"&gt; &lt;ion-nav-view name="tab-dash"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;!-- Chats Tab --&gt; &lt;ion-tab title="Chats" icon-off="ion-ios-chatboxes-outline" icon-on="ion-ios-chatboxes" href="#/tab/chats"&gt; &lt;ion-nav-view name="tab-chats"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt; &lt;!-- Account Tab --&gt; &lt;ion-tab title="Account" icon-off="ion-ios-gear-outline" icon-on="ion-ios-gear" href="#/tab/account"&gt; &lt;ion-nav-view name="tab-account"&gt;&lt;/ion-nav-view&gt; &lt;/ion-tab&gt;&lt;/ion-tabs&gt; tab-demo.html&lt;ion-view view-title="Dashboard"&gt; &lt;ion-content class="padding"&gt; &lt;h2&gt;Welcome to Ionic&lt;/h2&gt; &lt;p&gt; This is the Ionic starter for tabs-based apps. For other starters and ready-made templates, check out the &lt;a href="http://market.ionic.io/starters" target="_blank"&gt;Ionic Market&lt;/a&gt;. &lt;/p&gt; &lt;p&gt; To edit the content of each tab, edit the corresponding template file in &lt;code&gt;www/templates/&lt;/code&gt;. This template is &lt;code&gt;www/templates/tab-dash.html&lt;/code&gt; &lt;/p&gt; &lt;p&gt; If you need help with your app, join the Ionic Community on the &lt;a href="http://forum.ionicframework.com" target="_blank"&gt;Ionic Forum&lt;/a&gt;. Make sure to &lt;a href="http://twitter.com/ionicframework" target="_blank"&gt;follow us&lt;/a&gt; on Twitter to get important updates and announcements for Ionic developers. &lt;/p&gt; &lt;p&gt; For help sending push notifications, join the &lt;a href="https://apps.ionic.io/signup" target="_blank"&gt;Ionic Platform&lt;/a&gt; and check out &lt;a href="http://docs.ionic.io/docs/push-overview" target="_blank"&gt;Ionic Push&lt;/a&gt;. We also have other services available. &lt;/p&gt; &lt;/ion-content&gt;&lt;/ion-view&gt; app.js主模块angular.module('starter', ['ionic', 'starter.controllers', 'starter.services']).run(function($ionicPlatform) &#123; $ionicPlatform.ready(function() &#123; // Hide the accessory bar by default (remove this to show the accessory bar above the keyboard // for form inputs) if (window.cordova &amp;&amp; window.cordova.plugins &amp;&amp; window.cordova.plugins.Keyboard) &#123; cordova.plugins.Keyboard.hideKeyboardAccessoryBar(true); cordova.plugins.Keyboard.disableScroll(true); &#125; if (window.StatusBar) &#123; // org.apache.cordova.statusbar required StatusBar.styleDefault(); &#125; &#125;);&#125;).config(function($stateProvider, $urlRouterProvider) &#123; // Ionic uses AngularUI Router which uses the concept of states // Learn more here: https://github.com/angular-ui/ui-router // Set up the various states which the app can be in. // Each state's controller can be found in controllers.js $stateProvider // setup an abstract state for the tabs directive .state('tab', &#123; url: '/tab', abstract: true, templateUrl: 'templates/tabs.html' &#125;) // Each tab has its own nav history stack: .state('tab.dash', &#123; url: '/dash', views: &#123; 'tab-dash': &#123; templateUrl: 'templates/tab-dash.html', controller: 'DashCtrl' &#125; &#125; &#125;) .state('tab.chats', &#123; url: '/chats', views: &#123; 'tab-chats': &#123; templateUrl: 'templates/tab-chats.html', controller: 'ChatsCtrl' &#125; &#125; &#125;) .state('tab.chat-detail', &#123; url: '/chats/:chatId', views: &#123; 'tab-chats': &#123; templateUrl: 'templates/chat-detail.html', controller: 'ChatDetailCtrl' &#125; &#125; &#125;) .state('tab.account', &#123; url: '/account', views: &#123; 'tab-account': &#123; templateUrl: 'templates/tab-account.html', controller: 'AccountCtrl' &#125; &#125; &#125;); // if none of the above states are matched, use this as the fallback $urlRouterProvider.otherwise('/tab/dash');&#125;); controllers.jsangular.module('starter.controllers', []).controller('DashCtrl', function($scope) &#123;&#125;).controller('ChatsCtrl', function($scope, Chats) &#123; // With the new view caching in Ionic, Controllers are only called // when they are recreated or on app start, instead of every page change. // To listen for when this page is active (for example, to refresh data), // listen for the $ionicView.enter event: // //$scope.$on('$ionicView.enter', function(e) &#123; //&#125;); $scope.chats = Chats.all(); $scope.remove = function(chat) &#123; Chats.remove(chat); &#125;;&#125;).controller('ChatDetailCtrl', function($scope, $stateParams, Chats) &#123; $scope.chat = Chats.get($stateParams.chatId);&#125;).controller('AccountCtrl', function($scope) &#123; $scope.settings = &#123; enableFriends: true &#125;;&#125;); services.jsangular.module('starter.services', []).factory('Chats', function() &#123; // Might use a resource here that returns a JSON array // Some fake testing data var chats = [&#123; id: 0, name: 'Ben Sparrow', lastText: 'You on your way?', face: 'img/ben.png' &#125;, &#123; id: 1, name: 'Max Lynx', lastText: 'Hey, it\'s me', face: 'img/max.png' &#125;, &#123; id: 2, name: 'Adam Bradleyson', lastText: 'I should buy a boat', face: 'img/adam.jpg' &#125;, &#123; id: 3, name: 'Perry Governor', lastText: 'Look at my mukluks!', face: 'img/perry.png' &#125;, &#123; id: 4, name: 'Mike Harrington', lastText: 'This is wicked good ice cream.', face: 'img/mike.png' &#125;]; return &#123; all: function() &#123; return chats; &#125;, remove: function(chat) &#123; chats.splice(chats.indexOf(chat), 1); &#125;, get: function(chatId) &#123; for (var i = 0; i &lt; chats.length; i++) &#123; if (chats[i].id === parseInt(chatId)) &#123; return chats[i]; &#125; &#125; return null; &#125; &#125;;&#125;); Ionic CSS文档参考地址：http://www.ionic.wang/css_doc-index.html Ionic JS文档参考地址：http://www.ionic.wang/js_doc-index.html Ionic图标参考地址：http://ionicons.com/ 常用网址 ionic 官方网站 ionic 官方文档 Github 地址 项目文件代码示例shopping入口文件编写规则： head中，引框架带的css，插件css，各个功能模块的css，自己定制css body底部，引入框架带的js，插件js，全局js，各个功能模块js 一般每个功能模块对应一个页面或者多个相同页面不同数据，每个功能模块编写对应的路由、控制器、服务、视图。 全局js： app.js：主模块，依赖[‘ionic’,’route’,’global’,’config’,’ionicLazyLoad’] config.js：配置兼容 global.js：全局常量配置 route.js：总路由 依赖各个功能模块路由 各个模块路由依赖对应的控制器模块，各自控制器模块依赖服务模块。 angular.module('guidePage.services', []) .factory('GuidePageFty', function($http,$q) &#123; return &#123; get:function()&#123;&#125;, postdata:function()&#123;&#125;, deletedata:function()&#123;&#125; &#125;;&#125;);]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>Ionic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS笔记]]></title>
    <url>%2F2017%2F04%2F08%2FAngularJS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下AngularJS。 简介AngularJS 是一个 JavaScript 框架。它可通过 &lt;script&gt;标签添加到 HTML 页面。 AngularJS 通过 指令 扩展了 HTML，且通过 表达式 绑定数据到 HTML。 基础模块（module）AngularJS很重要的一个特性就是实现模块化编程，我们可以通过以下方式创建一个模块，对页面进行功能业务上的划分。 也可以将重复使用的指令或过滤器之类的做成模块便于复用。 注意必须指定第二个参数，否则变成找到已经定义的模块。var myApp = angular.module("MyApp", []); 控制器（controller）调度逻辑的集合。 控制器常用注入：’$scope’, ‘$location’, ‘MainService’, ‘$routeParams’,’$http’,’$window’,’$document’ var app = angular.module('myApp', []);app.controller('personCtrl', ['$scope',function($scope) &#123; $scope.firstName = "John"; $scope.lastName = "Doe"; $scope.fullName = function() &#123; return $scope.firstName + " " + $scope.lastName; &#125;&#125;]); 控制器的三个主要职责： 为应用中的模型设置初始状态 通过$scope对象把数据模型或函数行为暴露给视图 监视模型的变化，做出相应的动作 代码示例：$scope.$watch(‘totalCart’, calculateDiscount);$scope.$watch('user.username', function(now, old) &#123; // 当user.username发生变化时触发这个函数 // console.log('now is ' + now); // console.log('old is ' + old); if (now) &#123; if (now.length &lt; 7) &#123; $scope.message = '输入格式不合法'; &#125; else &#123; $scope.message = ''; &#125; &#125; else &#123; $scope.message = '请输入用户名'; &#125; &#125;); $scope（上下文模型） 视图和控制器之间的桥梁 用于在视图和控制器之间传递数据 利用$scope暴露数据模型（数据，行为） 谷歌插件：AngularJS batarang调试$scope 表达式使用表达式把数据绑定到html，类似 ng-bind 指令。 表达式可以包含文字、运算符、变量，支持过滤器。 语法：&#123;&#123;expression&#125;&#125; 建议更多的使用指令 指令AngularJS 有一套完整的、可扩展的、用来帮助 Web 应用开发的指令集。 在 DOM 编译期间，和 HTML 关联着的指令会被检测到，并且被执行。 在 AngularJS 中将前缀为 ng- 这种属性称之为指令，其作用就是为 DOM 元素调用方法、定义行为绑定数据等。 简单说：当一个 Angular 应用启动，Angular 就会遍历 DOM 树来解析 HTML，根据指令不同，完成不同操作。 指令如下： ng-app ng-app指令用来标明一个AngularJS应用程序 标记在一个AngularJS的作用范围的根对象上 系统执行时会自动的执行根对象范围内的其他指令 可以在同一个页面创建多个ng-app节点 ng-cloak添加一下样式，并且在body中添加此属性。&lt;style&gt; [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak, .ng-hide:not(.ng-hide-animate) &#123; display: none !important; &#125; ng\:form &#123; display: block; &#125; .ng-animate-shim &#123; visibility: hidden; &#125; .ng-anchor &#123; position: absolute; &#125;&lt;/style&gt;&lt;body ng-app ng-cloak&gt; ng-repeatng-repeat指令用来编译一个数组重复创建当前元素，如果数组中有重复的项，则需要早后面加track by $index如&lt;ul class="messages"&gt; &lt;li ng-repeat="item in messages track by $index"&gt; &#123;&#123;item&#125;&#125; &lt;/li&gt;&lt;/ul&gt; ng-classng-class指令可以设置一个键值对，用于决定是否添加一个特定的类名，键为class名，值为bool类型表示是否添加该类名。&lt;ul class="messages"&gt; &lt;li ng-repeat="item in messages track by $index" ng-class="&#123;red:item.read&#125;"&gt; &#123;&#123;item.content&#125;&#125; &lt;/li&gt;&lt;/ul&gt; ng-show/ng-hideng-show/ng-hide指令会根据属性值去确定是否展示当前元素，例如ng-show=false则不会展示该元素。&lt;ul class="messages"&gt; &lt;li ng-repeat="item in messages track by $index" ng-show="item.read"&gt; &#123;&#123;item.content&#125;&#125; &lt;/li&gt;&lt;/ul&gt; ng-link/ng-srcng-link/ng-src指令用于解决当链接类型的数据绑定时造成的加载BUG，如&lt;!-- 浏览器在解析HTML时会去请求&#123;&#123;item.url&#125;&#125;文件 --&gt;&lt;img src="&#123;&#123;item.url&#125;&#125;"&gt;&lt;!-- 可以使用ng-src解决该问题 --&gt;&lt;img ng-src="&#123;&#123;item.url&#125;&#125;"&gt; ng-switch&lt;body ng-app&gt; &lt;select ng-model="selected"&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;option value="3"&gt;3&lt;/option&gt; &lt;/select&gt; &lt;div ng-switch="selected"&gt; &lt;div ng-switch-when="1"&gt; 你选择的是1 &lt;/div&gt; &lt;div ng-switch-when="2"&gt; 你选择的是2 &lt;/div&gt; &lt;div ng-switch-when="3"&gt; 你选择的是3 &lt;/div&gt; &lt;div ng-switch-default&gt; 你什么都没选 &lt;/div&gt; &lt;/div&gt; 其他常用命令 ng-model ng-click ng-dbclick ng-if：指是否存在DOM元素 ng-checked ng-selected ng-disabled ng-readonly ng-blur ng-change ng-focus ng-submit 自定义指令var demoApp = angular.module('demoApp', []);// 第一个参数是指令的名字，第二个参数任然应该使用一个数组，数组的最后一个元素是一个函数// 定义指令的名字，应该使用驼峰命名法demoApp.directive('itcastButton', [function() &#123; // 该函数应该返回一个指令对象 return &#123; template:'&lt;input type="button" value="itcast" class="btn btn-lg btn-primary btn-block" /&gt;' &#125;;&#125;]);&lt;!-- html中使用 --&gt;&lt;itcast-button&gt;&lt;/itcast-button&gt;//详细说明demoApp.directive('breadcrumb', [function() &#123; // Runs during compile return &#123; // 指定当前指令的类型什么样的 // restrict: 'EA', // // E = Element, A = Attribute, C = Class, M = Comment // template: '', // 模版字符串 templateUrl: 'tmpls/breadcrumb.html', replace: true, // transclude: true, &#125;;&#125;]);// demoApp.directive('btn', [function() &#123;// return&#123;// scope:&#123;// primary:'@',// lg:'@',// block:'@',// &#125;,// template:'&lt;button class="btn &#123;&#123;primary==\'true\'?\'btn-primary\':\'\'&#125;&#125;"&gt;button&lt;/button&gt;'// &#125;// &#125;]);// demoApp.directive('btn', [function() &#123;// return &#123;// // 指令对象的transclude必须设置为true才可以在模版中使用ng-transclude指令// transclude: true,// replace: true, // 替换指令在HTML中绑定的元素// template: '&lt;button class="btn btn-primary btn-lg" ng-transclude&gt;&lt;/button&gt;'// &#125;;// &#125;]); AngularJS过滤器过滤器的主要用途就是一个格式化数据的小工具，一般用于服务端存储的数据转换为用户界面可以理解的数据。 currency格式化数字为货币格式。&#123;&#123; (quantity * price) | currency &#125;&#125; filter从数组项中选择一个子集，其中test是我们在文本框中输入的值进行过滤。&lt;p&gt;&lt;input type="text" ng-model="test"&gt;&lt;/p&gt;&lt;ul&gt; &lt;li ng-repeat="x in names | filter:test | orderBy:'country'"&gt; &#123;&#123; (x.name | uppercase) + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; lowercase格式化字符串为小写。&#123;&#123; lastName | lowercase &#125;&#125; orderBy根据某个表达式排列数组。&lt;ul&gt; &lt;li ng-repeat="x in names | orderBy:'country'"&gt; &#123;&#123; x.name + ', ' + x.country &#125;&#125; &lt;/li&gt;&lt;/ul&gt; uppercase格式化字符串为大写。&#123;&#123; lastName | uppercase &#125;&#125; 其他&#123;&#123;&apos;itcast.cn,itcast.com,itheima.com&apos; | limitTo:10:10&#125;&#125;&#123;&#123;p1 | json:8&#125;&#125;&#123;&#123;1288323623006 | date:&apos;fullDate&apos;&#125;&#125;&#123;&#123;1112123.141592635 | number:10&#125;&#125; 自定义过滤器&lt;p&gt;你&#123;&#123;weight|weight&#125;&#125;&lt;/p&gt;angular.module('app', []) .filter('checkmark', function() &#123; return function(input, style) &#123; style = style || 1; // 短路运算符 switch (style) &#123; case 1: return input ? '\u2713' : '\u2718'; case 2: return input ? '\u2714' : '\u2719'; &#125; &#125;; &#125;) .filter('weight', function() &#123; return function(input) &#123; if (input &gt; 100) &#123; return '太胖了'; &#125; else &#123; return '太瘦了'; &#125; &#125;; &#125;); AngularJS表单AngularJS服务 公用（公共）的业务逻辑集中存放的一段代码 主要用于对重复业务的封装，重用 一般主要封装针对于Model的CRUD 创建服务var myApp = angular.module('MyApp', []);// 通过factory方法创建一个公用的servicevar userService = myApp.service('UserService', function() &#123; var users = &#123; 1: 'zhangsan1', 2: 'zhangsan2' &#125;; return &#123; getUser: function(id) &#123; return users[id]; &#125;, addUser: function(id, name) &#123; users[id] = name; &#125;, &#125;;&#125;); $location服务类似window.location对象，使用$location.path()获取url中锚点值后的字符串。 $http服务$http服务是AngularJS中处理AJAX的服务。// Simple GET request example:$http(&#123; method: 'GET', url: '/someUrl'&#125;).then(function successCallback(response) &#123; // this callback will be called asynchronously // when the response is available &#125;, function errorCallback(response) &#123; // called asynchronously if an error occurs // or server returns response with an error status. &#125;);// getvar app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $http) &#123; $http.get("welcome.htm").then(function (response) &#123; $scope.myWelcome = response.data; &#125;);&#125;); $timeout服务var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $timeout) &#123; $scope.myHeader = "Hello World!"; $timeout(function () &#123; $scope.myHeader = "How are you today?"; &#125;, 2000);&#125;); $interval服务var app = angular.module('myApp', []);app.controller('myCtrl', function($scope, $interval) &#123; $scope.theTime = new Date().toLocaleTimeString(); $interval(function () &#123; $scope.theTime = new Date().toLocaleTimeString(); &#125;, 1000);&#125;); AngularJS路由请求过来，判断用哪个控制器来处理。&lt;div ng-view&gt;&lt;/div&gt;&lt;script id="a_tmpl" type="text/ng-template"&gt; &lt;!-- 只有type="text/javascript"的script节点才会被当做JS执行 --&gt; &lt;!-- script中的内容就算不能执行，也不可以显示在界面上 --&gt; &lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('app', ['ngRoute']); app.config(['$routeProvider', function($routeProvider) &#123; $routeProvider // 某一类特定地址 .when('/students/:name?', &#123; controller: 'StudentsController', templateUrl: 'a_tmpl' &#125;) .when('/a', &#123; controller: 'AController', templateUrl: 'a_tmpl' &#125;) .when('/b', &#123; controller: 'BController', templateUrl: 'a_tmpl' &#125;) .when('/c', &#123; controller: 'CController', templateUrl: 'a_tmpl' &#125;) // 别的请求 .otherwise(&#123; // 跳转到一个地址 redirectTo: '/a' &#125;); &#125;]); app.controller('StudentsController', ['$scope', '$routeParams', function($scope, $routeParams) &#123; $scope.title = '你好' + $routeParams['name'] + '这是A控制器'; &#125;]); app.controller('AController', ['$scope', function($scope) &#123; $scope.title = '这是A控制器'; &#125;]); app.controller('BController', ['$scope', function($scope) &#123; $scope.title = '这是B控制器'; &#125;]); app.controller('CController', ['$scope', function($scope) &#123; $scope.title = '这是C控制器'; &#125;]);&lt;/script&gt; 依赖注入依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。 该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。 AngularJS 提供很好的依赖注入机制。以下5个核心组件用来作为依赖注入： valueValue 是一个简单的 javascript 对象，用于向控制器传递值（配置阶段）：// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 value 对象 "defaultInput" 并传递数据mainApp.value("defaultInput", 5);...// 将 "defaultInput" 注入到控制器mainApp.controller('CalcController', function($scope, CalcService, defaultInput) &#123; $scope.number = defaultInput; $scope.result = CalcService.square($scope.number); $scope.square = function() &#123; $scope.result = CalcService.square($scope.number); &#125;&#125;); factoryfactory 是一个函数用于返回值。在 service 和 controller 需要时创建。通常我们使用 factory 函数来计算或返回值。// 定义一个模块var mainApp = angular.module("mainApp", []);// 创建 factory "MathService" 用于两数的乘积 provides a method multiply to return multiplication of two numbersmainApp.factory('MathService', function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b &#125; return factory;&#125;); // 在 service 中注入 factory "MathService"mainApp.service('CalcService', function(MathService)&#123; this.square = function(a) &#123; return MathService.multiply(a,a); &#125;&#125;); providerAngularJS 中通过 provider 创建一个 service、factory等(配置阶段)。 Provider 中提供了一个 factory 方法 get()，它用于返回 value/service/factory。// 定义一个模块var mainApp = angular.module("mainApp", []);...// 使用 provider 创建 service 定义一个方法用于计算两数乘积mainApp.config(function($provide) &#123; $provide.provider('MathService', function() &#123; this.$get = function() &#123; var factory = &#123;&#125;; factory.multiply = function(a, b) &#123; return a * b; &#125; return factory; &#125;; &#125;);&#125;); constantconstant(常量)用来在配置阶段传递数值，注意这个常量在配置阶段是不可用的。mainApp.constant(&quot;configParam&quot;, &quot;constant value&quot;); 传参和获取参数angular中例如：/:status 控制器注入$routeParams，用$routeParams.status可获取对应参数。 更新url地址参数，匹配路由: 控制器中注入$route,使用$route.updateParams({ category: ‘search’, q: $scope.input })方法可以更新url中的参数。 ionic中例如：/:typeNumber 控制器注入$stateParams，用$stateParams.typeNumber可获取对应参数。 跳转如下： 控制器注入$state。 //用在控制器中$state.go(&apos;goodsList&apos;,&#123;typeNumber:666&#125;);//用在视图中ui-sref=&quot;goodsList(&#123;typeNumber:&#123;&#123;item.typeNumber&#125;&#125;&#125;)”//直接跳转&lt;a href=&quot;#/goodsList/34&quot;&gt;跳转到商品详细页面&lt;/a&gt; 其实$state.go 与ui-sref一样，后面的参数是路由的名称。 项目目录及代码示例一般主页面会有一个&lt;ng-view&gt;&lt;/ng-view&gt;标签，用来放置各类子页面 todomvc只有一个页面，在服务中编写好对应的方法，然后控制器调用并向视图暴露数据和方法。 处理好模块依赖，一般都让主模块依赖控制器模块和服务模块，然后依次编写控制器模块和服务模块。 熟练各种指令，了解获取路由的参数。 项目目录：css app.css //个人定制cssjs app.js //主模块，并且配置路由 controllers.js //控制器，调度逻辑 services.js //各种服务，curd操作index.html // 入口文件 moviecat如果页面布局相似，直接抽象出一个模块公用，在此用了列表模块公用。 项目目录：css app.css //custom stylemovie_list controller.js // 配置路由，写逻辑 view.htmlmovie_detail controller.js view.htmlcomponents auto-focus.js http.js app.js //主模块，并且配置路由。 注意主模块中依赖顺序。主模块中配置常量在控制器里可以直接注入，主模块中定义的控制器要在视图中用指令绑定上去，并且只执行一次，如果需执行多次，请执行$watch()方法监控$scope中暴露出的对应数据。 抽象出的共用模块，配置路由时使用参数的形式：/:category/:page $scope.$apply(); // 跨域请求数据以后，使用此方法将数据绑定到视图。 代码示例1. app.js'use strict';// Declare app level module which depends on views, and componentsangular.module('moviecat', [ 'ngRoute', 'moviecat.movie_detail', 'moviecat.movie_list', 'moviecat.directives.auto_focus', ]) // 为模块定义一些常量 .constant('AppConfig', &#123; pageSize: 10, listApiAddress: 'http://api.douban.com/v2/movie/', detailApiAddress: 'http://api.douban.com/v2/movie/subject/' &#125;) .config(['$routeProvider', function($routeProvider) &#123; $routeProvider.otherwise(&#123; redirectTo: '/in_theaters/1' &#125;); &#125;]) .controller('SearchController', [ '$scope', '$route', 'AppConfig', function($scope, $route, AppConfig) &#123; $scope.input = ''; // 取文本框中的输入 $scope.search = function() &#123; // console.log($scope.input); $route.updateParams(&#123; category: 'search', q: $scope.input &#125;); &#125;; &#125; ]);// .controller('NavController', [// '$scope',// '$location',// function($scope, $location) &#123;// $scope.$location = $location;// $scope.$watch('$location.path()', function(now) &#123;// if (now.startsWith('/in_theaters')) &#123;// $scope.type = 'in_theaters';// &#125; else if (now.startsWith('/coming_soon')) &#123;// $scope.type = 'coming_soon';// &#125; else if (now.startsWith('/top250')) &#123;// $scope.type = 'top250';// &#125;// console.log($scope.type);// &#125;);// &#125;// ]) 2. movie_list.js(function(angular) &#123; 'use strict'; // 创建正在热映模块 var module = angular.module( 'moviecat.movie_list', [ 'ngRoute', 'moviecat.services.http' ]); // 配置模块的路由 module.config(['$routeProvider', function($routeProvider) &#123; $routeProvider.when('/:category/:page', &#123; templateUrl: 'movie_list/view.html', controller: 'MovieListController' &#125;); &#125;]); module.controller('MovieListController', [ '$scope', '$route', '$routeParams', 'HttpService', 'AppConfig', function($scope, $route, $routeParams, HttpService, AppConfig) &#123; var count = AppConfig.pageSize; // 每一页的条数 var page = parseInt($routeParams.page); // 当前第几页 var start = (page - 1) * count; // 当前页从哪开始 // 控制器 分为两步： 1. 设计暴露数据，2. 设计暴露的行为 $scope.loading = true; // 开始加载 $scope.subjects = []; $scope.title = 'Loading...'; $scope.message = ''; $scope.totalCount = 0; $scope.totalPages = 0; $scope.currentPage = page; HttpService.jsonp( AppConfig.listApiAddress + $routeParams.category, // $routeParams 的数据来源：1.路由匹配出来的，2.?参数 &#123; start: start, count: count, q: $routeParams.q &#125;, function(data) &#123; $scope.title = data.title; $scope.subjects = data.subjects; $scope.totalCount = data.total; $scope.totalPages = Math.ceil($scope.totalCount / count); $scope.loading = false; $scope.$apply(); // $apply的作用就是让指定的表达式重新同步 &#125;); // 暴露一个上一页下一页的行为 $scope.go = function(page) &#123; // 传过来的是第几页我就跳第几页 // 一定要做一个合法范围校验 if (page &gt;= 1 &amp;&amp; page &lt;= $scope.totalPages) $route.updateParams(&#123; page: page &#125;); &#125;; &#125; ]);&#125;)(angular);// var doubanApiAddress = 'http://api.douban.com/v2/movie/in_theaters';// // 测试$http服务// // 在Angular中使用JSONP的方式做跨域请求，// // 就必须给当前地址加上一个参数 callback=JSON_CALLBACK// $http.jsonp(doubanApiAddress+'?callback=JSON_CALLBACK').then(function(res) &#123;// // 此处代码是在异步请求完成过后才执行（需要等一段时间）// if (res.status == 200) &#123;// $scope.subjects = res.data.subjects;// &#125; else &#123;// $scope.message = '获取数据错误，错误信息：' + res.statusText;// &#125;// &#125;, function(err) &#123;// console.log(err);// $scope.message = '获取数据错误，错误信息：' + err.statusText;// &#125;); 3. movie_detail.js (function(angular) &#123; 'use strict'; // 创建正在热映模块 var module = angular.module( 'moviecat.movie_detail', [ 'ngRoute', 'moviecat.services.http' ]); // 配置模块的路由 module.config(['$routeProvider', function($routeProvider) &#123; $routeProvider.when('/detail/:id', &#123; templateUrl: 'movie_detail/view.html', controller: 'MovieDetailController' &#125;); &#125;]); module.controller('MovieDetailController', [ '$scope', '$route', '$routeParams', 'HttpService', 'AppConfig', function($scope, $route, $routeParams, HttpService, AppConfig) &#123; $scope.movie = &#123;&#125;; $scope.loading = true; var id = $routeParams.id; var apiAddress = AppConfig.detailApiAddress + id; // 跨域的方式 HttpService.jsonp(apiAddress, &#123;&#125;, function(data) &#123; $scope.movie = data; $scope.loading = false; $scope.$apply(); &#125;); &#125; ]);&#125;)(angular); 4. auto-focus.js自定义指令 (function(angular) &#123; angular.module('moviecat.directives.auto_focus', []) .directive('autoFocus', ['$location', function($location) &#123; // Runs during compile // var path = $location.path(); // /coming_soon/1 // console.log(path); return &#123; restrict: 'A', // E = Element, A = Attribute, C = Class, M = Comment link: function($scope, iElm, iAttrs, controller) &#123; $scope.$location = $location; $scope.$watch('$location.path()', function(now) &#123; // 当path发生变化时执行，now是变化后的值 var aLink = iElm.children().attr('href'); var type = aLink.replace(/#(\/.+?)\/\d+/, '$1'); // /coming_soon if (now.startsWith(type)) &#123; // 访问的是当前链接 iElm.parent().children().removeClass('active'); iElm.addClass('active'); &#125; &#125;) // iElm.on('click', function() &#123; // iElm.parent().children().removeClass('active'); // iElm.addClass('active'); // &#125;); &#125; &#125;; &#125;]);&#125;)(angular); 5. http.js跨域服务 // 由于默认angular提供的异步请求对象不支持自定义回调函数名// angular随机分配的回调函数名称不被豆瓣支持var http = angular.module('moviecat.services.http', []);http.service('HttpService', ['$window', '$document', function($window, $document) &#123; // url : http://api.douban.com/vsdfsdf -&gt; &lt;script&gt; -&gt; html就可自动执行 this.jsonp = function(url, data, callback) &#123; // if (typeof data == 'function') &#123; // callback = data; // &#125; var querystring = url.indexOf('?') == -1 ? '?' : '&amp;'; for (var key in data) &#123; querystring += key + '=' + data[key] + '&amp;'; &#125; var fnSuffix = Math.random().toString().replace('.', ''); var cbFuncName = 'my_json_cb_' + fnSuffix; querystring += 'callback=' + cbFuncName; var scriptElement = $document[0].createElement('script'); scriptElement.src = url + querystring; // 不推荐 $window[cbFuncName] = function(data) &#123; callback(data); $document[0].body.removeChild(scriptElement); &#125;; $document[0].body.appendChild(scriptElement); &#125;;&#125;]);]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SeaJS笔记]]></title>
    <url>%2F2017%2F04%2F06%2FSeaJS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下SeaJS。 // 包在匿名函数里面，避免污染全局变量(function() &#123; var brian_said = 'hello world', ritchie_said_also = 'konicuwa world?'; // 代码！代码！代码！&#125;)(); // 全局变量弥足珍贵，不能用的太豪爽啊var Precious = &#123;&#125;;// module 1Precious.mod1 = (function() &#123; // 写示例敢不敢不再用 hello world？ return &#123; // 公开方法、变量 &#125;&#125;)();// module 2Precious.mod2 = (function() &#123; // 那用日语 ohayo world 行不行？ return &#123; // 公开方法、变量 &#125;&#125;)(); define('console', function(require, exports) &#123; exports.log = function(msg) &#123; if (window.console &amp;&amp; console.log) &#123; console.log(msg); &#125; else &#123; alert(msg); &#125; &#125;;&#125;); seajs.use('console', function(console) &#123; // now you can stop worrying about whether or not `console` is provided. // use it freely! console.log('hello world!'); // well, we need to enhance the `console` module a bit. // for methods like console.warn, and method calls like console.log(msg1, msg2, msg3);&#125;); define('jordan', function(require, exports) &#123; // 可以内联 exports.chamionship = function() &#123; // 乔丹和皮蓬是对好基友 return require('pippen').hasJoined(); &#125;; // 也可以在头部引入 var rodman = require('rodman'); exports.next3 = function() &#123; // 大虫 return require('rodman').hasJoined(); &#125;;&#125;); // 对象define(&#123; foo: 1 &#125;);// 字符串define('hello world'); &lt;!-- more compact way --&gt;&lt;script src="sea.js" data-main="./app"&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RequireJS笔记]]></title>
    <url>%2F2017%2F04%2F05%2Frequriejs%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下RequrieJS。 RequrieJS解决两个问题： 实现js文件的异步加载，避免网页失去响应； 管理模块之间的依赖性，便于代码的编写和维护。 RequrieJS的加载&lt;script src="js/require.js" defer async="true" &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了：&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 主模块的写法上面写的main.js就是主模块代码。// main.js require(['moduleA', 'moduleB', 'moduleC'], function (moduleA, moduleB, moduleC)&#123; // some code here &#125;); require()异步加载moduleA，moduleB和moduleC，浏览器不会失去响应；它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。 模块的加载使用require.config()方法，我们可以对模块的加载行为进行自定义。require.config()就写在主模块（main.js）的头部。参数就是一个对象，这个对象的paths属性指定各个模块的加载路径。 require.config(&#123; paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125; &#125;); 上面的代码给出了三个模块的文件名，路径默认与main.js在同一个目录（js子目录）。如果这些模块在其他目录，比如js/lib目录，则有两种写法。一种是逐一指定路径。require.config(&#123; paths: &#123; "jquery": "lib/jquery.min", "underscore": "lib/underscore.min", "backbone": "lib/backbone.min" &#125; &#125;); 另一种则是直接改变基目录（baseUrl）。require.config(&#123; baseUrl: "js/lib", paths: &#123; "jquery": "jquery.min", "underscore": "underscore.min", "backbone": "backbone.min" &#125; &#125;); 如果某个模块在另一台主机上，也可以直接指定它的网址，比如：require.config(&#123; paths: &#123; "jquery": "https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min" &#125; &#125;); require.js要求，每个模块是一个单独的js文件。这样的话，如果加载多个模块，就会发出多次HTTP请求，会影响网页的加载速度。因此，require.js提供了一个优化工具，当模块部署完毕以后，可以用这个工具将多个模块合并在一个文件中，减少HTTP请求数。 AMD模块的写法require.js加载的模块，采用AMD规范。也就是说，模块必须按照AMD的规定来写。 具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写：// math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;); 加载方法如下：// main.js require(['math'], function (math)&#123; alert(math.add(1,1)); &#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。define(['myLib'], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 加载非规范的模块理论上，require.js加载的模块，必须是按照AMD规范、用define()函数定义的模块。但是实际上，虽然已经有一部分流行的函数库（比如jQuery）符合AMD规范，更多的库并不符合。那么，require.js是否能够加载非规范的模块呢？回答是可以的。 这样的模块在用require()加载之前，要先用require.config()方法，定义它们的一些特征。 举例来说，underscore和backbone这两个库，都没有采用AMD规范编写。如果要加载它们的话，必须先定义它们的特征。require.config(&#123; shim: &#123; 'underscore':&#123; exports: '_' &#125;, 'backbone': &#123; deps: ['underscore', 'jquery'], exports: 'Backbone' &#125; &#125; &#125;); require.config()接受一个配置对象，这个对象除了有前面说过的paths属性之外，还有一个shim属性，专门用来配置不兼容的模块。具体来说，每个模块要定义（1）exports值（输出的变量名），表明这个模块外部调用时的名称；（2）deps数组，表明该模块的依赖性。 比如，jQuery的插件可以这样定义：shim: &#123; 'jquery.scroll': &#123; deps: ['jquery'], exports: 'jQuery.fn.scroll' &#125; &#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD规范]]></title>
    <url>%2F2017%2F04%2F03%2FAMD%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下AMD规范。 目前，通行的Javascript模块规范共有两种：CommonJS和AMD。 有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。但是大家必须以同样的方式编写模块。 CommonJSnode.js的模块系统，就是参照CommonJS规范实现的。在CommonJS中，有一个全局性方法require()，用于加载模块。 加载模块，调用模块的方法示例：var math = require('math'); math.add(2,3); // 5 AMDAMD也采用require()语句加载模块，但是不同于CommonJS，它要求两个参数：require([module], callback);require(['math'], function (math) &#123; math.add(2, 3); &#125;);]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息图表笔记]]></title>
    <url>%2F2017%2F03%2F10%2F%E4%BF%A1%E6%81%AF%E5%9B%BE%E8%A1%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[信息图表的相关知识总结。 什么是信息图表信息、数据等的可视化表达。 为什么信息图表这么受欢迎 我们天生喜欢读图，信息图表有与生俱来的吸引力。 我们注意力有限，信息图表能提高阅读效率。 为什么你应该学信息图表时代刚需工作离不开信息图表。 竞标提案借助信息图表，用数据说服客户。 产品发布借助信息图表，形象介绍产品功能，加深用户形象。 业务分析借助信息图表，迅速解读数据，协助快速决策。 年终总结借助信息图表，展示业绩，规划未来。 学习需要信息图表 读书笔记借助信息图表，整理内容逻辑，回顾书中精髓，温故知新。 时间管理借助信息图表，把抽象的时间可视化，便于管理，提高效率。 毕业答辩借助信息图表，展示研究数据，构造理论模型，为论文加分。 简历制作借助信息图表，展示自我，吸引眼球。 生活处处可见信息图表 理财 备忘 出行 看新闻 求职神奇信息图表风格简历，会让HR眼前一亮。 其实就是平常扁平化那一套：用图标，形状色块，非衬线字体。 做成长图可以在多个渠道传播。 逆袭神器对常见信息的可视化解读，分享，得到认可，逆袭人生。 一种情怀做表吧！ 如何制作一张好表信息图表的构成信息图表=信息（故事内容）+图表（可视化设计） 所以好的信息图表就是好的内容和设计构成的。 内容基础信息数据+逻辑框架 设计图标、图表、文字描述 所以，信息图表和PPT一样，依然是结构化思考，视觉化表达。 信息图表的制作工具PS? AI? PPT就可以啦！一页一页做完，导出长图，不就OK啦！ 信息图表的制作流程领导决定要做-确定内容-开始收集材料-问同事拿资料-加班-改 制作信息图表的五大原则图表合适，准确呈现选对表别看脸，图表不是装饰。不要手绘图表，确保数据准确，符合实际。 每个图表都有自己擅长的逻辑关系： 饼图：比例关系 折线：趋势 柱形图：分布关系 散点图：相关性 雷达图：综合关系 设计简约，风格统一简约至上，不要为了炫技而设计。统一风格，让整体视觉一气呵成。 使用主题配色，统一设计元素风格。 适当创新，吸引眼球怎样让图表活起来？最常用的两种方法： 关联 关联实物加深认知：把饼图和可乐瓶盖关联起来 关联实物加深理解：不同品牌咖啡因含量比较用咖啡杯实物 关联实物营造场景：在柱状图和山峰结合，营造雪山场景 类比 实物类比形象生动：把网速与实物（飞机，火箭等）结合 实物类比赋予联想：用各种实物类比尺寸（罩杯等） 适当关联，注意画面美观不违和。适当类比，切勿多此一举喧宾夺主 内容精简，避免冗余读者不关心的内容，删删删。 重点突出，结论秒懂信息图表绝不是数据的简单罗列，你还要告诉读者这个图反映了什么问题。 把结论强调在图上，这样读者就一目了然了。 如何突出重点？ 1. 强调法 2. 拆分法 如果你觉得每一个内容都是重点，都想突出，那就进行拆分，保证一个画面只讲一个内容，防止内容堆在一起互相干扰。 利用属性的场景进行拆分，例如马路。 利用熟悉的事物进行拆分，例如元素周期表 利用流程协助拆分 3. 粗暴法 直接告诉读者这就是重点。 粗暴的标出（地图位置） 粗暴的圈出：直接圈出重点，结论一目了然。 如何制定信息图表的内容讲好一个故事。 第一步：从零开始-确定目标、提出问题 第二步：顺藤摸瓜-解答问题、寻找信息 第三步：统领全局-整理逻辑、画出框架 第四步：局部处理-确定数据的可视化形式 从零开始-确定目标、提出问题做信息图表首先要确定目标，这个目标可以是一个热点、科普等。 围绕确定好的目标，提出问题，是做信息图表必不可少的一步。 提问题的原则：6W原则。数量为王，就是问题不论深浅都要提出来。 第二步：顺藤摸瓜-解答问题、寻找信息定性问题对于跟数据没有太大关系的问题，我们可以采用下面的方法（what why how）。 百度、谷歌、维基百科、调查问卷、采访行业专家 定量的问题需要用数据进行说话的部分。公司给了很多数据或没数据，没数据去哪找？ 首先你要确定，自己需要的数据所在的领域：微博？微信？互联网？然后就到对应的网站去收集。 找微博方面的数据：知微，并且有相关chrome插件。 微信图文数据：微信公众平台后台，如果要找别人公众号图文数据，到这新媒体排行榜 淘宝数据：淘宝指数 互联网行业数据：CNNIC与艾瑞 某个关键字相关数据：百度指数 找数据时可以看看同类信息图表的数据来源。 第三步：统领全局-整理逻辑、画出框架 第四步：局部处理-确定数据的可视化形式分析：这组数据用哪个表比较合适，这段信息是否需要使用图标，这组文字是否需要进行设计。 在纸上把它们画出来，这样一个信息图表的雏形就出现了。 ICON的N中睡法为何要用图标信息图表里用的时候有逼格。 如何获得现成的图标那些网站下载去，就不列举了。 如何三分钟打造一枚图标 PPT形状编辑法 AI素材法 AI描摹法：也可以用vector软件 重点说一下描摹法，在AI中描摹-扩展-去白底 用软件，可以在纸上画一个图标，拍照截图，进行处理。 三招变图表大神第一招：脱掉脱掉背景：杂乱的背景，刺眼的背景脱掉元素：多余的图例、坐标轴、网格线、边框线脱掉效果：渐变、描边、阴影脱掉字体： 难看的宋体脱掉颜色：系统默认颜色 第二招：复制黏贴插入图表，比如是柱形图，复制一个图标，选中柱形，黏贴就行了，如果被拉伸了，填充选择层叠就行了。 第三招：安装office2013利用各种插件。 三招教你文字设计信息图表文字排版术方式一：大小搭配（包括文字粗细） 通过大小对比来突出重点是个简单却有效的方式。 方式二：颜色对比 通过颜色的对比不仅能让信息图表的重点内容突出，还能让信息图表更有设计感。 方式三：位置和旋转 根据对内容的理解，改变文本位置和适当旋转，会让排版不乏味。 文字图形化，让文字也变得秒懂文字可以和形状进行布尔运算。 拆字，与图形组合，编辑锚点，多样化。 多思考联想标题中那个字或词可以进行设计。 只用文字也能做信息图表-文字云大法基础图表的逆袭-柱形图基础图表的逆袭-饼图]]></content>
      <categories>
        <category>职场办公</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[职场笔记]]></title>
    <url>%2F2017%2F03%2F01%2F%E8%81%8C%E5%9C%BA%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[进入职场需要了解的事情总结。 工具可以用在哪些地方，编程语言可以用来做什么，每个碎片时间可以用来做什么事等等，都要非常熟悉，这样才能在不同场合从容利用它们。 办公用品整理其实就是分类管理，常用的放到桌面看得见的地方，可以用些快递盒对抽屉空间进行划分。 办公桌面整洁 办公用品收纳 办公素材如何放 文件存档诀窍 其他 管理电脑文件个人文件夹：电影（电影首字母做文件名） 图片（年份文件夹-日期（加主题关键字）文件夹-图片文件） 项目文件夹命名：项目开始日期-项目名-描述-结束日期 文件命名：日期-文件名-描述（未提交or完整版）-作者-版本号 职场文件夹：正在进行的项目 参考资料 存档 桌面整洁、快速启动软件、文件下载放哪、搜索文件、文件夹命名、工作文件目录结构、云同步办公（远程控制） 电子邮件使用收件人等、主题、称呼、开场白、事实项、致谢、签名档。 邮件管理：正在处理、存档、临时文件（没份邮件可以加个标签） 时间管理互联网时代，我么拥有大量碎片化时间 你对时间敏感吗 碎片时间你能干什么 用碎片时间完成大块工作 为一件事找到多重目标 建立较长周期的时间视图 不要什么事都自己一个人做 对时间敏感才能管理好时间，设置做每件事的时间，定闹钟提醒自己。没事自问自答现在几点了，训练自己。 碎片化时间：对每个碎片化时间思考自己能做些什么事？针对不同场合为这些时间安排做相符合的事。 时间管理的秘密就是为时间预设各种用途，供自己选择，并提前做好准备。 固定的时间，固定的地点，做固定的事。串联碎片化时间完成大块事。 专注做事的3个条件：时间、空间、目标 很多个小目标，每次专心做这一件事，做完在进行下一个。 将任务分成不同大小的任务单元完成。为碎片时间提前做好准备。 写作一般能分成两个阶段：构思+码字，前期收集整理资料，搜索相关主题文章，保存可用素材，阅读思考一篇素材，构思一段文字写法。然后，列好提纲，码文章。 集中注意力，一次只做一件事，一次做完，不留尾巴。 为一件事找到多重目标，然后集中注意力一个一个完成。比如等车记站牌、算时间、看路线等比如阅读杂志，看标题、封面、文章、广告等，从中学习到不同的知识。 睡觉前列举明天的待办清单。 用日历表管理每周时间 日历表长的话，就是月时间管理 每天的待办清单根据日程表来列举 我们每年都会定个目标，那么我们就要对年时间进行拆分，每月要做哪些事，然后对应每天要做多少事，这些都用日历表和待办清单分配时间。 不要什么事情都自己一个人做： 分包：借助资源的能力（找人分担，专业的人做专业的事） 外包：借助别人的专业能力（花钱找人办事） 众包：借助分众的力量 如何养成擅用资源的能力？ 为身边的每一个人找到可以合作的三种用途 为每件事想三种可能的内部资源和外部资源 为每一种需要的资源积累可以用来交换的牌 职场笔记法职场笔记不同于学生时代的课堂笔记，职场笔记记录每天要做的琐碎事务，课堂记录的详细笔记重点是要记忆。 便利贴灵感要第一时间记录，记录继续忙手里的事情，事后，在进一步思考。 记录是执行的第一步，别只空想，将所想的事记录下来然后采取行动。 按最小单位记录更可能被执行。记录的事情要具体，这样才有利于执行。 笔记放在越碍眼的位置越有效。 记录的意义在于尽快处理，处理完后，丢掉笔记。 笔记本记笔记： 挑出有价值的便利贴，贴到笔记本里。 在空白处复述事情的前因后果。 扩展，写下细枝末节和所思所想。 总结，写下成功经验或反省感悟。 日报/周报记录工作流水账。 三步学会康奈尔笔记法： 抄板书、写要点、做总结。 记录，就是将原文或原材料抄到右侧区域。 简化和背诵，就是归纳要点和复述中心思想。 思考和复习，就是写我的感悟和未来的行动。 周报日报如何写？ 本周我做了那些事：1 2 3 4 列举下来 关键几点：1 2 3 列举 我的感悟：成功的经验或反省的感想未来会怎么做：未来我要…… 如果每天写待办清单，就会很清楚知道每周干了什么。 会议笔记画出会议席位图、用录音笔全程录音、把会议内容录到模板里。 搜商只要是搜索引擎能回答的，就不要麻烦人！ 4步，搜出自己想要的答案： 搞清楚自己到底想要问什么（具体化出来对应问题） 为每个问题分别搭配”核心关键词+扩展关键词“ 搜索原来网上已经有现成的回答。 用云笔记保存有用的信息专业就业分析网站 想找到好工作，五步搜索帮助你： 在求职网站搜索职业岗位，挑选中意的招聘信息。 整理出该公司招聘要求的5要素 搜索该公司的网站、新闻；手机搜索它的微信公众号 用搜索关键词思维写简历的标题（应聘前端工程师擅长移动端开发） 依据HR的关注度，由强到弱完善自己简历内容 不会就学，缺什么补什么，学会再战。 没经历就攒经历，缺什么补什么（实习攒经历） 用联想关键词给自己打上能加分的标签 五步建立自己的网络搜索影响力： 确定平台 内容填充 行业论坛交流 百度知道知乎 影响力建立 个人品牌建立其实不难，难在执行力。 想了解一个公司是否靠谱，只需要六步： 先搜索招聘网站，查一查该公司的信息公司成立的早，有官网，当然加分 工商局工商注册查询，看看公司是否存在对比招聘信息和工商局注册信息 用公司名称+骗子 传销等搜索，查查有没有大量负面消息 搜公司新闻：先看公司官网新闻，再搜百度新闻 搜公司的负责人、领导人、投资人能在百度上搜索到的企业负责人的消息，也反映了企业实力 到知乎搜索“如何评价XXX公司？” PPT模板搜索： 演界网、PPTstore、officePlus等 年终总结 filetype:ppt 关键词：韩国 TG ppt 百度图片 关键词： asadal ppt 图片搜索，去收集的外国网站，用英文搜索。 快速搞定工作文档： 方法一：直接搜索对应关键词 方法二：直接在百度文库中搜索（关键词+filetype:doc） 方法三：网盘搜索文件 学会搜索，干货长文随便写： 第一招：写微信长文没思路？搜搜同行们都在写什么用搜狗的微信搜索。 第二招： 有话题，但不会写，看看历史上同类话题怎么写 第三招：没有话题，就写历史上的今天百度百科，搜索今天的日期，能看到历史上今天的重要事件和出生人物。 从搜索结果中挑出关键词与自己话题关键词组合即可开写，若还不会写，用这些关键词搜索微信文章，找素材。 文章标题怎么起？ 搜狗微信搜索对应关键词，看别人怎么写标题。 手机微信搜索朋友圈，看看吸引的标题怎么写。 今日头条搜索 理财 理财的开始就是分清收支情况。 一切进入到口袋的都算收入。 收入不要单一，用好生活中的优惠。 理财从记账开始：手工、Excel表、APP 拒绝无聊又花钱的约会、不做手机控，拒绝时间被碎片化。 碎片时间学理财知识，社区关注达人，买书等。 离不开的三个顾问：医生、律师、理财师 未完待续… 职场礼仪 学通讯录玩转Excel 高效电话沟通 高效职场会议 办公设备 办公用品采购 发票报销 收发快递 简历 面试]]></content>
      <categories>
        <category>职场办公</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PPT笔记]]></title>
    <url>%2F2017%2F02%2F20%2Fppt-note%2F</url>
    <content type="text"><![CDATA[PPT学习过程的记录。 四步变身高富帅PPT我们每次得到的都是一个word文档，根据文档来设计PPT，所以要仔细阅读文档，把握文档的大纲结构、要点，以及相关内容。 简单说下我做PPT的思路：缕清内容大钢结构，根据金字塔原则，对要点进行罗列。找出各部分内容之间的逻辑结构。搞清楚各部分内容需要如何展示（可以画个草图简单布局，或参考其他的模板） 开搞PPT，先整主题（字体，颜色），母版，板式，封面，封底，目录，接着各部分内容先放到页面上，然后，用逻辑图-图文-表进行内容的展示设计。 字体描述：不超过三种，统一，宋体扔掉，不会都用微软雅黑。 方法：全部换为微软雅黑（替换字体选项） 标题正文对比描述：颜色对比，字号对比，间距，字体，加粗否 方法：加大字号，加粗（或换色） 配色描述：不超过三种，logo取色，模板取色，配色收集 方法：经典红黑搭配，大标题红底白字，小标题红字，正文黑字 配图图文比例，选图与主题风格一致，高清 方法：选择和内容、颜色相关的图片，注意图文对齐（参考线，智能参考线） 联想思维搜图、英文搜、查相似 四步快速标准化长文档 word转PPT：同级段落转成PPT大纲，PPT里也有大纲视图。快速查看每一页的核心观点。 统一模板（主题） 统一字体（全局替换或大纲视图，简单排版） 统一颜色（取色-设置-格式刷） 四步做好PPT段落排版 分层对齐（两端对齐，段落块间距拉开） 提炼段落小标题，添加项目符号可以为图标（每一段的内容提炼出局部小标题，内容分条，每一条的距离调整好） 调间距 正文设置缩进 弄个色，加个图 自定义字体设计-替换-安装-嵌入-存成图 中文搭配：微软雅黑、方正粗倩（粗宋）+雅黑（政府学校公务场合）、海报体（标题体）+雅黑（海报广告）、中国风、文艺 英文搭配：impact华文细黑 字体突出、加特效、填充图片纹理等 字体创意：字体弯曲三维等设置、字体设计、字体与人物线条搭配 字体风格：多用、多看别人的作品、积累各种风格字体 字体管家：管理字体，下载安装字体，可以预览文字对应字体效果URL：求字体网、找字网 别人预览字体不丢失：嵌入、打包、合并形状、存图 艺术字：文本效果-变形-配合形状相交合并等 线条常用的设置方法，以及线条类别 用途：引导视线、划分阅读区域、串联不同对象（跨页面串联）、标注重点、和形状组合传递各种感觉 要点：右键设置默认线条、渐变线条（射线，两侧为白，中间色透明度设置、凹凸线条（两条不同深浅线条叠加在深色背景）、画复合线（宽度12磅）、虚线（1.5磅）、对形状运用边框线。 表格表格框线参数：颜色、粗细、线型、边框类型 设置表格底纹、效果 表格美化套路：默认表格-表头与表内设置区别度高的颜色-修改框线-表头单元格设置凹凸效果-表格设置阴影-各种填充 先设置边框颜色在设置边框类型。 设置表格背景是整个表格背景，单元格可以在设置，不干扰，设置形状格式里的是设置单元格背景，以及上面菜单栏也是。 为表格（单元格）设置图片背景时，要把图片裁剪为和表格相同大小 smart图形使用方式：先对已有文本提炼-修改，删除，敲回车以及内容层级，得出小标题加内容条的格式-记得内容要都在一个文本框内。然后选中转为smart图形，选一个布局，因为里面的都是图形，所以可以更改形状，填充，样式，线性啥的。 smart的图片布局：PPT的任何形状填充图片要比例一样活大小一样，不然被拉伸或压缩，可以平铺纹理，设置缩放，设置位置把图的中心放到中央。 图片分离术：smart图形右击取消组合，整个选中，在smart里选中形状ctrl+cctrl+v在下面就会新增一个 扁平化形状玩法-填充-样式，画icon、折纸、形状组合等于对齐的使用形状与图形相交要先选图片。 手绘多边形工具就是PS的钢笔工具，编辑形状顶点，调节锚点，右击更改锚点类型（平滑锚点、角部锚点、直线锚点）直线锚点手柄不一样长，平滑的一样长。照着图片用多边形工具画，画完调节锚点，最后加特效（发光？） 文字图形相交-填充图片，多边形绘画，做logo艺术字 图片处理基本：托选选中多个对象，窗格图层概念，复制 处理方法：裁剪、去背景、变色、效果、样式 裁剪为各种形状，图片可以变色 图片创意，在PS里分分钟，就是抠图（主体），背景去色或虚化，把主体放里面。 图片放到白色矩形上，一定角度放置。 形状用幻灯片背景填充。 图片容器：表格容器、线条容器、形状容器、样式容器 表格填充图做图片海报 小图片美化：补色（背景取图片颜色，纯色，渐变啥的）、点缀（与形状组合出win8效果）、阵列（多个小图裁剪为形状，一起排列） 小图裁剪为三份，除主体外，那两份拉伸做背景。 大图美化：文本框半透明、图片加渐变色块、图片加上标签、文字融为图片。 透明与渐变微渐变风格，全图形PPT，镂空，磨砂玻璃。 PPT图表类型：柱形图、条形图、饼图、环形图、折线、散点 图表：将信息简洁直观地呈现给受众。 插入方法：插入图表-选择类型-编辑数据 图表三步法： 图表选用 确定主题（提炼图表标题） 找出关系（数据之间的关系） 确定图表（根据数据相对关系确定图表类型） 输入数据图表中没用的数据删除掉（蓝色区域为数据有效区域，可以托大概右下角选取有效区域），表格列标题为柱状图表的横轴，行标题为图表的纵轴。 美化图表 调整字体 调整布局 图表设计-图表布局-添加图表元素（数据标签、趋势线） 或直接在图表上的加号里选择添加删除相关内容 修改配色 调整细节（多余元素、单位） 换个图表试试（图表设计-更改图表类型-饼图） 为饼图标注百分比（在数据上右击设置格式– 标签选型内勾选百分比） 爆炸分离饼图：单击饼图，双击需要拖动的块，直接左键拖动就行，当然也可以设置具体数值（右击-格式设置搞出来） 条形图数据展示最好为多到少即为F型（编辑数据-数据降序） 图表去燥 删除背景-删除背景墙-删除多余图示-删除多余标题-删除多余边框-减少颜色使用突出强调数据-调整字体-淡化数据标签突出数据-删除多余网格线-删除多余坐标-把数据标签放到数据条内。 图表变色强化 用颜色，形状等将关键数据与普通数据区分开来。 图表动画 在动画效果选项里设置序列按类别。 图表样式 PPT2013内置的图表样式 PPT动画分类：切换动画（A页到B页的过度动画）、页面动画（进入、强调、退出、路径） 换页动画（切换动画）切换种类试一试-效果选项设置需要的方向等-切换声音-持续时间-单击切换or自动播放 作用：吸引眼球（帘式，最好用在开头结尾，别太多）、引导视线（推进-擦除等）、展示逻辑（推进等） 页面切换三步法： 梳理逻辑整个PPT的框架结构（思维导图） 降维排序二维变一维，线性顺序结构图（讲故事一样用线索串起来） 设计排版添加引导链接元素，设定切换动画 ## 页面动画动画菜单的使用操作 选中对象-挑选动画-效果选项-动画窗格-设置开始方式-时间（设置完动画，点击添加动画才能增加动画，不会替换前面的动画） 插入多媒体步骤：插入视频-裁剪长度-标牌框架-设置样式-美化装饰 插入视频 插入音频（字幕音频同步方法）音频就是个动画 板式母版、板式、积累、看好的作品 在板式里用占位符做的就是模板 多积累，就可以心中有版 方法： 神奇色快法（信息吉木图）覆盖色块：用形状覆盖页面上的图形、文本、图像（去除页面无关元素） 对齐色块：大色块切割出标题、内容、对齐色块 套用板式：套用常见板式，填入素材 四步法：最早的四步法 交互式PPT超链接、趣味答题]]></content>
      <categories>
        <category>职场办公</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[word笔记]]></title>
    <url>%2F2017%2F02%2F16%2Fword-note%2F</url>
    <content type="text"><![CDATA[word学习过程的记录。 快捷键shift+f3选中写的英文，在全大写、首字母大写、小写间切换。 f4 ctrl+* ctrl+= 自定义快速访问工具栏等。 选择文本ctrl+鼠标左键选择一句文本 鼠标定位到相应文本出，到选择选项点击选择格式相似文本。 设置缩进空格法、标尺法、格式刷（设置好一个段落，直接刷）、F4重复上次设置的缩进。 替换操作批量删除文字、删除空格、删除空行。 替换中使用通配符*：替换时选中通配符，勾选通配符时，特殊格式里的选项是不同的。 页面空白（空格）：全角空格（方框）、半角空格（点）、tab缩进（箭头） 特殊格式中的空白区域选项（空格）可以替换掉后两个。空行、空段在特殊格式里找到多次替换即可（两个替换一个） 填空题：设置一个内容，直接格式刷，或者把所需替换文字，在替换中设置一个格式，然后替换为设置另一个格式。 替换和替换为里面设置表达式，可以给手机号打码，还有很多用法。 文档合并多个文档合并为一个文档方法： 新建一个文档，点击插入-对象-文件中的文字，选中六个文件，插入。 顺序不对的话：导航窗格可以拖动调整顺序，每个文件命名时前面加一个序号如01,递增。 更新问题：插入时，选插入链接，这样在源文件更改后，到总文件里的块上，右击选更新域就行了。 一些小问题微软雅黑行距问题。 找符号：键盘输入（中英文对应符号不同）、插入符号（里面会显示常用符号，选中普通文本选项，找子集，获取所需符号）wingdings字体，输入法输入。 图片插入被隐藏了：行距设为单倍、文本段落有底色、图片被挡住了微信文章的图片问题：webp图片格式转换，用IE，搜狗的微信搜索看微信文章。改一个图片尺寸，然后F4其他图片。 复制黏贴：只保留文本黏贴、选择性黏贴为图片，选中PPT一个页面直接选择性黏贴为图片。 选择性黏贴为链接：将Excel里的表黏贴为Excel工作表对象，这样在word中点击表格会跳到Excel里，更改后，在word里的表格上右击更新链接。 剪贴板功能：会把我们每次复制的东西放到这里，相当于一个小池子，所以我们把所有需要的东西先复制放到这里，然后逐个黏贴所需要的，或者全部黏贴。 一个文本格式给其他文本：双击格式刷、ctrl+shift+c和F4生成文本：=rand(8,8)=lorem(3,3)段落数与句子数 套模板 新建-搜索模板-双击创建 右键单击图片-原地保持大小替换图片 改配色-设计-颜色-点击 美化大师插件-范文库 officeplus模板文档下载 长文档排版秘籍2大问题：文本格式设置好管理起来，自动生成页码、目录等 论文排版编辑步骤设置页面布局、文档需要的样式、套用样式排版、图片图表自动编号、参考文献的标注和引用、设置页眉页脚、生成目录。 整体规划页面整体布局、配置文档样式、多级编号标题 论文需要的样式：我的正文，标题1234，图名，表名，公式。 排版美化细节三线表：顶线、栏目线、底线木有竖线（顶底为粗线）。新建表格-去除边框-自绘三条线注意粗细-注的字号比表格内容字小。 科学的公式：制表位设置公式居中对齐（左上角切换制表符类型，在标尺下面点击添加相应的制表符）把需要重复使用的样式保存下来。 整齐的图片：表格法（设置单元格不随内容自动调整，边距为0） 页眉页码设置分节符作用： 奇偶页不同： 多重页码系统：无（封面、扉页、声明）、罗马序号（摘要、目录）、数字（正文、文献）需要用分节符解决不同页面使用不同页眉页码问题。 目录引文自动化目录-自定义目录-点点选项和修改。 图片编号：插入题注，其他地方复制，最后统一选中，更新域。交叉引用，可快速定位需要引用的图片或表。 引文：自定义编号-用文献工具生成文献集-拷贝到文献部分添加编号-文中插入交叉引用-将交叉引用编号替换成上标格式 文本变表格文本列之间编写时用逗号隔开，全选，插入表格-文本装换位表格，套用样式，更改样式选项，细节调整。 表格布局选项里有排序和公式等选项，可以对表格内容排序，求和，做好的表格还可以在全选（可以加标题和注）后-插入表格-快速表格里-将所选内容进行保存 表格重复标题行（选中标题行，右击-表格属性） 表格内容跨行（表格属性-取消勾选跨行）]]></content>
      <categories>
        <category>职场办公</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Grunt：任务自动管理工具]]></title>
    <url>%2F2017%2F01%2F22%2Fgrunt%2F</url>
    <content type="text"><![CDATA[在Javascript的开发过程中，经常会遇到一些重复性的任务，比如合并文件、压缩代码、检查语法错误、将Sass代码转成CSS代码等等。通常，我们需要使用不同的工具，来完成不同的任务，既重复劳动又非常耗时。Grunt就是为了解决这个问题而发明的工具，可以帮助我们自动管理和运行各种任务。 简单说，Grunt是一个自动任务运行器，会按照预先设定的顺序自动运行一系列的任务。这可以简化工作流程，减轻重复性工作带来的负担。 安装Grunt基于Node.js，安装之前要先安装Node.js，然后运行下面的命令。 sudo npm install grunt-cli -g grunt-cli表示安装的是grunt的命令行界面，参数g表示全局安装。 Grunt使用模块结构，除了安装命令行界面以外，还要根据需要安装相应的模块。这些模块应该采用局部安装，因为不同项目可能需要同一个模块的不同版本。 首先，在项目的根目录下，创建一个文本文件package.json，指定当前项目所需的模块。下面就是一个例子。 &#123; "name": "my-project-name", "version": "0.1.0", "author": "Your Name", "devDependencies": &#123; "grunt": "0.x.x", "grunt-contrib-jshint": "*", "grunt-contrib-concat": "~0.1.1", "grunt-contrib-uglify": "~0.1.0", "grunt-contrib-watch": "~0.1.4" &#125;&#125; 上面这个package.json文件中，除了注明项目的名称和版本以外，还在devDependencies属性中指定了项目依赖的grunt模块和版本：grunt核心模块为最新的0.x.x版，jshint插件为最新版本，concat插件不低于0.1.1版，uglify插件不低于0.1.0版，watch插件不低于0.1.4版。 然后，在项目的根目录下运行下面的命令，这些插件就会被自动安装在node_modules子目录。 npm install 上面这种方法是针对已有package.json的情况。如果想要自动生成package.json文件，可以使用npm init命令，按照屏幕提示回答所需模块的名称和版本即可。 npm init 如果已有的package.json文件不包括Grunt模块，可以在直接安装Grunt模块的时候，加上–save-dev参数，该模块就会自动被加入package.json文件。 npm install &lt;module&gt; --save-dev 比如，对应上面package.json文件指定的模块，需要运行以下npm命令。 npm install grunt --save-devnpm install grunt-contrib-jshint --save-devnpm install grunt-contrib-concat --save-devnpm install grunt-contrib-uglify --save-devnpm install grunt-contrib-watch --save-dev 命令脚本文件Gruntfile.js模块安装完以后，下一步在项目的根目录下，新建脚本文件Gruntfile.js。它是grunt的配置文件，就好像package.json是npm的配置文件一样。Gruntfile.js就是一般的Node.js模块的写法。 module.exports = function(grunt) &#123; // 配置Grunt各种模块的参数 grunt.initConfig(&#123; jshint: &#123; /* jshint的参数 */ &#125;, concat: &#123; /* concat的参数 */ &#125;, uglify: &#123; /* uglify的参数 */ &#125;, watch: &#123; /* watch的参数 */ &#125; &#125;); // 从node_modules目录加载模块文件 grunt.loadNpmTasks('grunt-contrib-jshint'); grunt.loadNpmTasks('grunt-contrib-concat'); grunt.loadNpmTasks('grunt-contrib-uglify'); grunt.loadNpmTasks('grunt-contrib-watch'); // 每行registerTask定义一个任务 grunt.registerTask('default', ['jshint', 'concat', 'uglify']); grunt.registerTask('check', ['jshint']);&#125;; 上面的代码用到了grunt代码的三个方法： grunt.initConfig：定义各种模块的参数，每一个成员项对应一个同名模块。 grunt.loadNpmTasks：加载完成任务所需的模块。 grunt.registerTask：定义具体的任务。第一个参数为任务名，第二个参数是一个数组，表示该任务需要依次使用的模块。default任务名表示，如果直接输入grunt命令，后面不跟任何参数，这时所调用的模块（该例为jshint，concat和uglify）；该例的check任务则表示使用jshint插件对代码进行语法检查。 上面的代码一共加载了四个模块：jshint（检查语法错误）、concat（合并文件）、uglify（压缩代码）和watch（自动执行）。接下来，有两种使用方法。 （1）命令行执行某个模块，比如 grunt jshint 上面代码表示运行jshint模块。 （2）命令行执行某个任务。比如 grunt check 上面代码表示运行check任务。如果运行成功，就会显示“Done, without errors.”。 如果没有给出任务名，只键入grunt，就表示执行默认的default任务。 Gruntfile.js实例：grunt-contrib-cssmin模块下面通过cssmin模块，演示如何编写Gruntfile.js文件。cssmin模块的作用是最小化CSS文件。 首先，在项目的根目录下安装该模块。 npm install grunt-contrib-cssmin --save-dev 然后，新建文件Gruntfile.js。 module.exports = function(grunt) &#123; grunt.initConfig(&#123; cssmin: &#123; minify: &#123; expand: true, cwd: 'css/', src: ['*.css', '!*.min.css'], dest: 'css/', ext: '.min.css' &#125;, combine: &#123; files: &#123; 'css/out.min.css': ['css/part1.min.css', 'css/part2.min.css'] &#125; &#125; &#125; &#125;); grunt.loadNpmTasks('grunt-contrib-cssmin'); grunt.registerTask('default', ['cssmin:minify','cssmin:combine']);&#125;; 下面详细解释上面代码中的三个方法，下面一个个来看。 （1）grunt.loadNpmTasks grunt.loadNpmTasks方法载入模块文件。 grunt.loadNpmTasks('grunt-contrib-cssmin'); 你需要使用几个模块，这里就要写几条grunt.loadNpmTasks语句，将各个模块一一加载。 如果加载模块很多，这部分会非常冗长。而且，还存在一个问题，就是凡是在这里加载的模块，也同时出现在package.json文件中。如果使用npm命令卸载模块以后，模块会自动从package.json文件中消失，但是必须手动从Gruntfile.js文件中清除，这样很不方便，一旦忘记，还会出现运行错误。这里有一个解决办法，就是安装load-grunt-tasks模块，然后在Gruntfile.js文件中，用下面的语句替代所有的grunt.loadNpmTasks语句。 require('load-grunt-tasks')(grunt); 这条语句的作用是自动分析package.json文件，自动加载所找到的grunt模块。 （2）grunt.initConfiggrunt.initConfig方法用于模块配置，它接受一个对象作为参数。该对象的成员与使用的同名模块一一对应。由于我们要配置的是cssmin模块，所以里面有一个cssmin成员（属性）。 cssmin（属性）指向一个对象，该对象又包含多个成员。除了一些系统设定的成员（比如options），其他自定义的成员称为目标（target）。一个模块可以有多个目标（target），上面代码里面，cssmin模块共有两个目标，一个是“minify”，用于压缩css文件；另一个是“combine”，用于将多个css文件合并一个文件。 每个目标的具体设置，需要参考该模板的文档。就cssmin来讲，minify目标的参数具体含义如下： expand：如果设为true，就表示下面文件名的占位符（即*号）都要扩展成具体的文件名。 cwd：需要处理的文件（input）所在的目录。 src：表示需要处理的文件。如果采用数组形式，数组的每一项就是一个文件名，可以使用通配符。 dest：表示处理后的文件名或所在目录。 ext：表示处理后的文件后缀名。 除了上面这些参数，还有一些参数也是grunt所有模块通用的。 filter：一个返回布尔值的函数，用于过滤文件名。只有返回值为true的文件，才会被grunt处理。 dot：是否匹配以点号（.）开头的系统文件。 makeBase：如果设置为true，就只匹配文件路径的最后一部分。比如，a?b可以匹配/xyz/123/acb，而不匹配/xyz/acb/123。 关于通配符，含义如下： *：匹配任意数量的字符，不包括/。 ?：匹配单个字符，不包括/。 **：匹配任意数量的字符，包括/。 {}：允许使用逗号分隔的列表，表示“or”（或）关系。 !：用于模式的开头，表示只返回不匹配的情况。 比如，foo/*.js匹配foo目录下面的文件名以.js结尾的文件，foo/**/*.js匹配foo目录和它的所有子目录下面的文件名以.js结尾的文件，!*.css表示匹配所有后缀名不为“.css”的文件。 使用通配符设置src属性的更多例子： &#123;src: 'foo/th*.js'&#125;grunt-contrib-uglify&#123;src: 'foo/&#123;a,b&#125;*.js'&#125;&#123;src: ['foo/a*.js', 'foo/b*.js']&#125; 至于combine目标，就只有一个files参数，表示输出文件是css子目录下的out.min.css，输入文件则是css子目录下的part1.min.css和part2.min.css。 files参数的格式可以是一个对象，也可以是一个数组。 files: &#123; 'dest/b.js': ['src/bb.js', 'src/bbb.js'], 'dest/b1.js': ['src/bb1.js', 'src/bbb1.js'],&#125;,// orfiles: [ &#123;src: ['src/aa.js', 'src/aaa.js'], dest: 'dest/a.js'&#125;, &#123;src: ['src/aa1.js', 'src/aaa1.js'], dest: 'dest/a1.js'&#125;,], 如果minify目标和combine目标的属性设置有重合的部分，可以另行定义一个与minify和combine平行的options属性。 grunt.initConfig(&#123; cssmin: &#123; options: &#123; /* ... */ &#125;, minify: &#123; /* ... */ &#125;, combine: &#123; /* ... */ &#125; &#125; &#125;); （3）grunt.registerTask grunt.registerTask方法定义如何调用具体的任务。“default”任务表示如果不提供参数，直接输入grunt命令，则先运行“cssmin:minify”，后运行“cssmin:combine”，即先压缩再合并。如果只执行压缩，或者只执行合并，则需要在grunt命令后面指明“模块名:目标名”。 grunt # 默认情况下，先压缩后合并grunt cssmin:minify # 只压缩不合并grunt css:combine # 只合并不压缩 如果不指明目标，只是指明模块，就表示将所有目标依次运行一遍。 grunt cssmin 常用模块设置grunt的模块已经超过了2000个，且还在快速增加。下面是一些常用的模块（按字母排序）。 grunt-contrib-clean：删除文件。 grunt-contrib-compass：使用compass编译sass文件。 grunt-contrib-concat：合并文件。 grunt-contrib-copy：复制文件。 grunt-contrib-cssmin：压缩以及合并CSS文件。 grunt-contrib-imagemin：图像压缩模块。 grunt-contrib-jshint：检查JavaScript语法。 grunt-contrib-uglify：压缩以及合并JavaScript文件。 grunt-contrib-watch：监视文件变动，做出相应动作。 模块的前缀如果是grunt-contrib，就表示该模块由grunt开发团队维护；如果前缀是grunt（比如grunt-pakmanager），就表示由第三方开发者维护。 以下选几个模块，看看它们配置参数的写法，也就是说如何在grunt.initConfig方法中配置各个模块。 grunt-contrib-jshintjshint用来检查语法错误，比如分号的使用是否正确、有没有忘记写括号等等。它在grunt.initConfig方法里面的配置代码如下。 jshint: &#123; options: &#123; eqeqeq: true, trailing: true &#125;, files: ['Gruntfile.js', 'lib/**/*.js']&#125;, 上面代码先指定jshint的检查项目，eqeqeq表示要用严格相等运算符取代相等运算符，trailing表示行尾不得有多余的空格。然后，指定files属性，表示检查目标是Gruntfile.js文件，以及lib目录的所有子目录下面的JavaScript文件。 grunt-contrib-concatconcat用来合并同类文件，它不仅可以合并JavaScript文件，还可以合并CSS文件。 concat: &#123; js: &#123; src: ['lib/module1.js', 'lib/module2.js', 'lib/plugin.js'], dest: 'dist/script.js' &#125; css: &#123; src: ['style/normalize.css', 'style/base.css', 'style/theme.css'], dest: 'dist/screen.css' &#125;&#125;, js目标用于合并JavaScript文件，css目标用语合并CSS文件。两者的src属性指定需要合并的文件（input），dest属性指定输出的目标文件（output）。 grunt-contrib-uglifyuglify模块用来压缩代码，减小文件体积。 uglify: &#123; options: &#123; banner: bannerContent, sourceMapRoot: '../', sourceMap: 'distrib/'+name+'.min.js.map', sourceMapUrl: name+'.min.js.map' &#125;, target : &#123; expand: true, cwd: 'js/origin', src : '*.js', dest : 'js/' &#125;&#125;, 上面代码中的options属性指定压缩后文件的文件头，以及sourceMap设置；target目标指定输入和输出文件。 grunt-contrib-copycopy模块用于复制文件与目录。 copy: &#123; main: &#123; src: 'src/*', dest: 'dest/', &#125;,&#125;, 上面代码将src子目录（只包含它下面的第一层文件和子目录），拷贝到dest子目录下面（即dest/src目录）。如果要更准确控制拷贝行为，比如只拷贝文件、不拷贝目录、不保持目录结构，可以写成下面这样： copy: &#123; main: &#123; expand: true, cwd: 'src/', src: '**', dest: 'dest/', flatten: true, filter: 'isFile', &#125;,&#125;, grunt-contrib-watchwatch模块用来在后台运行，监听指定事件，然后自动运行指定的任务。 watch: &#123; scripts: &#123; files: '**/*.js', tasks: 'jshint', options: &#123; livereload: true, &#125;, &#125;, css: &#123; files: '**/*.sass', tasks: ['sass'], options: &#123; livereload: true, &#125;, &#125;,&#125;, 设置好上面的代码，打开另一个进程，运行grunt watch。此后，任何的js代码变动，文件保存后就会自动运行jshint任务；任何sass文件变动，文件保存后就会自动运行sass任务。 需要注意的是，这两个任务的options参数之中，都设置了livereload，表示任务运行结束后，自动在浏览器中重载（reload）。这需要在浏览器中安装livereload插件。安装后，livereload的默认端口为localhost:35729，但是也可以用livereload: 1337的形式重设端口（localhost:1337）。 其他模块下面是另外一些有用的模块。 （1）grunt-contrib-clean 该模块用于删除文件或目录。 clean: &#123; build: &#123; src: ["path/to/dir/one", "path/to/dir/two"] &#125;&#125; （2）grunt-autoprefixer 该模块用于为CSS语句加上浏览器前缀。 autoprefixer: &#123; build: &#123; expand: true, cwd: 'build', src: [ '**/*.css' ], dest: 'build' &#125;&#125;, （3）grunt-contrib-connect 该模块用于在本机运行一个Web Server。 connect: &#123; server: &#123; options: &#123; port: 4000, base: 'build', hostname: '*' &#125; &#125;&#125; connect模块会随着grunt运行结束而结束，为了使它一直处于运行状态，可以把它放在watch模块之前运行。因为watch模块需要手动中止，所以connect模块也就会一直运行。 （4）grunt-htmlhint 该模块用于检查HTML语法。 htmlhint: &#123; build: &#123; options: &#123; 'tag-pair': true, 'tagname-lowercase': true, 'attr-lowercase': true, 'attr-value-double-quotes': true, 'spec-char-escape': true, 'id-unique': true, 'head-script-disabled': true, &#125;, src: ['index.html'] &#125;&#125; 上面代码用于检查index.html文件：HTML标记是否配对、标记名和属性名是否小写、属性值是否包括在双引号之中、特殊字符是否转义、HTML元素的id属性是否为唯一值、head部分是否没有script标记。 （5）grunt-contrib-sass模块 该模块用于将SASS文件转为CSS文件。 sass: &#123; build: &#123; options: &#123; style: 'compressed' &#125;, files: &#123; 'build/css/master.css': 'assets/sass/master.scss' &#125; &#125;&#125; 上面代码指定输出文件为build/css/master.css，输入文件为assets/sass/master.scss。 （6）grunt-markdown 该模块用于将markdown文档转为HTML文档。 markdown: &#123; all: &#123; files: [ &#123; expand: true, src: '*.md', dest: 'docs/html/', ext: '.html' &#125; ], options: &#123; template: 'templates/index.html', &#125; &#125;&#125;, 上面代码指定将md后缀名的文件，转为docs/html/目录下的html文件。template属性指定转换时采用的模板，模板样式如下。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="main" class="container"&gt; &lt;%=content%&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 参考链接 Frederic Hemberger, A build tool for front-end projects Mária Jurčovičová, Building a JavaScript Library with Grunt.js Ben Briggs，Speed Up Your Web Development Workflow with Grunt Optimizing Images With Grunt Swapnil Mishra, Simplifying Chores with Grunt AJ ONeal, Moving to GruntJS Grunt Documentation, Configuring tasks Landon Schropp, Writing an Awesome Build Script with Grunt Mike Cunsolo, Get Up And Running With Grunt Matt Bailey, A Beginner’s Guide to Using Grunt With Magento Paul Bakaus, Supercharging your Gruntfile]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>grunt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bower简介]]></title>
    <url>%2F2017%2F01%2F02%2Fbower-intro%2F</url>
    <content type="text"><![CDATA[概述随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。 Bower基于node.js，所以安装之前，必须先确保已安装node.js。 $ sudo npm install bower --global 运行上面的命令以后，Bower就已经安装在你的系统中了。运行帮助命令，查看Bower是否安装成功。 $ bower help 下面的命令可以更新或卸载Bower。 # 更新$ sudo npm update -g bower# 卸载$ sudo npm uninstall --global bower 常用操作项目初始化在项目根目录下，运行下面的命令，进行初始化。 $ bower init 通过回答几个问题，就会自动生成bower.json文件。这是项目的配置文件，下面是一个例子。 &#123; "name": "app-name", "version": "0.1.0", "main": ["path/to/app.html", "path/to/app.css", "path/to/app.js"], "ignore": [".jshintrc","**/*.txt"], "dependencies": &#123; "sass-bootstrap": "~3.0.0", "modernizr": "~2.6.2", "jquery": "latests" &#125;, "devDependencies": &#123;"qunit": "&gt;1.11.0"&#125;&#125; 有了bower.json文件以后，就可以用bower install命令，一下子安装所有库。 $ bower install bower.json文件存放在库的根目录下，它的作用是（1）保存项目的库信息，供项目安装时使用，（2）向Bower.com提交你的库，该网站会读取bower.json，列入在线索引。 $ bower register &lt;my-package-name&gt; &lt;git-endpoint&gt;# 实例：在 bower.com 登记jquery$ bower register jquery git://github.com/jquery/jquery 注意，如果你的库与现有的库重名，就会提交失败。 库的安装bower install命令用于安装某个库，需要指明库的名字。 $ bower install backbone Bower会使用库的名字，去在线索引中搜索该库的网址。某些情况下，如果一个库很新（或者你不想使用默认网址），可能需要我们手动指定该库的网址。 $ bower install git://github.com/documentcloud/backbone.git$ bower install http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.0.0/backbone-min.js$ bower install ./some/path/relative/to/this/directory/backbone.js 上面的命令说明，指定的网址可以是github地址、http网址、本地文件。 默认情况下，会安装该库的最新版本，但是也可以手动指定版本号。 $ bower install jquery-ui#1.10.1 上面的命令指定安装jquery-ui的1.10.1版。 如果某个库依赖另一个库，安装时默认将所依赖的库一起安装。比如，jquery-ui依赖jquery，安装时会连jquery一起安装。 安装后的库默认存放在项目的bower_components子目录，如果要指定其他位置，可在.bowerrc文件的directory属性设置。 库的搜索和查看bower search命令用于使用关键字，从在线索引中搜索相关库。 bower search jquery 上面命令会得到下面这样的结果。 Search results: jquery git://github.com/components/jquery.git jquery-ui git://github.com/components/jqueryui jquery.cookie git://github.com/carhartl/jquery-cookie.git jquery-placeholder git://github.com/mathiasbynens/jquery-placeholder.git jquery-file-upload git://github.com/blueimp/jQuery-File-Upload.git jasmine-jquery git://github.com/velesin/jasmine-jquery jquery.ui git://github.com/jquery/jquery-ui.git ... bower info命令用于查看某个库的详细信息。 bower info jquery-ui 查看结果会列出该库的依赖关系（dependencies），以及可以得到的版本（Available versions）。 库的更新和卸载bower update用于更新一个库，将其更新为最新版本。 $ bower update jquery-ui 如果不给出库名，则更新所有库。 bower uninstall命令用于卸载指定的库。 $ bower uninstall jquery-ui 注意，默认情况下会连所依赖的库一起卸载。比如，jquery-ui依赖jquery，卸载时会连jquery一起卸载，除非还有别的库依赖jquery。 列出所有库bower list或bower ls命令，用于列出项目所使用的所有库。 Bower listBower ls 配置文件.bowerrc项目根目录下（也可以放在用户的主目录下）的.bowerrc文件是Bower的配置文件，它大概像下面这样。 &#123; "directory" : "components", "json" : "bower.json", "endpoint" : "https://Bower.herokuapp.com", "searchpath" : "", "shorthand_resolver" : ""&#125; 其中的属性含义如下。 directory：存放库文件的子目录名。 json：描述各个库的json文件名。 endpoint：在线索引的网址，用来搜索各种库。 searchpath：一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。 shorthand_resolver：定义各个库名称简写形式。 相关链接 Cody Lindley, Package Managers: An Introductory Guide For The Uninitiated Front-End Developer Tyson Cadenhead, Client-Side Dependency Management with Bower Matt West, Getting Started with Bower]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Gulp：任务自动管理工具]]></title>
    <url>%2F2016%2F10%2F27%2Fgulp-intro%2F</url>
    <content type="text"><![CDATA[Gulp与Grunt一样，也是一个自动任务运行器。它充分借鉴了Unix操作系统的管道（pipe）思想，很多人认为，在操作上，它要比Grunt简单。 安装Gulp需要全局安装，然后再在项目的开发目录中安装为本地模块。先进入项目目录，运行下面的命令。 npm install -g gulpnpm install --save-dev gulp 除了安装gulp以外，不同的任务还需要安装不同的gulp插件模块。举例来说，下面代码安装了gulp-uglify模块。 $ npm install --save-dev gulp-uglify gulpfile.js项目根目录中的gulpfile.js，是Gulp的配置文件。下面就是一个典型的gulpfile.js文件。 var gulp = require('gulp');var uglify = require('gulp-uglify');gulp.task('minify', function () &#123; gulp.src('js/app.js') .pipe(uglify()) .pipe(gulp.dest('build'))&#125;); 上面代码中，gulpfile.js加载gulp和gulp-uglify模块之后，使用gulp模块的task方法指定任务minify。task方法有两个参数，第一个是任务名，第二个是任务函数。在任务函数中，使用gulp模块的src方法，指定所要处理的文件，然后使用pipe方法，将上一步的输出转为当前的输入，进行链式处理。 task方法的回调函数使用了两次pipe方法，也就是说做了两种处理。第一种处理是使用gulp-uglify模块，压缩源码；第二种处理是使用gulp模块的dest方法，将上一步的输出写入本地文件，这里是build.js（代码中省略了后缀名js）。 执行minify任务时，就在项目目录中执行下面命令就可以了。 $ gulp minify 从上面的例子中可以看到，gulp充分使用了“管道”思想，就是一个数据流（stream）：src方法读入文件产生数据流，dest方法将数据流写入文件，中间是一些中间步骤，每一步都对数据流进行一些处理。 下面是另一个数据流的例子。 gulp.task('js', function () &#123; return gulp.src('js/*.js') .pipe(jshint()) .pipe(uglify()) .pipe(concat('app.js')) .pipe(gulp.dest('build'));&#125;); 上面代码使用pipe命令，分别进行jshint、uglify、concat三步处理。 gulp模块的方法src()gulp模块的src方法，用于产生数据流。它的参数表示所要处理的文件，这些指定的文件会转换成数据流。参数的写法一般有以下几种形式。 js/app.js：指定确切的文件名。 js/*.js：某个目录所有后缀名为js的文件。 js/**/*.js：某个目录及其所有子目录中的所有后缀名为js的文件。 !js/app.js：除了js/app.js以外的所有文件。 *.+(js|css)：匹配项目根目录下，所有后缀名为js或css的文件。 src方法的参数还可以是一个数组，用来指定多个成员。 gulp.src(['js/**/*.js', '!js/**/*.min.js']) dest()dest方法将管道的输出写入文件，同时将这些输出继续输出，所以可以依次调用多次dest方法，将输出写入多个目录。如果有目录不存在，将会被新建。 gulp.src('./client/templates/*.jade') .pipe(jade()) .pipe(gulp.dest('./build/templates')) .pipe(minify()) .pipe(gulp.dest('./build/minified_templates')); dest方法还可以接受第二个参数，表示配置对象。 gulp.dest('build', &#123; cwd: './app', mode: '0644'&#125;) 配置对象有两个字段。cwd字段指定写入路径的基准目录，默认是当前目录；mode字段指定写入文件的权限，默认是0777。 task()task方法用于定义具体的任务。它的第一个参数是任务名，第二个参数是任务函数。下面是一个非常简单的任务函数。 gulp.task('greet', function () &#123; console.log('Hello world!');&#125;); task方法还可以指定按顺序运行的一组任务。 gulp.task('build', ['css', 'js', 'imgs']); 上面代码先指定build任务，它由css、js、imgs三个任务所组成，task方法会并发执行这三个任务。注意，由于每个任务都是异步调用，所以没有办法保证js任务的开始运行的时间，正是css任务运行结束。 如果希望各个任务严格按次序运行，可以把前一个任务写成后一个任务的依赖模块。 gulp.task('css', ['greet'], function () &#123; // Deal with CSS here&#125;); 上面代码表明，css任务依赖greet任务，所以css一定会在greet运行完成后再运行。 task方法的回调函数，还可以接受一个函数作为参数，这对执行异步任务非常有用。 // 执行shell命令var exec = require('child_process').exec;gulp.task('jekyll', function(cb) &#123; // build Jekyll exec('jekyll build', function(err) &#123; if (err) return cb(err); // return error cb(); // finished task &#125;);&#125;); 如果一个任务的名字为default，就表明它是“默认任务”，在命令行直接输入gulp命令，就会运行该任务。 gulp.task('default', function () &#123; // Your default task&#125;);// 或者gulp.task('default', ['styles', 'jshint', 'watch']); 执行的时候，直接使用gulp，就会运行styles、jshint、watch三个任务。 watch()watch方法用于指定需要监视的文件。一旦这些文件发生变动，就运行指定任务。 gulp.task('watch', function () &#123; gulp.watch('templates/*.tmpl.html', ['build']);&#125;); 上面代码指定，一旦templates目录中的模板文件发生变化，就运行build任务。 watch方法也可以用回调函数，代替指定的任务。 gulp.watch('templates/*.tmpl.html', function (event) &#123; console.log('Event type: ' + event.type); console.log('Event path: ' + event.path);&#125;); 另一种写法是watch方法所监控的文件发生变化时（修改、增加、删除文件），会触发change事件。可以对change事件指定回调函数。 var watcher = gulp.watch('templates/*.tmpl.html', ['build']);watcher.on('change', function (event) &#123; console.log('Event type: ' + event.type); console.log('Event path: ' + event.path);&#125;); 除了change事件，watch方法还可能触发以下事件。 end：回调函数运行完毕时触发。 error：发生错误时触发。 ready：当开始监听文件时触发。 nomatch：没有匹配的监听文件时触发。 watcher对象还包含其他一些方法。 watcher.end()：停止watcher对象，不会再调用任务或回调函数。 watcher.files()：返回watcher对象监视的文件。 watcher.add(glob)：增加所要监视的文件，它还可以附件第二个参数，表示回调函数。 watcher.remove(filepath)：从watcher对象中移走一个监视的文件。 gulp-load-plugins模块一般情况下，gulpfile.js中的模块需要一个个加载。 var gulp = require('gulp'), jshint = require('gulp-jshint'), uglify = require('gulp-uglify'), concat = require('gulp-concat');gulp.task('js', function () &#123; return gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(uglify()) .pipe(concat('app.js')) .pipe(gulp.dest('build'));&#125;); 上面代码中，除了gulp模块以外，还加载另外三个模块。 这种一一加载的写法，比较麻烦。使用gulp-load-plugins模块，可以加载package.json文件中所有的gulp模块。上面的代码用gulp-load-plugins模块改写，就是下面这样。 var gulp = require('gulp'), gulpLoadPlugins = require('gulp-load-plugins'), plugins = gulpLoadPlugins();gulp.task('js', function () &#123; return gulp.src('js/*.js') .pipe(plugins.jshint()) .pipe(plugins.jshint.reporter('default')) .pipe(plugins.uglify()) .pipe(plugins.concat('app.js')) .pipe(gulp.dest('build'));&#125;); 上面代码假设package.json文件包含以下内容。 &#123; "devDependencies": &#123; "gulp-concat": "~2.2.0", "gulp-uglify": "~0.2.1", "gulp-jshint": "~1.5.1", "gulp": "~3.5.6" &#125;&#125; gulp-livereload模块gulp-livereload模块用于自动刷新浏览器，反映出源码的最新变化。它除了模块以外，还需要在浏览器中安装插件，用来配合源码变化。 var gulp = require('gulp'), less = require('gulp-less'), livereload = require('gulp-livereload'), watch = require('gulp-watch');gulp.task('less', function() &#123; gulp.src('less/*.less') .pipe(watch()) .pipe(less()) .pipe(gulp.dest('css')) .pipe(livereload());&#125;); 上面代码监视less文件，一旦编译完成，就自动刷新浏览器。 参考链接 Callum Macrae, Building With Gulp]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jade使用介绍]]></title>
    <url>%2F2016%2F10%2F10%2Fjade%2F</url>
    <content type="text"><![CDATA[jade使用总结。 jade基础语法知识文档声明和头尾标签jade编写：doctype htmlhtml head title my jade template body h1 Hello jade 编译后：&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;my jade template&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello jade&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 命令行适时编译jade index.jade //编译后备压缩jade index.jade -P //编译文件为jade.html并且格式化了 放在相同的目录。jade index.jade -P -w //实时编译jade index.jade -P -w --obj '&#123;"course","jade"&#125;' //想文档中传递变量 优先级最低。jade index.jade -P -O jade.json //通过json想文档传递数据 标签语法jade编写：h3 标签语法section div ul p 编译后：&lt;h3&gt;标签语法&lt;/h3&gt;&lt;section&gt; &lt;div&gt; &lt;ul&gt;&lt;/ul&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;&lt;/section&gt; 属性文本和值jade编写：h3 元素属性#id.class1(class=&apos;class2&apos;)div#id.class1.class2 a(href=&apos;http://imooc.com&apos;, target=&apos;_blank&apos;) linkh3 元素的值，文本p a(href=&apos;http://imooc.com&apos;,title=&apos;imooc jade study&apos;, data-uid=&apos;1000&apos;) link input(name=&apos;course&apos;, type=&apos;text&apos;, value=&apos;jade&apos;) input(name=&apos;type&apos;, type=&apos;checkbox&apos;, checked) 编译后：&lt;h3&gt;元素属性&lt;/h3&gt; &lt;div id="id" class="class1 class2"&gt;&lt;/div&gt; &lt;div id="id" class="class1 class2"&gt;&lt;a href="http://imooc.com" target="_blank"&gt;link&lt;/a&gt;&lt;/div&gt; &lt;h3&gt;元素的值，文本&lt;/h3&gt; &lt;p&gt;&lt;a href="http://imooc.com" title="imooc jade study" data-uid="1000"&gt;link&lt;/a&gt; &lt;input name="course" type="text" value="jade"&gt; &lt;input name="type" type="checkbox" checked&gt; &lt;/p&gt; 混合的成段文本和标签jade编写：h3 混排的大段文本 p. 1. aa 2. bb &lt;strong&gt;333&lt;/strong&gt; 3. c 4. dd p | 1. aa strong 11 | 2. bb | 3. c 编译后：&lt;h3&gt;混排的大段文本&lt;/h3&gt; &lt;p&gt; 1. aa 2. bb &lt;strong&gt;333&lt;/strong&gt; 3. c 4. dd &lt;/p&gt; &lt;p&gt;1. aa&lt;strong&gt;11&lt;/strong&gt;2. bb 3. c &lt;/p&gt; 注释和条件注释jade编写：h2 注释 h3 单行注释 // h3.title(id=&apos;title&apos;, class=&apos;title3&apos;) imooc h3 非缓冲注释 //- #id.classname h3 块注释 //- p a(href=&apos;http://imooc.com&apos;,title=&apos;imooc jade study&apos;, data-uid=&apos;1000&apos;) link input(name=&apos;course&apos;, type=&apos;text&apos;, value=&apos;jade&apos;) input(name=&apos;type&apos;, type=&apos;checkbox&apos;, checked) &lt;!--[if IE 8]&gt; script(src=&apos;/ie.js&apos;) &lt;![endif]--&gt; 编译后：&lt;h2&gt;注释&lt;/h2&gt;&lt;h3&gt;单行注释&lt;/h3&gt;&lt;!-- h3.title(id='title', class='title3') imooc--&gt;&lt;h3&gt;非缓冲注释&lt;/h3&gt;&lt;h3&gt;块注释&lt;/h3&gt;&lt;!--[if IE 8]&gt;&lt;script src="/ie.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 变量声明和数据传递jade编写：h2 声明变量和替换数据-安全转义与非转义 h3 转义 - var data = &apos;text&apos; - var htmlData = &apos;&lt;script&gt;alert(1);&lt;/script&gt;&lt;span&gt;script&lt;/span&gt;;&apos; p #&#123;data&#125; p #&#123;htmlData&#125; p= data p= htmlData h3 非转义 p!= htmlData p !&#123;htmlData&#125; h3 非解析变量符 p \#&#123;htmlData&#125; p \!&#123;htmlData&#125; h3 不输出 undefined input(value=&apos;#&#123;newData&#125;&apos;) input(value=newData) h3 样式和脚本块语法 style. body &#123;color: #ff6600;&#125; script. var imoocCourse = &apos;jade&apos;; 编译后：&lt;h2&gt;声明变量和替换数据&lt;/h2&gt; &lt;h3&gt;转义&lt;/h3&gt; &lt;p&gt;text&lt;/p&gt; &lt;p&gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;&amp;lt;span&amp;gt;script&amp;lt;/span&amp;gt;;&lt;/p&gt; &lt;p&gt;text&lt;/p&gt; &lt;p&gt;&amp;lt;script&amp;gt;alert(1);&amp;lt;/script&amp;gt;&amp;lt;span&amp;gt;script&amp;lt;/span&amp;gt;;&lt;/p&gt; &lt;h3&gt;非转义&lt;/h3&gt; &lt;p&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;span&gt;script&lt;/span&gt;;&lt;/p&gt; &lt;p&gt;&lt;script&gt;alert(1);&lt;/script&gt;&lt;span&gt;script&lt;/span&gt;;&lt;/p&gt; &lt;h3&gt;非解析变量符&lt;/h3&gt; &lt;p&gt;#&#123;htmlData&#125;&lt;/p&gt; &lt;p&gt;!&#123;htmlData&#125;&lt;/p&gt; &lt;h3&gt;不输出 undefined&lt;/h3&gt; &lt;input value="undefined"&gt; &lt;input&gt; &lt;h3&gt;样式和脚本块语法&lt;/h3&gt; &lt;style&gt;body &#123;color: #ff6600;&#125;&lt;/style&gt; &lt;script&gt; var imoocCourse = 'jade'; &lt;/script&gt; 流程逻辑jade编写：h2 流程逻辑h3 if else- var isImooc = true- var lessons = [&apos;jade&apos;, &apos;node&apos;]if lessons if lessons.length &gt; 2 p more than 2: #&#123;lessons.join(&apos;, &apos;)&#125; else if lessons.length &gt; 1 p more than 1: #&#123;lessons.join(&apos;, &apos;)&#125; else p no lessonelse p no lessonh3 unlessunless !isImooc p #&#123;lessons.length&#125;h3 case- var name = &apos;jade&apos;case name when &apos;java&apos; when &apos;node&apos; p Hi node! when &apos;jade&apos;: p Hi jade! when &apos;express&apos;: p Hi exress default p Hi #&#123;name&#125;h3 for- var imooc = &#123;course: &apos;jade&apos;, level: &apos;high&apos;&#125;- for (var k in imooc) p= imooc[k]h3 each- each value, key in imooc p #&#123;key&#125;: #&#123;value&#125;each value, key in imooc p #&#123;key&#125;: #&#123;value&#125;h3 遍历数组- var courses = [&apos;node&apos;, &apos;jade&apos;, &apos;express&apos;]each item in courses p= itemh3 嵌套循环- var sections = [&#123;id: 1, items: [&apos;a&apos;, &apos;b&apos;]&#125;, &#123;id: 2, items: [&apos;c&apos;, &apos;d&apos;]&#125;]dl each section in sections dt= section.id each item in section.items dd= itemh3 while- var n = 0ul while n &lt; 4 li= n++ 编译后：&lt;h2&gt;流程逻辑&lt;/h2&gt; &lt;h3&gt;if else&lt;/h3&gt; &lt;p&gt;more than 1: jade, node&lt;/p&gt; &lt;h3&gt;unless&lt;/h3&gt; &lt;p&gt;2&lt;/p&gt; &lt;h3&gt;case&lt;/h3&gt; &lt;p&gt;Hi jade!&lt;/p&gt; &lt;h3&gt;for&lt;/h3&gt; &lt;p&gt;jade&lt;/p&gt; &lt;p&gt;high&lt;/p&gt; &lt;h3&gt;each&lt;/h3&gt; &lt;p&gt;course: jade&lt;/p&gt; &lt;p&gt;level: high&lt;/p&gt; &lt;p&gt;course: jade&lt;/p&gt; &lt;p&gt;level: high&lt;/p&gt; &lt;h3&gt;遍历数组&lt;/h3&gt; &lt;p&gt;node&lt;/p&gt; &lt;p&gt;jade&lt;/p&gt; &lt;p&gt;express&lt;/p&gt; &lt;h3&gt;嵌套循环&lt;/h3&gt; &lt;dl&gt; &lt;dt&gt;1&lt;/dt&gt; &lt;dd&gt;a&lt;/dd&gt; &lt;dd&gt;b&lt;/dd&gt; &lt;dt&gt;2&lt;/dt&gt; &lt;dd&gt;c&lt;/dd&gt; &lt;dd&gt;d&lt;/dd&gt; &lt;/dl&gt; &lt;h3&gt;while&lt;/h3&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; 神奇的mixinsjade编写：h2 神奇的 mixinsmixin lesson p imooc jade study+lessonmixin study(name, courses) p #&#123;name&#125; study ul.courses each course in courses li= courseh3 嵌套的 mixin+study(&apos;tom&apos;, [&apos;jade&apos;, &apos;node&apos;])mixin group(student) h4 #&#123;student.name&#125; +study(student.name, student.courses)+group(&#123;name: &apos;tom&apos;, courses: [&apos;jade&apos;, &apos;node&apos;]&#125;)h3 mixin 的块包含mixin team(slogon) h4 #&#123;slogon&#125; if block block else p no team+team(&apos;slogon&apos;) p Good job!h3 mixin 传递属性mixin attr(name) p(class!=attributes.class) #&#123;name&#125;+attr(&apos;attr&apos;)(class=&apos;magic&apos;)mixin attrs(name) p&amp;attributes(attributes) #&#123;name&#125;+attrs(&apos;attrs&apos;)(class=&apos;magic2&apos;, id=&apos;attrid&apos;)h3 mixin 传递位置个数参数mixin magic(name, ...items) ul(class=&apos;#&#123;name&#125;&apos;) each item in items li= item+magic(&apos;magic&apos;, &apos;node&apos;, &apos;jade&apos;, &apos;..&apos;) 编译后：&lt;h2&gt;神奇的 mixins&lt;/h2&gt; &lt;p&gt;imooc jade study&lt;/p&gt;&lt;h3&gt;嵌套的 mixin&lt;/h3&gt; &lt;p&gt;tom study&lt;/p&gt; &lt;ul class="courses"&gt; &lt;li&gt;jade&lt;/li&gt; &lt;li&gt;node&lt;/li&gt; &lt;/ul&gt; &lt;h4&gt;tom&lt;/h4&gt; &lt;p&gt;tom study&lt;/p&gt; &lt;ul class="courses"&gt; &lt;li&gt;jade&lt;/li&gt; &lt;li&gt;node&lt;/li&gt; &lt;/ul&gt;&lt;h3&gt;mixin 的块包含&lt;/h3&gt; &lt;h4&gt;slogon&lt;/h4&gt; &lt;p&gt;Good job!&lt;/p&gt;&lt;h3&gt;mixin 传递属性&lt;/h3&gt; &lt;p class="magic"&gt;attr&lt;/p&gt; &lt;p id="attrid" class="magic2"&gt;attrs&lt;/p&gt;&lt;h3&gt;mixin 传递位置个数参数&lt;/h3&gt; &lt;ul class="magic"&gt; &lt;li&gt;node&lt;/li&gt; &lt;li&gt;jade&lt;/li&gt; &lt;li&gt;..&lt;/li&gt; &lt;/ul&gt; jade进阶模板继承// layout.jadedoctype htmlhtml head block scripts script(src='jquery.js') block styles body block content p there's no content here 等价于：&lt;doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;script src=&apos;jquery.js&apos;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;there&apos;s no content here&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; // page1.jade（假设和layout.jade相同路径）extends layout // .jade扩展名可以省略block scripts // 替代原模板中的 block scripts script(src='jquery.js') script(src='underscore.js')block content // 替代原模板中的 block content 等价于&lt;doctype html&gt;&lt;html&gt; &lt;head&gt; &lt;script src='jquery.js'&gt;&lt;/script&gt; &lt;script src='underscore.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 模板包含jade编写：h3 包含 include style style. h2 &#123; color: #000; &#125; include title.html block desc p desc from index 编译后：&lt;h3&gt;包含&lt;/h3&gt; &lt;style&gt; body &#123; color: #999; &#125; &lt;/style&gt; &lt;style&gt; h2 &#123; color: #000; &#125; &lt;/style&gt; &lt;div&gt; &lt;h3&gt;content from html&lt;/h3&gt; &lt;/div&gt; &lt;p&gt;desc from index&lt;/p&gt; 过滤器jade编写：h2 过滤器 filters h3 markdown :markdown Hi, this is **imooc** [link](http://imooc.com) h3 less style :less body &#123; p &#123; color: #ccc; &#125; &#125; h3 coffee script :coffee console.log &apos;This is coffee!&apos; 编译后：&lt;h2&gt;过滤器 filters&lt;/h2&gt; &lt;h3&gt;markdown&lt;/h3&gt;&lt;p&gt;Hi, this is &lt;strong&gt;imooc&lt;/strong&gt; &lt;a href="http://imooc.com"&gt;link&lt;/a&gt;&lt;/p&gt; &lt;h3&gt;less&lt;/h3&gt; &lt;style&gt; body p &#123; color: #ccc; &#125; &lt;/style&gt; &lt;h3&gt;coffee&lt;/h3&gt; &lt;script&gt; (function() &#123; console.log('This is coffee!'); &#125;).call(this); &lt;/script&gt; runtime环境下使用jadejade –client –no-debug runtime.jade //命令h2 浏览器端使用 jade #runtime script(src=&apos;node_modules/jade/runtime.js&apos;) script(src=&apos;runtime.js&apos;) script. var runtimeNode = document.getElementById(&apos;runtime&apos;); var runtimeHtml = template(&#123;isRuntime: true&#125;); runtimeNode.innerHTML = runtimeHtml; span 12 编译后：&lt;h2&gt;浏览器端使用 jade&lt;/h2&gt; &lt;div id="runtime"&gt;&lt;/div&gt; &lt;script src="node_modules/jade/runtime.js"&gt;&lt;/script&gt; &lt;script src="runtime.js"&gt;&lt;/script&gt; &lt;script&gt; var runtimeNode = document.getElementById('runtime'); var runtimeHtml = template(&#123;isRuntime: true&#125;); runtimeNode.innerHTML = runtimeHtml; span 12 &lt;/script&gt; 利用html2jade反编译html2jade http://twitter.comhtml2jade http://twitter.com &gt; twitter.jadehtml2jade mywebpage.html # outputs mywebpage.jadehtml2jade public/*.html # converts all .html files to .jade]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>jade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git使用指南]]></title>
    <url>%2F2016%2F08%2F20%2Fgit%2F</url>
    <content type="text"><![CDATA[简单介绍一下git的安装、配置及常用命令。 安装Git官网 设置全局变量$ git config --global user.name "amenzai" # 提交版本时的用户名$ git config --global user.email "amenzai@qq.com" # 提交版本时的邮箱 配置SSH$ ssh-keygen -t rsa -C "775166868@qq.com" 然后可以不输入文件名字 ，直接回车，到C:\Users\xxxx\.ssh文件夹下 打开id_rsa.pub文件，复制内容，到github官网，点击用户图像里的设置，点击左侧的 sshkeys，黏贴相关信息。 $ ssh -T git@github.com # 检查是否添加成功 初始化一个本地GIT仓储$ cd demo-project # 定位到仓储文件夹目录$ git init # 初始化本地仓储 添加本地GIT忽略清单文件.gitignore# 添加OS X中系统文件.DS_Store到忽略清单，这将忽略项目任意目录下的.DS_Store文件或是文件夹$ echo .DS_Store &gt;&gt; .gitignore 查看本地仓储的变更状态$ git status 添加本地暂存（托管）文件$ git add README.md # 添加指定文件名的文件$ git add *.md # 添加通配符匹配的文件$ git add --all # 添加所有未托管的文件（忽略.gitignore清单中的列表） 提交被托管的文件变化到本地仓储$ git commit -m 'Initial commit(change log)' 为仓储添加远端（服务器端）地址$ git remote add origin https:# github.com/amenzai/demo-project.git # 添加一个远端地址并起了一个别名叫origin$ git remote -v # 查看现有的远端列表 将本地仓储的提交记录推送到远端的master分支$ git push -u origin master 拉取远端master分支的更新记录到本地$ git pull origin master 其他常用命令$ git status -s # 输出简要的变更日志$ git diff # 对比当前状态和版本库中状态的变化$ git log # 可以查看提交日志$ git reset --hard xxxxxx # 回归到指定版本$ git branch # 查看仓库有哪些分支以及当前处于哪个分支$ git branch V2 # 创建一个V2分支$ git checkout V2 # 切换到V2分支$ git push -u origin V2 # 提交到V2分支 相关网址 Github官网 Github客户端下载 GitHub Guides Git Guides]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5总结]]></title>
    <url>%2F2016%2F06%2F10%2Fhtml5%2F</url>
    <content type="text"><![CDATA[HTML5新增内容的整理。 新标签更语义化的标签&lt;header&gt;&lt;nav&gt;&lt;footer&gt;&lt;main&gt;&lt;aside&gt;&lt;artical&gt;&lt;section&gt;&lt;figure&gt;&lt;figcaption&gt; 应用程序功能标签&lt;!-- 模拟下拉列表 --&gt;&lt;input list="teachers" /&gt;&lt;datalist id="teachers"&gt; &lt;option value="段誉" /&gt; &lt;option value="乔峰" /&gt; &lt;option value="方世玉" /&gt;&lt;/datalist&gt;&lt;!-- 模拟菜单 仅仅火狐支持--&gt;&lt;menu&gt; &lt;command type="command" disabled label="Publish" /&gt;&lt;/menu&gt;&lt;!-- 点击查看详情 --&gt;&lt;details&gt; &lt;summary&gt;HTML 5&lt;/summary&gt; This slide deck teaches you everything you need to know about HTML 5.&lt;/details&gt;&lt;!-- meta --&gt;&lt;meter min="0" max="100" low="40" high="90" optimum="100" value="91"&gt;A+&lt;/meter&gt;&lt;!-- 进度条 在不同操作系统上显示不同 --&gt;&lt;progress&gt;working...&lt;/progress&gt;&lt;progress value="75" max="100"&gt;3/4 complete&lt;/progress&gt; 新属性ARIA 属性&lt;!-- 盲人用户如何知道当前浏览区域就是网站主导航？ --&gt;&lt;div id="mainnav" role="navigation"&gt; &lt;a href="http://news.qq.com/" target="_blank"&gt;新闻&lt;/a&gt; &lt;a href="http://v.qq.com/" target="_blank"&gt;视频&lt;/a&gt; &lt;a href="http://ent.qq.com/" target="_blank"&gt;娱乐&lt;/a&gt;&lt;/div&gt;&lt;!-- 如何让盲人用户知道我们使用li标签是用来模拟标准select控件？ --&gt;&lt;div class="dropdown"&gt; &lt;a href="javascript:;" role="combobox" aria-autocomplete="list" aria-owns="question-list" aria-expanded="true"&gt;选择提示问题&lt;/a&gt; &lt;ul id="question-list" role="listbox"&gt; &lt;li role="option"&gt;&lt;a href="javascript:;"&gt;我妈妈的名字是？&lt;/a&gt;&lt;/li&gt; &lt;li role="option"&gt;&lt;a href="javascript:;"&gt;我爸爸的名字是？&lt;/a&gt;&lt;/li&gt; &lt;li role="option"&gt;&lt;a href="javascript:;"&gt;我爱人的名字是？&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; data属性&lt;!-- 标签绑定数据 --&gt;&lt;li class="item" data-id="1" data-age="18" data-gender="true"&gt;text&lt;/li&gt;&lt;script&gt; // 设置data属性 DOM.setAttribute('data-name', 'text'); // 获取data属性 DOM.dataset['age']&lt;/script&gt; 新的表单类型type = [&apos;search&apos;,&apos;date&apos;,&apos;range&apos;,&apos;number&apos;,&apos;color&apos;,&apos;email&apos;,&apos;url&apos;,&apos;tel&apos;] 多媒体元素h5-vedio or h5-audio //在sublime中定义好了代码段，直接输入+tab&lt;!-- 滚动字体 --&gt;&lt;marquee style="width: 388px; height: 200px" scrollamount="2" direction="up"&gt; &lt;p&gt;&lt;span&gt;日不落的夏天中了50元酒店信用住超值红包&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;悠悠youyou中了20元酒店信用住超值红包&lt;/span&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;xiaomogu中了100元酒店信用住超值红包&lt;/span&gt;&lt;/p&gt;&lt;/marquee&gt; SVG//svg文件的引入方式&lt;!-- 第一种方式 --&gt;&lt;iframe src="famoustiger.svg" style="border:none; width:550px; height:540px; background: white;"&gt;&lt;/iframe&gt;&lt;!-- 第二种方式 --&gt;&lt;embed src="famoustiger.svg" style="border:none; width:550px; height:540px; background: white;" type="image/svg+xml" pluginspage="http://www.adobe.com/svg/viewer/install/" /&gt;&lt;!-- 第三种方式 --&gt;&lt;object type="image/svg+xml" style="border:none; width:550px; height:540px; background: white;" data="famoustiger.svg" codebase="http://www.adobe.com/svg/viewer/install/"&gt;&lt;/object&gt; SVG可以看成个页面，因此用上述方法引入时无法更改其样式。 所以通常我们会这样引入：通过Js将SVG文档根元素，插入到本文档，这样我们可以对其样式进行更改。&lt;svg data-src="demo.svg"&gt;&lt;/svg&gt;var svgs = $('svg');for (var i = 0; i &lt; svgs.length; i++) &#123; var src = $(svgs[i]).data('src'); // 向服务器发送请求 得到svg $.get(src, function(data) &#123; var el = data.documentElement; $(document.body).append($(el)); &#125;);&#125; JS-API新的选择器document.querySelector(selector) //可以通过CSS选择器的语法找到匹配的第一个DOM元素document.querySelectorAll(selector) //可以通过CSS选择器的语法找到匹配的所有DOM元素 Class Listvar demoClassList = demoElement.classList; //返回一个数组demoClassList.add('bordered'); // 添加一个类名demoClassList.remove('highlighted'); // 删除一个类名var isAnimated = demoClassList.contains('animated'); // 获取是否存在指定类名demoClassList.toggle('animated', !isAnimated); // 根据第二个参数切换一个类名 history-api界面上的所有JS操作不会被浏览器记住，就无法回到之前的状态。 在HTML5中可以通过window.history操作访问历史状态，让一个页面可以有多个历史状态window.history.forward(); // 前进window.history.back(); // 后退window.history.go(); // 刷新history.pushState(放入历史中的状态数据, 设置title(现在浏览器不支持)， 改变历史状态)window的popstate事件当前进或后退触发。e.state得到“放入历史中的状态数据”单页应用程序（记录js中的事件，可以返回） 全屏 APIJavaScript中可以通过调用requestFullScreen()方式实现指定元素的全屏显示。var element = document.querySelector('...');element.requestFullScreen();fullScreen(element)// 让元素全屏的方法，全平时背景是黑的，要给每个元素设置背景才行function fullScreen(element) &#123; if (element.webkitRequestFullScreen) &#123; element.webkitRequestFullScreen(); &#125; else if (element.mozRequestFullScreen) &#123; element.mozRequestFullScreen(); &#125; else if (element.requestFullScreen) &#123; element.requestFullScreen(); &#125; // 锁定鼠标 if (element.requestPointerLock) element.requestPointerLock();&#125; Application Cache对HTML元素加一个manifest属性，根目录创建一个cache.manifest文件，高速浏览器将会缓存里面编写的文件，以后不用到服务器加载，版本更新的话，把里面的version改了就行。&lt;html lang="zh-CN" manifest="cache.manifest"&gt;&lt;!-- cache.manifest文件内容 --&gt;CACHE MANIFEST# version 1.0.7CACHE: cache.css //路径写正确 cache.js 05-application-cache.html toy.pngNETWORK: * Web Storage(本地存储)localStorage //永久存储，除非用户删除了sessionStorage //网页关闭即删除localStorage.setItem(key,value); //设置键值对localStorage.getItem(key); 获取存储的键值]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式图片解决方案]]></title>
    <url>%2F2016%2F05%2F20%2Fresponsive-img%2F</url>
    <content type="text"><![CDATA[响应式图片实现方法：js、服务器、srcset、picture、svg 具体实现可以用picture加腻子脚本。 picture加腻子脚本&lt;!-- 先引入 --&gt;&lt;script src=&quot;lib/picturefill.min.js&quot;&gt;&lt;/script&gt;&lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad001-l.png&quot; media=&quot;(min-width:50em)&quot;&gt; &lt;source srcset=&quot;img/ad001-m.png&quot; media=&quot;(min-width:30em)&quot;&gt; &lt;img src=&quot;img/ad001.png&quot; alt=&quot;2015年度报告&quot;&gt; &lt;/picture&gt;&lt;/div&gt;&lt;div class=&quot;item&quot;&gt; &lt;picture&gt; &lt;source srcset=&quot;img/ad002-l.png&quot; media=&quot;(min-width: 50em)&quot;&gt; &lt;source srcset=&quot;img/ad002-m.png&quot; media=&quot;(min-width: 30em)&quot;&gt; &lt;img srcset=&quot;img/ad002.png&quot; alt=&quot;新年红包&quot;&gt; &lt;/picture&gt;&lt;/div&gt; js判断窗口尺寸function resize() &#123; // 屏幕宽度 var windowWidth = $(window).width(); // 是否为小于768的屏幕 var smallScreen = windowWidth &lt; 768; // 轮播图板块适应 var $itemImages = $(&apos;#home_slide .item-image&apos;); $itemImages.each(function(i, item) &#123; var $item = $(item); var imgSrc = $item.data(smallScreen ? &apos;image-small&apos; : &apos;image-large&apos;); var imgAlt = $item.data(&apos;image-alt&apos;); $item.html(&apos;&lt;img src=&quot;&apos; + imgSrc + &apos;&quot; alt=&quot;&apos; + imgAlt + &apos;&quot;/&gt;&apos;); $item.css(&apos;backgroundImage&apos;, &apos;url(&apos; + imgSrc + &apos;)&apos;); &#125;);&#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>responsive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BDL2.0笔记]]></title>
    <url>%2F2016%2F04%2F08%2FBDL2.0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这一篇讲解一下genero bdl语言。 Genero BDL 架构DATABASE：资料库GLOBAL：程式所使用的外部变数MAIN：主程式FUNCTION：函式REPORT：报表 .4gl-.42m.per-.42f Genero BDL 语言特点： 切分为 Client、Server 架构（GDC 与fgl），增进运行效率 以 XML Bsae 做为Client 及Server 端数据传递的架构 支持更多不同平台（OS）及数据库系统 可在运行阶段动态调整画面输出的格式（Layout Styles） 在部份新增的功能中引入基本的对象（Object）概念 看第一章，第三章，第四章，第八章，第九章，第十章 画面档FORM组成扩展名：per SCHEMA section（非必要部分）设置设计画面时，所需要引用到的数据库。 如果在『per』中没有指定SCHEMA，系统缺省为FORMONLY，即表示此不引用数据库中字段型态、长度等数据。若未设置，则对后续SECTION 影响有下列二点： 不得使用 TABLES SECTION。 需于 ATTRIBUTES SECTION 中指定字段型态。 每一个 Form 都可以设置一个 SCHEMA section ，且可以定义任何 Database SCHEMA，当 FORM 字段被定义时会参考到此处所指定的 SCHEMA。 SCHEMA section 需注意到的重点是： 若制作 FORM 时，字段都不参考 SCHEMA 内容时，则 SCHEMA section 可写为 SCHEMA FORMONLY，在 ATTRIBUTES Section 中字段可用 FORMONLY.字段名称来定义字段 内容。 若设为 SCHEMA FORMONLY 时，不得使用 TABLES SECTION。 若设置为 SCHEMA db 【实际 database schema 时】，且设置 TABLE section 时，可参照 引用字段型态、长度进入 ATTRIBUTES section 段。 示例： SCHEMA FORMONLYLAYOUT (TEXT=&quot;SCHEMA SECTION&quot;) GRID grid_id &#123; Name [a ] &#125; END --GRID END --LAYOUTATTRIBUTES EDIT a = FORMONLY.a; 或SCHEMA example_databaseLAYOUT (TEXT=&quot;SCHEMA SECTION&quot;) GRID grid_id &#123; Name [a ] &#125; END --GRID END --LAYOUTTABLES example_table ATTRIBUTES EDIT a = a; ACTION DEFAULT section（非必要部分）定义 ACTION 显示于画面上的名称值及快速键设置。 ACTION DEFAULTS 主要是定义功能按键（Action）的属性，包含显示在画面文件上的文字、快速键（1.31 以上版本允许设置至多三组）、显示图片（注）、弹出式说明（Hint、Comments） 等属性，须搭配 4GL 程序才会有作用。 示例： ACTION DEFAULTS Action add (text=&quot;Append&quot;, ACCELERATOR=CONTROL-V ) Action del (text=&quot;Delete&quot;, ACCELERATOR=SHIFT-F2 ) Action zoom (text=&quot;Zoom&quot;, COMMENT=&quot;Open Zoom Window&quot; ) Action quit (text=&quot;Quit&quot;, ACCELERATOR=SHIFT-F5, IMAGE=&quot;quit&quot; )ENDLAYOUT (TEXT=&quot;ACTION DEFAULT SECTION&quot;) GRID grid_id &#123; Name [a ] &#125; END --GRIDEND --LAYOUTATTRIBUTES EDIT a=FORMONLY.a; 编译之后可以得到如下的运行画面： TOPMENU section（非必要部分）定义画面中的 TOPMENU 结构。 TOOLBAR section（非必要部分）定义画面中的 TOOLBAR 结构。 LAYOUT section（非必要部分）定义画面样式的主要 SECTION，在本SECTION 中须采用对象的概念，任何的设置均应以Container 视之，在结束处需加上END 注记以标示结束。 TABLES section（非必要部分）设置屏幕画面的显示字段所对应的数据库的 TABLE 名称。 ATTRIBUTES section（非必要部分）在 LAYOUT SECTION 中出现的字段、TAG 等，均需在此段中定义其类型或属性。 INSTRUCTION section（非必要部分）定义屏幕数组。当使用屏幕数组时才需定义。 画面档（PER）中只可用『–』作为批注符号，标示处至行尾均视为批注。 变量及运算变量的定义直接定义DEFINE employee_no CHAR(10) 对应数据库字段DATABASE database_idDEFINE p_employee_no LIKE employee_file.employee_no 上面的示范，定义p_employee_no 与数据库中的employee_file 这个table 的employee_no 字段有相同的数据型态。 变量的型态CHARVARCHARSTRINGDATEDATETIMEINTEGER 4SMALLINT 2FLOAT 8SMALLFLOAT 4DECIMAL(p,s)MONEY 变量的集合（Records）直接定义MAIN DEFINE rec RECORD id INTEGER, name VARCHAR(100), birth DATE END RECORDEND MAIN 此示范中，直接定义 rec 这个Records 中的各个变量型态。 对应数据库字段DATABASE example_databaseMAIN DEFINE cust01 RECORD LIKE customer.* DEFINE cust02 RECORD id LIKE customer.id, name LIKE customer.name, birth LIKE customer.birth, sales LIKE salesman.name END RECORDEND MAIN 此示范中，定义cust01 这个Record 的变量与数据库中的customer 这个table 的字段有相同的名称及数据型态。若在这组变量中有穿插非同一TABLE 字段，或是需要做顺序上的调动，则必需参照cust02 的作法，将变量组中的每一个项目独立写出。 变数的设置语法：LET variable = expression 示范：DATABASE dsMAIN DEFINE c1, c2 CHAR(10) LET c1 = &quot;Genero&quot; LET c2 = c1END MAIN 注：若变量类型为 CHAR 和变量类型为VARCHAR 时，指定给予的值有差异。 DATABASE dsMAIN DEFINE c1, c2 CHAR(10) DEFINE c3 VARCHAR(10) LET c1 = &quot;Genero&quot; LET c2 = c1 LET c3 = c1END MAIN 初始化一组变数的值若要初始化一组 RECORD 变数为NULL，或者是初始化为数据库Table 的缺省值，可利用INITIALIZE。 语法：INITIALIZE 变数串行 { LIKE 字段串行 | TO NULL } 示范： DATABASE dsMAIN DEFINE cr RECORD LIKE customer.* INITIALIZE cr.cust_name TO NULL INITIALIZE cr.* LIKE customer.*END MAIN 预定义完成变数以下说明一些系统的预先定义变量及用途： INT_FLAG：当设置DEFER INTERRUPT 时，系统即会在用户每次按下『中断键』时，将此变数设置为『TRUE』，须要程序恢复回原值（FALSE）。 STATUS：储存每次SQL 的运行状态。 常数的定义CONSTANT c1 = &quot;Drink&quot; -- 自行宣告为 STRINGCONSTANT c2 = 4711 -- 自行宣告为 INTEGERCONSTANT c3 SMALLINT = 12000 -- 自行修正为 INTEGERCONSTANT c4 CHAR(10) = &quot;abc&quot; -- 遵照设置为 CHAR(10) 预定义完成常数 NULL：即表示NULL。 TRUE：表示布尔逻辑中的『非零』值，缺省为『1』，但不可视为『1』运算。 FALSE：表示布尔逻辑中的『零』值，缺省为『0』，但不可视为『0』运算。 NOTFOUND：表示SQL 信息中的『找不到notfound』，缺省为『100』，但不可视为『100』运算。 表达式比较表达式数值表达式MAIN DEFINE i,j SMALLINT LET i = 9 LET j = 2 DISPLAY i + j DISPLAY i - j DISPLAY i * j DISPLAY i / j DISPLAY j ** i DISPLAY i mod jEND MAIN 字符串表达式MAIN DEFINE i,j,k CHAR(20) LET i = &quot;TIPTOP GP&quot; LET j = &quot;Genero BDL&quot; DISPLAY i , j CLIPPED DISPLAY i || j CLIPPED DISPLAY i || j || k DISPLAY i[4,6] DISPLAY i CLIPPED , j CLIPPED DISPLAY 5 SPACES,iEND MAIN 字符串链接：,|| str[m,n] LET i = &quot;TIPTOP GP Genero BDL&quot; LET j= i[1,9] DISPLAY &quot; i= &quot;, iShow: i=TIPTOP GP USING：针对数值或日期设置其打印或显示于画面上的格式，若需设置时，须注意溢位（overflow）的问题。LET salary =1000PRINT salary USING &quot; $##,### &quot;DISPLAY &quot;yyyy-mm-dd :&quot;,TODAY USING &quot;yyyy-mm-dd&quot;Show1: $ _1,000Show1: yyyy-mm-dd :2004-06-11 CLIPPED：清除尾部空白 LET i = &quot;TIPTOP GP &quot; LET j = &quot;Genero BDL&quot; DISPLAY “i&amp;j=&quot;, i CLIPPED, j CLIPPEDShow: i&amp;j= TIPTOP GP Genero BDL SPACES：输出空白字符串 LET i = &quot;TIPTOP GP &quot; LET j = &quot;Genero BDL&quot; DISPLAY “i&amp;j=&quot;, i ,8 SPACES, j CLIPPEDShow: i&amp;j= TIPTOP GP Genero BDL 逻辑、日期、字段表达式 全域变数指定语法一：直接写定 GLOBALS 区块GLOBALS declaration-statement [,...]END GLOBALS 语法二：读入已写好的共同设置档（外部档案）。GLOBALS &quot;filename&quot; 变数的生命周期DATABASE dsGLOBALS DEFINE g_employee CHAR(10)END GLOBALS DEFINE g_tty CHAR(32)MAIN DEFINE answer CHAR(1)END MAINFUNCTION ins_employee() DEFINE flag CHAR(1), change SMALLINTEND FUNCTION 程控流程Module 程序架构程序部份可区分为MAIN( )函式、一般FUNCTION( )函式及报表结构定义REPORT( )函式等。 MAIN( ) 函式MAIN( )函式是程序运行的入口，一个完整可运行的程序必定仅含一个MAIN( )函式。 示范： MAIN DISPLAY &quot;Hello, world!&quot;END MAIN DEFER 设置 此设置可定义程序是否要拦截『当用户按下中断（interrupt）或离开（quit）键』时所送出的系统讯号。 语法：DEFER { INTERRUPT | QUIT } OPTIONS 设置 此段设置可变更系统缺省的选项。 Exceptions 设置 定义当遇到 SQL 错误时，系统要采取何种方式因应。此设置不限MAIN( )函式可设置，此设置在程序中想改变因应方式时可再次指定，即可以新设置方式处理。 语法：WHENEVER [ANY] ERROR { CONTINUE | STOP | CALL function | GOTO label } MAIN OPTIONS #改变一些系统缺省值 FORM LINE FIRST + 2, #画面开始的位置 MESSAGE LINE LAST, #信息显示的位置 PROMPT LINE LAST, #提示信息的位置 INPUT NO WRAP #录入的方式：不打转 DEFER INTERRUPT WHENEVER ERROR STOP DISPLAY “Change Exception!” WHENEVER ERROR CALL chk_err #此处的CALL 是没有括号的END MAINFUNCTION chk_err( ) DISPLAY “Error Happened!”END FUNCTION 一般 FUNCTION( ) 函式运行某个特定功能的子函式，程序中可将某些功能独立编写为一个个的子函式，以供互相呼叫之用，如此即可趋近模块化的目标。同一支完整作业内的Function 名称不能相同。 示范： MAIN CALL sayIt()END MAINFUNCTION sayIt() DISPLAY &quot;Hello, world!&quot;END FUNCTION 报表结构 REPORT( )函式为函式的一种，专门用来设置报表打印格式，后续章节有详细的介绍。 REPORT 结构示范： REPORT test_rep(sr)．．． FORMAT PAGE HEADER BEFORE GROUP ON EVERY ROW AFTER GROUP ．．．END REPORT 4GL 批注符号 {}：可以将某个范围做备注。 #：将某行做备注。 –：将某行做备注。 CALL运行指定的函式（Function），若有回传值，以RETURNING 接回。 语法：CALL function ( [ parameter [,…] ] ) [ RETURNING variable [,…] ] RETURN传回原呼叫函式所需的变量值，并停止此子函式的运行。 语法：RETURN [ value [,…] ] 示范一：回传单一值 MAIN DEFINE var1 CHAR(10) DEFINE var2 CHAR(2) LET var1 = foo() DISPLAY &quot;var1 = &quot; || var1 CALL foo() RETURNING var2 DISPLAY &quot;var2 = &quot; || var2END MAINFUNCTION foo() RETURN &quot;Hello&quot;END FUNCTION 示范二：回传单一值（布尔值）MAIN IF foo() THEN DISPLAY &quot;Choice is OK!” END IFEND MAINFUNCTION foo() RETURN TRUEEND FUNCTION 示范三：回传多值MAIN DEFINE var1 CHAR(15) DEFINE var2 CHAR(15) CALL foo() RETURNING var1, var2 DISPLAY var1, var2END MAINFUNCTION foo() DEFINE r1 CHAR(15) DEFINE r2 CHAR(15) LET r1 = &quot;return value 1&quot; LET r2 = &quot;return value 2&quot; RETURN r1, r2END FUNCTION 示范4-1：(test1.4gl)MAIN DISPLAY &quot;MAIN FUNCTION&quot; CALL a1() CALL a2() RUN &quot;fglrun test3&quot;END MAINFUNCTION a1() DISPLAY &quot;SUB FUNCTION a1()&quot;END FUNCTION 以上程序段会呼叫另外两个 Function，并且利用RUN 指令运行一道unix 指令。 示范 4-2：(test2.4gl )FUNCTION a2() # a2 function DISPLAY &quot;SUB FUNCTION a2()&quot;END FUNCTION 示范 4-3：(test3.4gl )MAIN DISPLAY &quot;This is test3.4gl&quot;END MAIN IF依条件运行程序 语法：IF condition THEN statement [...][ ELSE statement [...]]END IF 示范：MAIN DEFINE name CHAR(20) LET name = &quot;John Smith&quot; IF name MATCHES &quot;John*&quot; THEN DISPLAY &quot;The first name is too common to be displayed.&quot; IF name MATCHES &quot;*Smith&quot; THEN DISPLAY &quot;Even the last name is too common to be displayed.&quot; END IF ELSE DISPLAY &quot;The name is &quot; , name , &quot;.&quot; END IFEND MAIN CASE运行符合条件的特定程序段 语法一：CASE expression-1 WHEN expression-2 &#123; statement | EXIT CASE &#125; [...] [ OTHERWISE &#123; statement | EXIT CASE &#125; [...] ]END CASE 说明：若判别式很单纯，例如：只需判断一个数字的数值，因该值不同而有不同的选项时，可采用此写法（如下列示范）。若判断式较复杂，或可能同时出现两种以上的条件（成立）时，请改用语法二。 示范： MAIN DEFINE v CHAR(10) LET v = &quot;C1&quot; CASE v WHEN &quot;C1&quot; DISPLAY &quot;Value is C1&quot; WHEN &quot;C2&quot; DISPLAY &quot;Value is C2&quot; WHEN &quot;C3&quot; DISPLAY &quot;Value is C3&quot; OTHERWISE DISPLAY &quot;Unexpected value&quot; END CASEEND MAIN 语法二：CASE WHEN boolean-expression &#123; statement | EXIT CASE &#125; [...] [ OTHERWISE &#123; statement | EXIT CASE &#125; [...] ]END CASE 示范：MAIN DEFINE v CHAR(10) LET v = &quot;C1&quot; CASE WHEN ( v=&quot;C1&quot; OR v=&quot;C2&quot; ) DISPLAY &quot;Value is either C1 or C2&quot; WHEN ( v=&quot;C3&quot; OR v=&quot;C4&quot; ) DISPLAY &quot;Value is either C3 or C4&quot; OTHERWISE DISPLAY &quot;Unexpected value&quot; END CASEEND MAIN 注：当采用此种语法时需注意：需避免同时有两种情况成立的情形发生。若在未注意的状况下发生，则系统仅会走第一条符合条件的路径。MAIN DEFINE a,b INT LET a = b := 10 CASE WHEN a=10 DISPLAY &quot; a is ok &quot; WHEN b=20 DISPLAY &quot; b is ok &quot; OTHERWISE DISPLAY &quot; nothing is ok &quot; END CASEEND MAIN 画面仅会显示『 a is ok 』 FOR依指定的次数运行程序 语法：FOR counter = start TO finish [ STEP value ] statement [...]END FOR 示范： MAIN DEFINE i, i_min, i_max INTEGER LET i_min = 1 LET i_max = 10 DISPLAY &quot;Look how well I can count from &quot; , i_min , &quot; to &quot; , i_max DISPLAY &quot;I can count forwards...&quot; FOR i = i_min TO i_max DISPLAY i END FOR DISPLAY &quot;... and backwards!&quot; FOR i = i_max TO i_min STEP -1 DISPLAY i END FOREND MAIN WHILE运行程序直到条件式不成立为止 语法：WHILE b-expression statement [...]END WHILE 示范： MAIN DEFINE a,b INTEGER LET a=20 LET b=1 WHILE a &gt; b DISPLAY a , &quot; &gt; &quot; , b LET b = b + 1 END WHILEEND MAIN CONTINUE重新运行循环 语法：CONTINUE { FOR | FOREACH | MENU | CONSTRUCT | INPUT | WHILE } 示范：MAIN DEFINE i INTEGER LET i = 0 WHILE i &lt; 5 LET i = i + 1 DISPLAY &quot;i=&quot; || i CONTINUE WHILE DISPLAY &quot;This will never be displayed !&quot; END WHILEEND MAIN EXIT离开控制段语法：EXIT { CASE | FOR | MENU | CONSTRUCT | FOREACH | REPORT | DISPLAY | INPUT | WHILE | PROGRAM（注） } 示范：MAIN DEFINE i INTEGER LET i = 0 WHILE TRUE DISPLAY &quot;This is an infinite loop. How would you get out of here ?&quot; LET i = i + 1 IF i = 100 THEN EXIT WHILE END IF END WHILE DISPLAY &quot;Well done.&quot;END MAIN 注：若程序运行到 EXIT PROGRAM，则表示『正常离开作业』（非异常中止），所以不会有任何stderr 码传出。但此指令后可跟随 exit_code，exit_code 可为8bit 的数值，系统传出时会转换为正整数，以供原呼叫此作业之程序判别状态。 SLEEP程序依指定秒数暂停 语法： SLEEP seconds 注意：如果seconds &lt; 0 或 seconds IS NULL，则程序不会停止。 示范：MAIN DISPLAY &quot;Please wait 5 seconds...&quot; SLEEP 5 DISPLAY &quot;Thank you.&quot;END MAIN EL宣告程序注标。 语法： LABEL label-id： 注意：结尾处有一冒号（：）。 GOTO移到指定的程序段继续运行（为了程序的易读性与结构性，建议勿使用此指令）。 语法： GOTO： label-id 示范：MAIN DISPLAY &quot;Before GOTO&quot; GOTO: label_id1 DISPLAY &quot;Never Been Displayed&quot; LABEL label_id1: DISPLAY &quot;After GOTO&quot;END MAIN CURSOR 的应用数据的查询、更改在处理数据时，若只有单笔数据的选取，则可用单纯的SQL 指令即可（本书设置各位读者对SQL 指令均已熟悉，故不再说明SQL 指令的写法，请参阅其它SQL 语言介绍专书）。 若是要抓取多笔数据处理时，就会因抓取的特性不同（例如：一次只抓一笔数据处理，完成后再抓次笔，如『个人数据表』；或一次全部抓取，一起编辑，如『个人门禁进出记录表』等），而须使用不同的指标（CURSOR）。 在介绍指标（CURSOR）前，先介绍其它将应用到的相关指令。 CONSTRUCT此指令可让用户在画面上录入查询条件（通称Query By Example；QBE），以取得用户的查询范围数据。用户的查询数据会组成一串WHERE 指令（参下页批注），并置入设置好的变数中。若用户未录入任何条件，即按下『确定』离开CONSTRUCT，系统也会自动于此变量中补入『1=1』。 语法二：若字段名称和变量名称相同时，也可改采下列写法：CONSTRUCT BY NAME char_variable ON column_list 说明： char_variable 为接取用户录入数据的字符串变量（建议以STRING 格式变量接取） column_list 为对应到表格（TABLE）的字段名称清单（逗号隔开） field_list 为画面（WINDOW 或是FORM）上的字段代码清单（逗号隔开） 若有增加控制区段（CONTROL BLOCK，如ON ACTION 等），则就要加上『ENDCONSTRUCT』 示范：CONSTRUCT BY NAME l_str ON employee , salary ON IDLE 10 EXIT PROGRAMEND CONSTRUCT PREPARE若已经得到一个完整的WHERE 条件后，接下来即可将此条件，组合成SQL 字符串，再转换为一个完整且可以抓取符合条件的SQL 指令。 运行完 CONSTRUCT 后，系统只能得到一个『SQL 字符串（如上页示范的l_str）』，并非为『可运行的指令』，因此必须透过PREPARE 指令，将此SQL 字符串转换成『可运行的SQL指令』PREPARE 会将字符串传入数据库检查语法的正确性，再回传予一个prepared-id 以供后续呼叫之用。 语法：PREPARE statement-name FROM char_variable 说明： statement-name 是为一个PREPARE 完成后的替代代码（prepared-id） 运行 PREPARE 指令前须先组好SELECT 叙述。 FREE释放 PREPARE 的记录。 语法：FREE statement-name 示范：LET l_str = “employee=&apos;1000&apos; AND salary&gt;&apos;30000’ “LET l_sql = “ SELECT * FROM employee_file WHERE “,l_strPREPARE emp_pre FROM l_sql…FREE emp_pre 数据的查询Genero BDL 中有两种查询用的指标（CURSOR）可以运用在资料的查询： SCROLLING CURSOR通常运用在单档控制或查询类的程序，如『个人数据表』般的作业，可以随机抓取数据，一次一笔，再处理完后可以选择往前一比、往后一笔或往这个查询序列中的任何一笔数据移动的指针（CURSOR）。 语法：DECLARE cursor_id SCROLL CURSOR [WITH HOLD] FOR sql statementOPEN cursor_id [USING value]FETCH [first|last|previous|next| cursor_id INTO variableCLOSE cursor_id Non-SCROLLING CURSOR通常运用在双档控制程序或报表程序，如『个人出缺勤统计表』般的作业，抓取数据是依序（seguential）的方式，一次可以将合条件要求的资料一笔接着一笔的抓出，直到资料全数抓完（或被强制终止）为止。 语法：DECLARE cursor_id CURSOR [WITH HOLD] FOR sql statementFOREACH [first|last|previous|next| cursor_id INTO variable…END FOREACH SCROLLING CURSOR在运行『个人基本数据』的查询时，大多都会希望调用出来的资料，一次只有一个人的数据，这样比较容易聚焦，待查询或编修等工作完成后，再选择上一笔（或下一笔、任何一笔）数据来继续处理。如这类的『一次仅叫用单笔数据』，即为SCROLLING CURSOR 的作业范围。组成SCROLLING CURSOR 需以下列指令组成： DECLARE 叙述 语法：DECLARE cursor_id SCROLL CURSOR FROM [ prepared_id | char_variable ] 或 DECLARE cursor_id SCROLL CURSOR FOR select_statement 说明：DECLARE 后面可用『FOR 接SQL 查询指令』或用『FROM 接prepared-id 或是一个SQL查询字符串（注）』。 OPEN 叙述 语法：OPEN cursor_id 说明： 本指令可用 STATUS 来检视是否运行成功。 在后续要使用 cursor 时，之前要先将cursor OPEN 起来。 此叙述仅决定符合的数据，并不是真正从数据库中撷取数据。 注：在DECLARE 前可用PREPARE 指令运行SQL 字符串的转换及检查，除下列两种情况之外，其它情形均不一定需要写PREPARE 指令： SQL 查询指令中含有问号（Question Mark，参考本章中『USING 的用法』） SQL 查询指令中，拥有多组的数据可能来源（tables），如 CASE condiction WHEN “A” LET l_sql = “SELECT count(*) FROM abc_file “ WHEN “B” LET l_sql = “SELECT count(*) FROM def_file “END CASE 如上述情况，就必需使用 PREPARE 指令。 FETCH 叙述 语法：FETCH cursor_id INTO program_variable 说明：当宣告为 SCROLLING CURSOR 时，可以配合以下移动Cursor 的指令： CLOSE 叙述 语法：CLOSE cursor_id 说明：关闭并释放指标（CURSOR）的储存空间。 示范：DATABASE dsMAIN DEFINE a STRING DEFINE b,c CHAR(10) DECLARE test01 SCROLL CURSOR FOR SELECT zz01 FROM zz_file WHERE zz01 = “axmt410” OPEN test01 FETCH FIRST test01 INTO b DISPLAY b LET c = &quot;axmt410&quot; LET a = &quot;SELECT zz01 FROM zz_file WHERE zz01=&apos;&quot;,c CLIPPED,&quot;&apos; &quot; DECLARE test02 SCROLL CURSOR FROM a OPEN test02 FETCH LAST test02 INTO b DISPLAY bEND MAIN Non-SCROLLING CURSOR如查询『个人出缺勤统计表』（或打印）时，就会希望系统将指定人的数据全数列示出来（因为不希望看一笔、按键、再看一笔…），如果要达到这个动作，就必须改用Non-SCROLLINGCURSOR。以下分别列出Non-ScrollING 所需的控制指令： DECLARE 叙述 语法：DECLARE cursor_id CURSOR FROM [ prepared_id | char_variable ]或DECLARE cursor_id CURSOR FOR select_statement 说明：因为是『Non-SCROLLING CURSOR』，所以直接写『CURSOR』即可。 FOREACH（LOOP）叙述 示范： MAIN DEFINE clist ARRAY[200] OF RECORD cnum INTEGER, cname CHAR(50) END RECORD DEFINE i INTEGER DATABASE stores DECLARE c1 CURSOR FOR SELECT customer_num, cust_name FROM customer LET i=0 FOREACH c1 INTO clist[i+1].* LET i=i+1 DISPLAY clist[i].* END FOREACH DISPLAY &quot;Number of rows found: &quot;, iEND MAIN 数据的锁定当要进行数据的更改（UPDATE）时，最令人担心的就是有多人同时修到同一笔数据，因此，如何在开始编修前进行数据锁定（LOCK），以确保同时间只有一人能取得更改权，就成了在撰写程序时应注意的事。Genero BDL 中延续INFORMIX 4GL 的作法，采用LOCKINGCURSOR 对数据进行锁定。 LOCKING CURSOR又称『FOR UPDATE CURSOR』。通常运用在数据更新（UPDATE）程序段，将数据进行一个上锁的动作，以避免两组以上的联机同时再更新同一TABLE 下的同一笔数据（RECORD）。如果未作LOCK 的动作，可能再抓取数据的同时，有其它人正在进行数据的异动。此CURSOR 不属于数据查询的CURSOR，而需列为更新的CURSOR。 语法：DECLARE cursor_name CURSOR FOR sql statement FOR UPDATE [NOWAIT]OPEN cursor_id [USING value]FETCH cursor_id INTO variableCLOSE cursor_id DECLARE 叙述语法：DECLARE cursor_name CURSOR FOR select_statement FOR UPDATE [NOWAIT] 说明： 此处与 SCROLL CURSOR 或Non-SCROLL CURSOR 最大的差异。在于SQL 查询指令的最后须加上『FOR UPDATE（ORACLE 数据库需再加上NOWAIT）』，以标明此CURSOR 为LOCKING CURSOR。 此处亦可使用 FROM char_variable 方式来定义SQL 查询指令。 OPEN 叙述语法：OPEN cursor_id FETCH 叙述语法：FETCH cursor_id INTO program_variable 说明：此叙述除从数据库中取得资料外，在LOCKING CURSOR 的状态下，还会将所抓取到的资料锁住（LOCK），直到程序运行CLOSE cursor_id 的指令才会释放。 CLOSE 叙述语法：CLOSE cursor_id 说明：关闭并释放 CURSOR，待释放完成后，系统才会将被锁定的数据释放。 示范：DATABASE dsMAIN DEFINE g_gav01 LIKE gav_file.gav01 DEFINE g_gav08 LIKE gav_file.gav08 LET g_forupd_sql = &quot;SELECT * from gav_file WHERE gav01=? AND gav08=? &quot;, &quot; FOR UPDATE &quot; DECLARE p_per_lock_u CURSOR FROM g_forupd_sql OPEN p_per_lock_u USING g_gav01,g_gav08 OPEN p_per_lock_u USING g_gav01,g_gav08 IF STATUS THEN CLOSE p_per_lock_u RETURN END IF FETCH p_per_lock_u INTO g_gav_lock.* IF SQLCA.sqlcode THEN CLOSE p_per_lock_u RETURN END IF CLOSE p_per_lock_uEND MAIN USING 的使用时机此处的『USING』和先前谈变量格式输出的USING 有不同的意义。 有时，在组合 SQL 查询指令时，可能尚未取得相关的KEY 值供选取资料用，又不可以随意填不相关的值进入系统。 如上方示范：在组查询的SQL 指令时，根本无法确知将要锁定的资料为何，因此『可以在SQL 查询指令中使用问号（？），待后续要使用此CURSOR 时，再将已知值用USING 传入』。 语法：LET sql statement = “SELECT * FROM table_id WHERE key_value = ? “DECLARE cursor_name CURSOR FOR sql statement FOR UPDATE [NOWAIT]OPEN cursor_id USING value 说明： 问号（？）可以有多个。 USING 必需跟在OPEN 后方，若有多个问绕，则此处需依序对映，并以逗号隔开。 TRANSACTION当程序中运行『UPDATE』、『INSERT』、『DELETE』等指令时，都直接对数据库的数据进行异动，若有时数据需要多表格的同时连动时，会期望『所有的动作一起写入或一起毁弃』时，可采用『TRANSACTION』作法。 在一个 TRANSACTION 开始后（以『BEGIN WORK』指令开始），所有的『UPDATE』、『INSERT』、『DELETE』指令均不会对实体数据库做动作，一直到结束后，依照不同的条件进行写入实体数据库（以『COMMIT WORK』指令做整批写入）、或运行变更毁弃（以『ROLLBACK WORK』指令进行）的动作。 语法示范：BEGIN WORK [ UPDATE statement ] [ INSERT statement ] [ DELETE statement ]IF ( condiction ) THEN COMMINT WORKELSE ROLLBACK WORKEND IF 说明： BEGIN WORK 开始后，一定要有COMMIT WORK 或ROLLBACK WORK 做数据是否写入的判断。 TRANSACTION 区中的程序尽量不要太长，以免影响需要调用同笔数据的其它用户（但用户本身不受影响，未COMMIT WORK 前仍可调用已变更数据）。 有些 DDL 指令（如CREATE TABLE）会有自动COMMIT WORK 功能。 当 COMMIT WORK（或ROLLBACK WORK）时，会自动关闭无宣告『WITH HOLD』的CURSOR。 大量运行同一 SQL 指令（EXECUTE）当系统要运行大量的同一 SQL 指令（例如：要在工作数据中连续INSERT 十年的工作日数据），系统运行效能就会变成一个令人关心的议题。如塞入工作日数据，当然可以写做： INSERT INTO work_date VALUES ( “2005/07/01” , “Friday”, “Weekday”) 然后再以一个 FOR LOOP 包起，这个作法一样可以运行，但效能还有可以改进的空间。程序的撰写若有强烈的效能考量，则可以考虑改用『EXECUTE』作法。 语法：PREPARE prepared_id FROM sql_statementEXECUTE prepared_id [USING variable_list ] [ INTO fvar [,...] ]FREE prepared_id 说明： EXECUTE 可以应用在『SELECT』、『UPDATE』、『INSERT』、『DELETE』等处。 使用 EXECUTE 时，尽量将KEY 值或其它需要变异的值，保留至EXECUTE 指令时再以USING 方式传入。 示范：FUNCTION update_customer_name( key, name ) DEFINE key INTEGER DEFINE name CHAR(10) PREPARE s1 FROM &quot;UPDATE customer SET name=? WHERE customer_num=?&quot; EXECUTE s1 USING name, key FREE s1END FUNCTION 大量运行新增指令（PUT..FLUSH）以上页塞入工作日数据示范来谈，除改用 EXECUTE 外还可以有更快速的作法，就是用『INSERT CURSOR』。Genero BDL 提供一INSERT CURSOR：『PUT…FLUSH』，示范如下所示： 语法：PREPARE prepared_id FROM INSERT_sql_statementDECLARE cursor_id [WITH HOLD] FOR prepared_idOPEN cursor_idPUT cursor_id FROM variable_listFLUSH cursor_idCLOSE cursor_idFREE cursor_idFREE prepared_id 示范： MAIN DEFINE i INTEGER DEFINE rec RECORD key INTEGER, name CHAR(30) END RECORD DATABASE stock PREPARE is FROM &quot;INSERT INTO item VALUES (?,?)&quot; DECLARE ic CURSOR FOR is BEGIN WORK OPEN ic FOR i=1 TO 100 LET rec.key = i LET rec.name = &quot;Item #&quot; || i PUT ic FROM rec.* IF i MOD 50 = 0 THEN FLUSH ic END IF END FOR CLOSE ic COMMIT WORK FREE ic FREE isEND MAIN ARRAY 的应用ARRAY（数组）数组可以依一维，二维或三维数组方式来储存数据 固定数组（Static Array）定义ARRAY [ intconst [,intconst [,intconst] ] ] OF datatype 动态数组（Dynamic Array）定义DYNAMIC ARRAY [ WITH DIMENSION rank ] OF datatype 物件 INPUT ARRAYInput Array 可以让用户透过Screen Record 录入数据 DISPLAY ARRAY将程序数组的值显示在画面上 REPORT 撰写BDL 要印制出一份报表，程序分成二个部份： 主程序中先驱动 REPORT DRIVER，并且撷取报表所需报表的数据。 取得数据后进入 REPORT FUNCTION，做报表格式的设置，例如报表的版面设置、以及表头、表身、表尾如何安排。 FUNCTION 中启动REPORTSTART REPORT语法：START REPORT rep_name [TO { SCREEN |FILE filename | PRINTER } ] 说明： 这个指令是在驱动 REPORT DRIVER。 TO SCREEN：为系统DEFAULT 可不写。 TO FILE filenme：将REPORT 的结果送到一个档案中(档名自订)。 TO PRINTER：将REPORT 结果送到打印机(系统打印机)。 若(2)、(3)都不写，则系统会将结果自动送到屏幕输出。 OUTPUT TO REPORT 叙述语法：OUTPUT TO REPORT rep_name(expr_list) 说明：该功能类似 CALL function，并传递参数，将数据送到REPORT FUNCTION。 FIENSH REPORT 叙述语法：FINISH REPORT rep_name 说明：此指令为结束报表印制的指令。 4GL 报表示范： FUNCTION sel_employee( ) DEFINE p_employee RECORD LIKE employee_file.* DECLARE emp_cs CURSOR FOR SELECT * FROM employee_file : START REPORT emp_rep : FOREACH emp_cs INTO p_employee.* OUTPUT TO REPORT emp_rep(p_employee.*) END FOREACH : FINISH REPORT emp_repEND FUNCTIONREPORT emp_rep(s_employee) DEFINE s_employee RECORD LIKE employee_file.* FORMAT : :END REPORT REPORT FUNCTION 的组成REPORT report_name(expr_list) [DEFINE define_statement] [OUTPUT output_statement] [ORDER BY sort_list] FORMAT control_block statement : :END REPORT REPORT report_name（expr_list）叙述report_name 即是 REPORT 的名称，与START REPORT rep_name 的rep_name 是一致的。expr_list 为先前主程序所传递的参数。 OUTPUT Section此叙述为定义报表的边界，报表长度。以下介绍设置报表边界的指令，及若没有 OUPUT叙述时，系统的缺省值。 ORDER BY Section语法:ORDER [ EXTERNAL ] BY field_id_1 [ASC|DESC] , field_id_2 [ASC|DESC] , … 说明: ORDER BY 区间，主要是作排序字段用，以逗号分开，摆在最前面的字段为主键，同时只能用所接收的参数内的字段来排序。 ORDER BY 会先将数据排序过并存在暂存盘中，配合BEFORE GROUP OF 或 AFTER GROUP OF 区段排序后再由暂存档印出。 加上 EXTERNAL 即表示传入的数据已经经过外部（START REPORT 时）的排序，因此此处仅为注标，系统不会重复的运行工作。 若后续于 FORMAT 中有使用GROUP 的分群输出功能，则一定要有ORDER BY 宣告，必要时可搭配上述EXTRRNAL 功能。 FORMAT Section这个部份为 REPORT FUNCTION 的重心，所以报表的排版均由此部份控制。以下说明此SECTION 的每个CONTROL BLOCKS 用途。 FIRST PAGE HEADER ：报表第一页的表头控制段。 PAGE HEADER ：报表每一页的表头控制段。 BEFORE GROUP OF ：设置在一组数据的开始之前所必须运行的叙述。 ON EVERY ROW ：指定每一笔记录的输出格式。 AFTER GROUP OF ：在控制区段设置一组数据之后必须运行的叙述。 PAGE TRAILER ：每一页报表页尾的控制段。 ON LAST ROW ：所有数据印完后要做的动作，例如”总计”。 FORMAT 内可用指令PRINT 打印信息或资料。 可用逗号【，】分隔要打印的字段。 一个 PRINT 指令即占用一行的打印空间。 若以分号【；】结尾，表示下一个PRINT 指令亦接续本行打印。 示范：PRINT “员工编号：”, employee_no SKIP 打印时要跳几行或几页。 若在打印报表中有使用 IF、CASE 等流程判断指令，需确保每个流程的每一个情境下，所用的报表打印空间（行数）是一致的。 示范：SKIP 2 LINES 跳两行SKIP TO TOP OF PAGE 跳页 NEED NEED integer_value LINES 在打印前，先确定是否有足够的剩余行数，可供接下来打印，如果不够将先跳页后，再继续往下印。 打印时可运用的表达式或函数 CLIPPED：将字符串后面的空白清掉。 USING：针对数值定其打印的格式。 COLUMN：指定输出的行位置。 LINENO：取得当前打印行的列号值。 PAGENO：取得当前的页数。 SPACES：传回空白。 TIME：传回系统时间，格式:”hh:mm:ss” TODAY：传回系统今天的日期。 LENGTH(expr)：expr 为一字符串变量，其会传回expr 的长度。 群组函数在群组区块中，提供以下函数，方便在撰写报表时的数值运算。 GROUP SUM(expression) :GROUP 区块中，数值的加总。 GROUP COUNT(*) :GROUP 区块中，资料的总数。 GROUP MIN(expression) :GROUP 区块中，取得数值的最小值。 GROUP MAX(expression) :GROUP 区块中，取得数值的最大值。 GROUP AVG(expression) :GROUP 区块中，取得数值的平均值。 GROUP PERCENT(*) :GROUP 区块中，资料的百分比。]]></content>
      <tags>
        <tag>BDL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端touch事件]]></title>
    <url>%2F2016%2F03%2F20%2Ftouch%2F</url>
    <content type="text"><![CDATA[移动端touch事件总结 轮播图触摸事件重点掌握touch事件对象的touches属性。例如：e.touches[0].clientX//规定偏移多少要进行翻页var OFFSET = 50;// 轮播图触摸$('.carousel').each(function(i, item) &#123; var startX, endX; item.addEventListener('touchstart', function(e) &#123; // console.log(e); startX = e.touches[0].clientX; console.log(startX); console.log('start'); e.preventDefault(); &#125;); item.addEventListener('touchmove', function(e) &#123; endX = e.touches[0].clientX; console.log(endX); e.preventDefault(); &#125;); item.addEventListener('touchend', function(e) &#123; console.log('over'); var offsetX = endX - startX; console.log(offsetX); if (offsetX &gt; OFFSET) &#123; // 上一张 $(this).carousel('prev'); &#125; else if (offsetX &lt; -OFFSET) &#123; // 上一张 $(this).carousel('next'); &#125; e.preventDefault(); &#125;);&#125;); 实例&lt;body&gt; &lt;p id="desc"&gt;&lt;/p&gt; &lt;div id="touchPad" class="touchpad"&gt;触摸板&lt;/div&gt; &lt;div id="ball" class="ball"&gt;&lt;/div&gt; &lt;script src="../js/zepto.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; var touchpad = document.querySelector('#touchPad'), ball = document.querySelector('#ball'), desc = document.querySelector('#desc'); //获取touch的点(兼容mouse事件) var getTouchPos = function(e) &#123; var touches = e.touches; if (touches &amp;&amp; touches[0]) &#123; return &#123; x: touches[0].clientX, y: touches[0].clientY &#125;; &#125; return &#123; x: e.clientX, y: e.clientY &#125;; &#125; //计算两点之间距离 var getDist = function(p1, p2) &#123; if (!p1 || !p2) return 0; return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y)); &#125; //计算两点之间所成角度 var getAngle = function(p1, p2) &#123; var r = Math.atan2(p2.y - p1.y, p2.x - p1.x); var a = r * 180 / Math.PI; return a; &#125;; //获取swipe的方向 var getSwipeDirection = function(p2, p1) &#123; var dx = p2.x - p1.x; var dy = -p2.y + p1.y; var angle = Math.atan2(dy, dx) * 180 / Math.PI; if (angle &lt; 45 &amp;&amp; angle &gt; -45) return "right"; if (angle &gt;= 45 &amp;&amp; angle &lt; 135) return "top"; if (angle &gt;= 135 || angle &lt; -135) return "left"; if (angle &gt;= -135 &amp;&amp; angle &lt;= -45) return "bottom"; &#125; var startEvtHandler = function(e) &#123; var pos = getTouchPos(e); ball.style.left = pos.x + 'px'; ball.style.top = pos.y + 'px'; ball.style.display = 'block'; var touches = e.touches; if (!touches || touches.length == 1) &#123; //touches为空，代表鼠标点击 point_start = getTouchPos(e); time_start = Date.now(); &#125; &#125; var moveEvtHandler = function(e) &#123; var pos = getTouchPos(e); ball.style.left = pos.x + 'px'; ball.style.top = pos.y + 'px'; point_end = getTouchPos(e); e.preventDefault(); &#125; //touchend的touches和targetTouches没有对象，只有changeTouches才有 var endEvtHandler = function(e) &#123; ball.style.display = 'none'; var time_end = Date.now(); //距离和时间都符合 if (getDist(point_start, point_end) &gt; SWIPE_DISTANCE &amp;&amp; time_start - time_end &lt; SWIPE_TIME) &#123; var dir = getSwipeDirection(point_end, point_start); touchPad.innerHTML = 'swipe' + dir; &#125; &#125; var SWIPE_DISTANCE = 30; //移动30px之后才认为swipe事件 var SWIPE_TIME = 500; //swipe最大经历时间 var point_start, point_end, time_start, time_end; //判断是PC或者移动设备 var startEvt, moveEvt, endEvt; if ("ontouchstart" in window) &#123; startEvt = "touchstart"; moveEvt = "touchmove"; endEvt = "touchend"; &#125; else &#123; startEvt = "mousedown"; moveEvt = "mousemove"; endEvt = "mouseup"; &#125; touchpad.addEventListener(startEvt, startEvtHandler); touchpad.addEventListener(moveEvt, moveEvtHandler); touchpad.addEventListener(endEvt, endEvtHandler); &lt;/script&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端笔记（meta标签）]]></title>
    <url>%2F2016%2F03%2F01%2Fmoble%2F</url>
    <content type="text"><![CDATA[移动端常用meta标签整理 百度禁止转码通过百度手机打开网页时，百度可能会对你的网页进行转码，往你页面贴上它的广告，非常之恶心。不过我们可以通过这个meta标签来禁止它：&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt; 添h加到主屏后的标题（IOS）&lt;meta name="apple-mobile-web-app-title" content="标题"&gt; 启用 WebApp 全屏模式（IOS）当网站添加到主屏幕后再点击进行启动时，可隐藏地址栏（从浏览器跳转或输入链接进入并没有此效果）&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;meta name="apple-touch-fullscreen" content="yes" /&gt; PS：然而，经本人用5S测试，设置”apple-touch-fullscreen”并没有什么卵用，希望了解者能在底部评论告知 设置状态栏的背景颜色（IOS）设置状态栏的背景颜色，只有在 name=”apple-mobile-web-app-capable” content=”yes” 时生效&lt;meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" /&gt; 上面content 参数说明： default ：状态栏背景是白色。 black ：状态栏背景是黑色。 black-translucent ：状态栏背景是半透明。 如果设置为 default 或 black ,网页内容从状态栏底部开始。 如果设置为 black-translucent ,网页内容充满整个屏幕，顶部会被状态栏遮挡。移动端手机号码识别（IOS）在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如：7位数字，形如：1234567。带括号及加号的数字，形如：(+86)123456789。双连接线的数字，形如：00-00-0011111位数字，形如：13800138000。 可能还有其他类型的数字也会被识别。我们可以通过如下的meta来关闭电话号码的自动识别：&lt;meta name="format-detection" content="telephone=no" /&gt; 但某些时候，你关闭电话自动识别后，又希望某些电话号码长按时能够链接到 iPhone 的拨号功能和短信功能，你可以使用下面的方法实现： 开启电话功能：&lt;a href=”tel:123456″&gt;123456&lt;/a&gt; 开启短信功能：&lt;a href=”sms:123456″&gt;123456&lt;/a&gt; 移动端邮箱识别（Android）与电话号码的识别一样，在安卓上会对符合邮箱格式的字符串进行识别，我们可以通过如下的meta来管别邮箱的自动识别： &lt;meta content=”email=no” name=”format-detection” /&gt;``` 同样地，我们也可以通过标签属性来开启长按邮箱地址弹出邮件发送的功能：```html&lt;a href="mailto:dooyoe@gmail.com"&gt;dooyoe@gmail.com&lt;/a&gt; 添加智能 App 广告条 Smart App Banner（IOS 6+ Safari）&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt; IOS Web app启动动画由于iPad 的启动画面是不包括状态栏区域的。所以启动图片需要减去状态栏区域所对应的方向上的20px大小，相应地在retina设备上要减去40px的大小&lt;!-- iPhone --&gt;&lt;link href="apple-touch-startup-image-320x460.png" media="(device-width: 320px)" rel="apple-touch-startup-image"&gt;&lt;!-- iPhone (Retina) --&gt;&lt;link href="apple-touch-startup-image-640x960.png" media="(device-width: 320px) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;&lt;!-- iPad (portrait) --&gt;&lt;link href="apple-touch-startup-image-768x1004.png" media="(device-width: 768px) and (orientation: portrait)" rel="apple-touch-startup-image"&gt;&lt;!-- iPad (landscape) --&gt;&lt;link href="apple-touch-startup-image-748x1024.png" media="(device-width: 768px) and (orientation: landscape)" rel="apple-touch-startup-image"&gt;&lt;!-- iPad (Retina, portrait) --&gt;&lt;link href="apple-touch-startup-image-1536x2008.png" media="(device-width: 1536px) and (orientation: portrait) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;&lt;!-- iPad (Retina, landscape) --&gt;&lt;link href="apple-touch-startup-image-2048x1496.png" media="(device-width: 1536px) and (orientation: landscape) and (-webkit-device-pixel-ratio: 2)" rel="apple-touch-startup-image"&gt;（landscape：横屏 | portrait：竖屏） 添加到主屏后的APP图标指定web app添加到主屏后的图标路径，有两种略微不同的方式：&lt;!-- 设计原图 --&gt;&lt;link href="short_cut_114x114.png" rel="apple-touch-icon-precomposed"&gt;&lt;!-- 添加高光效果 --&gt;&lt;link href="short_cut_114x114.png" rel="apple-touch-icon"&gt; 上面的rel参数说明： apple-touch-icon：在IOS6及以下的版本会自动为图标添加一层高光效果（IOS7开始已使用扁平化的设计风格） apple-touch-icon-precomposed：使用”设计原图图标” 可通过指定size属性来为不同的设备提供不同的图标（但通常来说，我们只需提供一个114 x 114 pixels大小的图标即可 ） 优先使用最新版本 IE 和 Chrome&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; 关闭iOS键盘首字母自动大写在iOS中，默认情况下键盘是开启首字母大写的功能的，如果禁用这个功能，可以这样：&lt;input type="text" autocapitalize="off" /&gt; 关闭iOS输入自动修正和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。如果不希望开启此功能，我们可以通过input标签属性来关闭掉：&lt;input type="text" autocorrect="off" /&gt; 禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 `meta viewport’。 移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2 */&#125; 快速回弹滚动我们先来看看回弹滚动在手机浏览器发展的历史： 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll; Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动； Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除； iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果。 在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：.xxx &#123; overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch;&#125; PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个 iDangero Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条，官方地址：http://www.idangero.us/sliders/swiper/index.php 移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：.user-select-none &#123; -webkit-user-select: none; /* Chrome all / Safari all */ -moz-user-select: none; /* Firefox all （移动端不需要） */ -ms-user-select: none; /* IE 10+ */ &#125; 移动端取消touch高亮效果在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来进行全局的禁止：html &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 但这个方法在三星的机子上无效，有一种妥协的方法是把页面非真实跳转链接的a标签换成其它标签，可以解决这个问题。 如何禁止保存或拷贝图像（IOS）通常当你在手机或者pad上长按图像 img ，会弹出选项 存储图像 或者 拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：img &#123; -webkit-touch-callout: none; &#125; calc用法&lt;div class="calc"&gt;我是测试calc&lt;/div&gt;.calc&#123; margin-left:50px; padding-left:2rem; width:calc(100%-50px-2rem); height:10rem;&#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML简介]]></title>
    <url>%2F2016%2F02%2F20%2Fxml%2F</url>
    <content type="text"><![CDATA[XML用法创建文档。大家都知道，Xml是一种基于对象的语言，也就是说，在JavaScript中，很多东西也都是面向对象的。可以使用new关键字创建一个对象。当然，创建一个Xml文档也不例外。var xmlDoc = new ActiveXObject(“Msxml2.DOMDocument.3.0”); 添加节点。其实，使用JavaScript操作Xml，和使用C#操作Xml有着几乎相同的方法。我们可以使用C#中一样的方法appendChild()方法来实现添加XML节点。说到这里你该问如何创建Xml节点了，其实还是跟C#相同的方法 var root = xmlDoc.createElement(“root”); 将这个root节点添加到xmlDoc这个文档中就很简单了： xmlDoc.appendChild(root); 现在，xmlDoc中就有了一个根节点了。需要注意的是，一个Xml文档只能有一个根节点。其它的节点个数不限。 得到节点。查询节点的方法就很多了。可以使用一个一个节点遍历，也可以使用selectSingleNode()方法或者selectNodes()方法。而得到一个文档根节点的方法则是通过属性documentElement来得到。那么得到xmlDoc的根节点就是 var rootNode = xmlDoc.documentElement;现在我们向root节点中添加一个book节点：var book = xmlDoc.createElement(“book”); root.appendChild(bookNode); 那么得到book节点就是：var bookNode = root.selectSingleNode(“book”);或者var bookNode = root.selectNodes(“book”)[0]; 或者var bookNode = root.firstNode;你可以使用任何一种方法来得到自己想要的节点。 删除节点。其实这个功能使用量是非常少的。你可以使用removeChild()方法来操作。这里不再详细说明。 一些代码示例//根据文本创建xml对象function createXml(data)&#123; if(!data)&#123; return null; &#125; var xml = null; try&#123; xml = new ActiveXObject(&apos;Microsoft.XMLDOM&apos;); xml.loadXML(data); &#125; catch(e)&#123; try&#123; xml = (new DOMParser()).parseFromString(data,&apos;text/xml&apos;); &#125; catch(e)&#123; return null; &#125; &#125; return xml;&#125;//调用函数 返回xmlDocvar xml = &apos;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;student class=&quot;高三1班&quot;&gt;&lt;username&gt;zhangsan&lt;/username&gt;&lt;age&gt;12&lt;/age&gt;&lt;/student&gt;&apos;;var obj = createXml(xml);//获取文本节点内容function getNodeText(node)&#123; if(window.ActiveXObject)&#123; return node.text; &#125;else&#123; if(node.nodeType == 1)&#123; return node.textContent; &#125; &#125;&#125;//获取节点的属性function getNodeAttribute(node,attrName)&#123; if(window.ActiveXObject)&#123; return node.getAttribute(attrName); &#125;else&#123; if(node.nodeType == 1)&#123; return node.attributes[attrName].value; &#125;else&#123; return undefined; &#125; &#125;&#125; xml基础示例&lt;!-- html部分 --&gt;&lt;h1&gt;产品列表&lt;/h1&gt;&lt;div id=&apos;div&apos;&gt;&lt;/div&gt;&lt;script&gt; //生XML对象。 function createXMLDom()&#123; if (window.ActiveXObject) var xmldoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); else if (document.implementation&amp;&amp;document.implementation.createDocument) var xmldoc=document.implementation.createDocument(&quot;&quot;,&quot;doc&quot;,null); xmldoc.async = false; //为了和FireFox一至，这里不能改为False; xmldoc.preserveWhiteSpace=true; return xmldoc; &#125; //加载XML文件。 var xmlDom=createXMLDom(); xmlDom.load(&quot;products.xml&quot;); //获得根节点 var root=xmlDom.documentElement; var data=&quot;&quot;; var names=root.getElementsByTagName(&quot;name&quot;); var ages=root.getElementsByTagName(&quot;price&quot;); var len=names.length; for(var i=0;i&lt;len;i++) &#123; data+=&quot;&lt;strong&gt;产品名称:&lt;/strong&gt;&quot;; data+=names[i].firstChild.nodeValue; data+=&quot; &lt;strong&gt;产品价格:&lt;/strong&gt;&quot;; data+=ages[i].firstChild.nodeValue; data+=&quot; &lt;br /&gt;&quot;; &#125; console.log(data) var div = document.getElementById(&apos;div&apos;) div.innerHTML = data;&lt;/script&gt; xml文档示例&lt;!-- 第一个 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;item&gt; &lt;title&gt;女司机在故障红灯前等40分钟报警求助(01/14 15:13)&lt;/title&gt; &lt;link&gt;http://news.sina.com.cn/s/2013-01-14/151326030803.shtml&lt;/link&gt; &lt;author&gt;WWW.SINA.COM.CN&lt;/author&gt; &lt;category&gt;社会新闻&lt;/category&gt; &lt;pubDate&gt;2013 07:13:46&lt;/pubDate&gt; &lt;comments&gt;&lt;/comments&gt; &lt;description&gt; 1月11日，记者联系到了李女士，她给记者讲述了当时的情况。“我等了40分钟，说到底是担心不遵守交通规则会不安全。”她说。遇红灯不变 女司机坚持等11日10时15分，李女士准备开车出门办事，却发现道路上异常拥堵。“平时我都是11点出门，因为有事当天才出门.... &lt;/description&gt;&lt;/item&gt;&lt;!-- 第二个 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;gb2312&quot;?&gt;&lt;products&gt; &lt;product id=&quot;1&quot;&gt; &lt;name&gt;iphone7s&lt;/name&gt; &lt;price&gt;5555&lt;/price&gt; &lt;/product&gt; &lt;product id=&quot;2&quot;&gt; &lt;name&gt;iphone7s&lt;/name&gt; &lt;price&gt;5555&lt;/price&gt; &lt;/product&gt; &lt;product id=&quot;3&quot;&gt; &lt;name&gt;iphone7s&lt;/name&gt; &lt;price&gt;5555&lt;/price&gt; &lt;/product&gt; &lt;product id=&quot;4&quot;&gt; &lt;name&gt;iphone7s&lt;/name&gt; &lt;price&gt;5555&lt;/price&gt; &lt;/product&gt; &lt;product id=&quot;5&quot;&gt; &lt;name&gt;iphone7s&lt;/name&gt; &lt;price&gt;5555&lt;/price&gt; &lt;/product&gt;&lt;/products&gt;&lt;!-- 第三个 --&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;users&gt; &lt;user&gt; &lt;id&gt;22240319830000&lt;/id&gt; &lt;name&gt;小李&lt;/name&gt; &lt;age&gt;26&lt;/age&gt; &lt;gender&gt;男&lt;/gender&gt; &lt;email&gt;xiao@hotmail.com&lt;/email&gt; &lt;phone&gt;13843140000&lt;/phone&gt; &lt;/user&gt; - &lt;user&gt; &lt;id&gt;22040319860001&lt;/id&gt; &lt;name&gt;小张&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;gender&gt;女&lt;/gender&gt; &lt;email&gt;zhang@hotmail.com&lt;/email&gt; &lt;phone&gt;13843140002&lt;/phone&gt;&lt;/user&gt;&lt;/users&gt; 其他&lt;script type=&quot;text/javascript&quot;&gt; var is_Ie = false; //是否为IE浏览器 if (window.ActiveXObject) &#123; is_Ie = true; &#125; //加载多浏览器兼容的xml文档 function loadXml(xmlUrl) &#123; var xmldoc = null; try &#123; xmldoc = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); &#125; catch (e) &#123; try &#123; xmldoc = document.implementation.createDocument(&quot;&quot;, &quot;&quot;, null); &#125; catch (e) &#123; alert(e.message); &#125; &#125; try &#123; //关闭异步加载 xmldoc.async = false; xmldoc.load(xmlUrl); return xmldoc; &#125; catch (e) &#123; alert(e.message); &#125; returnnull; &#125; //将一个xml文档格式的字符串换成xml文档 function createXml(xmlText) &#123; if (!xmlText) &#123; returnnull; try &#123; var xmldocm = new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); xmldocm.loadXML(xmlText); return xmldocm; &#125; catch (e) &#123; try &#123; return new DOMParse().parseFromString(xmlText, &quot;text/xml&quot;); &#125; catch (e) &#123; return null; &#125; &#125; &#125; &#125; //获取节点及其子节点的文本 function getXmlText(oNode) &#123; if (oNode.text) &#123; //IE return oNode.tex; &#125; var sText = &quot;&quot;; for (var i = 0; i &lt; oNode.childNodes.length; i++) &#123; //遍历子节点 if (oNode.childNodes[i].hasChildNodes()) &#123; //是否有子节点 sText += getXmlText(oNode.childNodes[i]); &#125; else &#123; sText += oNode[i].childNodes.nodeValue; &#125; &#125; return sText; &#125; //获取节点及其子节点的字符串标识 function getXml(oNode) &#123; if (oNode.xml) &#123; //IE return oNode.xml; &#125; var serializer = new XMLSerializer(); return serializer.serializeToString(oNode); &#125; //获取指定节点的文本 function getxmlnodeText(oNode) &#123; if (is_Ie) &#123; return oNode.text; &#125; else &#123; if (oNode.nodeType == 1) return oNode.textContent; &#125; &#125; //获取指定节点的属性值 function getxmlnodeattribute(oNode, attrName) &#123; if (is_Ie) &#123; return oNode.getAttribute(attrName); &#125; else &#123; if (oNode.nodeType == 1 || oNode.nodeType == &quot;1&quot;) return oNode.attributes[attrName].value; return &quot;undefined&quot;; &#125; &#125; &lt;/script&gt;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[js面向对象基础知识杂谈]]></title>
    <url>%2F2016%2F01%2F20%2Fjs-oop%2F</url>
    <content type="text"><![CDATA[js面向对象基础知识杂谈 万事万物皆为对象。 编程方式的比较： 传统的编程方式：通过声明变量给变量赋值，然后将其绑定到需要这些值的元素上element.innerHtml = var;给相应元素绑定事件 json方式：是把数据存放到json对象里，然后绑定给需要的元素。 面向对象方式：创建用到的对象，对每个对象添加相关的属性和方法。 面向对象编程方式：先分析需要哪些工具包然后依次开发每个工具包然后再使用已经写好的工具包实现我们想要的功能 好处：将代码分类管理 将产品相关代码放在一起 将购物车相关代码放在一起 使用的时候只需要使用某个工具即可 将一坨代码用函数包装起来，看做一个整体代码清晰容易维护容易发现问题代码可读性好易于团队化作战 – 一个制造工具，一个使用工具更多好处等待大家发现 开发思想： 面向对象编程就是先把工具包开发出来，这些工具包中包含很多小工具。 然后我们使用一个一个工具将整体功能就像搭积木一样搭建出来，而不是一句一句的，一坨一坨的毫无组织，毫无纪律的编写代码。 开发时，先看需要什么对象，然后对每个对象进行开发，抽象然后实例化。例如列表我们队每个列表进行实例，可以把它们放到数组里进行遍历。 json:json就是对象的一个实例。直接使用。后台给我们：json 字符串 xml 二进制数据json协议 传递数据使用json格式ajax中，后台给我们传的数据是json字符串（json协议）JSON.stringify(obj)将JSON转为字符串通过eval() 函数可以将JSON字符串转化为对象。JSON.parse(string)将字符串转为JSON对象； json xml 都是一种通用数据传输协议 都是用来描述数据 json体积小 传递速度快 带宽小 没XML那么通用 可以和JS对象互换 xml: 以XML格式描述一些内容 他是一种规范Xml只是描述数据的一种结构，比如大家常用的html就是采用这种结构描述的。。HTML就是XML 面向对象的三个作用： 保存一些常用的工具来简化我们的开发工作（封装功能）单一职责：解耦合（互不影响）大的工程拆分成多个模块（架构师要做的），每个模块互不影响。 描述数据 框架 初始化绑定交互目标： 理解什么是对象 会用面向对象分析网络上常见的网页案例 新闻 商城 教育平台 众筹 P2P 面向对象编程 对象的三个作用 从生活场景或网站开发场景提炼出对象的属性和方法。 开发流程先宏观思考需要哪些对象，针对每个对象编写其所需的属性和方法。然后实例化对象，定义属性值（所需数据），获取页面DOM元素，然后让DOM元素绑定数据。 获取DOM元素，可以定义为对象的一个属性，绑定数据可以在对象原型里定义这样一个方法。 传统编程方式 普通形式 定义变量 - 产品（名称，描述啥的） 获取元素 绑定元素 绑定事件 json保存数据 定义编程需要的数据（json保存产品标题描述啥的） 购物车（购物车名称总价格啥的） 获取元素 产品 获取元素 购物车 绑定数据 - 产品 绑定事件 - 产品 绑定数据 - 购物车 绑定事件 - 购物车 对象方式（需要几个工具包） 产品工具包 - 保存和产品有关的工具 购物车工具包 - 保存和购物车有关的工具 绑定各自数据和事件 对象的创建方式function Product() &#123; this.name =&apos;&apos;; this.price=&apos;&apos;; this.description = &apos;&apos;; this.doms = &#123; attr: document.getElementById(&apos;we&apos;), attr: document.getElementById(&apos;we&apos;), attr: document.getElementById(&apos;we&apos;) &#125;&#125;Product.prototype=&#123; bindDom:function()&#123; this.doms.title.innerHTML=this.title; this.doms.author.innerHTML=this.author; this.doms.date.innerHTML=this.date; this.doms.source.innerHTML=this.source; this.doms.content.innerHTML=this.content; &#125;, getPrice:function() &#123; return this.price &#125;, addToCart:function()&#123; alert(&apos;haha&apos;); &#125;&#125;var iphone = new Product();iphone.name = &apos;aaa&apos;;iphone.name = &apos;aaa&apos;; 面向对象与列表//产品对象/*对象内如何使用对象的属性和方法：this，对象外如何使用：先实例化，后用点语法*/function Product() &#123; /*属性 行为*/ this.name =&apos;&apos;; this.price=&apos;&apos;; this.description = &apos;&apos;; this.youhuijia=&apos;&apos;; this.zhekou = &apos;&apos; this.sales = &apos;&apos; this.image=&apos;&apos;&#125;Product.prototype=&#123; bindDom:function()&#123; var str=&apos;&apos; str+=&apos;&lt;dl&gt;&apos; str+=&apos;&lt;dt&gt;&lt;a&gt;&lt;img src=&quot;&apos;+this.image+&apos;&quot; width=&quot;384&quot; height=&quot;225&quot; /&gt;&lt;/a&gt;&lt;/dt&gt;&apos; str+=&apos;&lt;dd&gt;&apos; str+=&apos;&lt;span&gt;&lt;a&gt;&lt;em&gt;&apos;+this.zhekou+&apos;折/&lt;/em&gt;&apos;+this.name+&apos;&lt;/a&gt;&lt;/span&gt;&apos; str+=&apos;&lt;/dd&gt;&apos; str+=&apos;&lt;dd class=&quot;price&quot;&gt;&apos; str+=&apos;&lt;em&gt;￥&apos;+this.price+&apos;&lt;/em&gt;&apos; str+=&apos;&lt;del&gt;￥&apos;+this.youhuijia+&apos;&lt;/del&gt;&apos; str+=&apos;&lt;i&gt;售量：&apos;+this.sales+&apos;&lt;/i&gt;&apos; str+=&apos;&lt;/dd&gt;&apos; str+=&apos;&lt;/dl&gt;&apos; return str; &#125;, bindEvents:function()&#123; &#125;&#125;/*搭积木开发 -- 代码可读性极高*/window.onload=function() &#123; /*假设这是ajax获取的json数据 -- 假设这是后台给你的数据*/ /*实例1*/ var product1 = new Product() product1.name = &apos;SKII&apos; product1.price = 1111 product1.youhuijia = 1000 product1.sales = 300 product1.zhekou = 3.5 product1.image = &apos;img/boutque10_r2_c2.jpg&apos; /*实例2*/ var product2 = new Product() product2.name = &apos;玉兰油&apos; product2.price = 1111 product2.youhuijia = 1000 product2.sales = 300 product2.zhekou = 3.5 product2.image = &apos;img/boutque10_r2_c2.jpg&apos; /*实例3*/ var product3 = new Product() product3.name = &apos;兰蔻&apos; product3.price = 1111 product3.youhuijia = 1000 product3.sales = 300 product3.zhekou = 3.5 product3.image = &apos;img/boutque10_r2_c2.jpg&apos; /*表示有多个产品 我们需要定义多个实例*/ var products = [product1,product2,product3] /*前端代码*/ /*前后台开发不影响，我们不必等待后端人员给我们数据*/ var str=&apos;&apos; for(var i = 0,len=products.length;i&lt;len;i++) &#123; str+= products[i].bindDom() &#125; var container = document.getElementById(&apos;container&apos;) container.innerHTML=str&#125; JS面向对象进阶目标 构造函数进阶 属性进阶 属性进阶2：共有私有属性 实例进阶 对象的作用进阶 使用对象封装框架 绑定进阶 - formateString 绑定进阶 - 模板技术 属性的set get&lt;script&gt; function dateFormat(date,format) &#123; var o = &#123; &quot;M+&quot; : date.getMonth()+1, //month &quot;d+&quot; : date.getDate(), //day &quot;h+&quot; : date.getHours(), //hour &quot;m+&quot; : date.getMinutes(), //minute &quot;s+&quot; : date.getSeconds(), //second &quot;q+&quot; : Math.floor((date.getMonth()+3)/3), //quarter &quot;S&quot; : date.getMilliseconds() //millisecond &#125; if(/(y+)/.test(format)) format=format.replace(RegExp.$1, (date.getFullYear()+&quot;&quot;).substr(4- RegExp.$1.length)); for(var k in o)if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(format)) format = format.replace(RegExp.$1, RegExp.$1.length==1? o[k] : (&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length)); return format; &#125; //产品对象 /*对象内如何使用对象的属性和方法：this，对象外如何使用：先实例化，后用点语法*/ /*类 -- 抽象对象*/ function Product(name,price) &#123; /*属性 行为 可以为空或者给默认值*/ this.name=name this.price=0; this.description = &apos;&apos;; this.zhekou = &apos;&apos; this.sales = &apos;&apos; this.produceDate /*我们的需求：自动计算打折后的价格*/ Object.defineProperty(this, &quot;price&quot;, &#123; get: function () &#123;return price*0.9;&#125;, set: function (value) &#123; /*大概普通产品的价格都在0--1万*/ if(value&gt;10000) &#123; alert(&apos;产品价格必须在0--1万之间&apos;); &#125;else&#123; price = value; &#125; &#125; &#125;); Object.defineProperty(this, &quot;produceDate&quot;, &#123; get: function () &#123; return dateFormat(produceDate,&apos;yyyy-MM-dd&apos;); &#125;, set: function (value) &#123; produceDate = value; &#125; &#125;); &#125; //定义对象的两种方式 Product.prototype=&#123; getPrice:function() &#123; return this.price &#125;, addToCart:function()&#123; alert(&apos;将物品添加到购物车&apos;) &#125; &#125; Product.prototype.buy=function()&#123; &#125; Product.prototype.addToCart=function()&#123; &#125; /*获取元素*/ var btn = document.getElementById(&apos;btn&apos;) var name = document.getElementById(&apos;pname&apos;) var price = document.getElementById(&apos;pprice&apos;) var sum = document.getElementById(&apos;sum&apos;) var des = document.getElementById(&apos;pdes&apos;) var youhuijia = document.getElementById(&apos;pyouhui&apos;) var zhekou = document.getElementById(&apos;pzhekou&apos;) var sales = document.getElementById(&apos;psales&apos;) var date = document.getElementById(&apos;date&apos;) /*搭积木开发 -- 代码可读性极高*/ window.onload=function() &#123; /*实例化 -- 实例 -- 具体*/ //如何使用 //对象的使用必须先实例化，对象定义好之后，都是抽象的，必须实例化成具体 var iphone = new Product() /*给对象的赋值赋值，也可以新增属性*/ iphone.name=&apos;iphone7&apos; iphone.price=6000 iphone.description=&apos;手机中的战斗机&apos; iphone.youhuijia=3000 iphone.zhekou=3.0 iphone.sales=40000 iphone.produceDate=new Date() /*绑定元素*/ /*通过点语法访问对象中的属性或者方法*/ name.innerHTML=iphone.name price.innerHTML=iphone.price des.innerHTML=iphone.description youhuijia.innerHTML=iphone.youhuijia zhekou.innerHTML=iphone.zhekou sales.innerHTML=iphone.sales date.innerHTML=iphone.produceDate /*绑定事件*/ btn.onclick = function()&#123; iphone.addToCart() &#125; &#125;&lt;/script&gt; 对象的公有属性-私有属性&lt;script&gt; function dateFormat(date,format)&#123; var o = &#123; &quot;M+&quot; : date.getMonth()+1, //month &quot;d+&quot; : date.getDate(), //day &quot;h+&quot; : date.getHours(), //hour &quot;m+&quot; : date.getMinutes(), //minute &quot;s+&quot; : date.getSeconds(), //second &quot;q+&quot; : Math.floor((date.getMonth()+3)/3), //quarter &quot;S&quot; : date.getMilliseconds() //millisecond &#125; if(/(y+)/.test(format)) format=format.replace(RegExp.$1, (date.getFullYear()+&quot;&quot;).substr(4- RegExp.$1.length)); for(var k in o)if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(format)) format = format.replace(RegExp.$1, RegExp.$1.length==1? o[k] : (&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length)); return format; &#125; //产品对象 /*对象内如何使用对象的属性和方法：this，对象外如何使用：先实例化，后用点语法*/ /*类 -- 抽象对象*/ function Product(name,price) &#123; /*属性 行为 可以为空或者给默认值*/ this.name=name this.price=1000; this.description = &apos;&apos;; this.zhekou = &apos;&apos; this.sales = &apos;&apos; this.produceDate /*我们的需求：自动计算打折后的价格*/ Object.defineProperty(this, &quot;price&quot;, &#123; value:5000000, writable: false, &#125;); Object.defineProperty(this, &quot;produceDate&quot;, &#123; get: function () &#123; return dateFormat(produceDate,&apos;yyyy年MM月dd日&apos;); &#125;, set: function (value) &#123; produceDate = value; &#125; &#125;); var that = this; this.config = &#123; btn: document.getElementById(&apos;btn&apos;), name : document.getElementById(&apos;pname&apos;), price : document.getElementById(&apos;pprice&apos;), sum : document.getElementById(&apos;sum&apos;), des : document.getElementById(&apos;pdes&apos;), youhuijia : document.getElementById(&apos;pyouhui&apos;), zhekou : document.getElementById(&apos;pzhekou&apos;), sales : document.getElementById(&apos;psales&apos;), date : document.getElementById(&apos;date&apos;) &#125; function bindDOM()&#123; /*绑定元素*/ /*通过点语法访问对象中的属性或者方法*/ that.config.name.innerHTML=that.name that.config.price.innerHTML=that.price that.config.des.innerHTML=that.description that.config.youhuijia.innerHTML=that.youhuijia that.config.zhekou.innerHTML=that.zhekou that.config.sales.innerHTML=that.sales that.config.date.innerHTML=that.produceDate &#125; function bindEvents()&#123; /*绑定事件*/ that.config.btn.onclick = function()&#123; that.addToCart() &#125; &#125; this.init = function()&#123; bindDOM() bindEvents() &#125; &#125; //定义对象的两种方式 Product.prototype=&#123; getPrice:function() &#123; return this.price &#125;, addToCart:function()&#123; alert(&apos;将物品添加到购物车&apos;) &#125; &#125; Product.prototype.buy=function()&#123; &#125; Product.prototype.addToCart=function()&#123; &#125; /*搭积木开发 -- 代码可读性极高*/ window.onload=function() &#123; /*实例化 -- 实例 -- 具体*/ //如何使用 //对象的使用必须先实例化，对象定义好之后，都是抽象的，必须实例化成具体 var iphone = new Product() /*给对象的赋值赋值，也可以新增属性*/ iphone.name=&apos;iphone7&apos; iphone.price=6000 iphone.description=&apos;手机中的战斗机&apos; iphone.youhuijia=3000 iphone.zhekou=3.0 iphone.sales=40000 iphone.produceDate=new Date() /*无法使用私有成员*/// iphone.bindDOM()// iphone.bindEvents() /*只能使用共有成员*/ iphone.init() &#125;&lt;/script&gt; 数据类型检测var num = 1var str = &apos;传智播客&apos;var bool=false;var arr=[];var obj=&#123;name:&apos;传智播客&apos;&#125;;var date = new Date();var fn = function()&#123;&#125;console.log(typeof &quot;abc&quot;) //&apos;string&apos;console.log(toString.call(123)) //[object Number]console.log(Object.prototype.toString.call(str) === &apos;[object String]&apos;) //-------&gt; true;console.log(arr instanceof Array) //---------------&gt; trueconsole.log(date.constructor === Date) //-----------&gt; true 原型对象进阶&lt;!-- 删除本对象拷贝的对象 --&gt;delete product.name//然后就可以访问到原型对象里的name属性了//hasOwnProperty : 看是不是对象自身下面的属性function Product()&#123; this.name=&apos;iphone&apos;&#125;Product.prototype=&#123; age:100&#125;var iphone = new Product()console.log(iphone.hasOwnProperty(&apos;name&apos;))console.log(iphone.hasOwnProperty(&apos;age&apos;))//给对象扩充功能//在JS源码 : 系统对象也是基于原型的程序 function Array()&#123; this.lenglth = 0; &#125; Array.prototype.push = function()&#123;&#125;; Array.prototype.sort = function()&#123;&#125;;*///尽量不要去修改或者添加系统对象下面的方法和属性 面向对象总结 封装框架 将一些常用的函数功能封装起来 面向对象编程 定义对象，编写属性和方法 数据描述 常用数据绑定：字符串相加方式，动态创建标签绑定，formateString，模板技术 引用类型、值类型、堆和栈、内存的生命周期、多种方式创建对象 多种方式创建对象 工厂模式： &lt;script&gt; /*一般游戏名称是我们自己取的，其他事默认值*/ /*那么怎么做呢？*/ function createPerson(name)&#123; //1.原料 var obj = new Object(); //2.加工 obj.name = name; obj.HP=100; obj.MP=100; obj.technologys=[&apos;普通攻击&apos;,&apos;横扫千军&apos;,&apos;地狱火&apos;,&apos;漫天飞雪&apos;]; obj.attack = function()&#123; alert(obj.name+&apos;发出攻击，导致对方10点伤害值&apos;) &#125;; obj.run = function()&#123; &#125;; //3.出场 return obj; &#125; var boy = createPerson(&apos;剑侠客&apos;); boy.attack(); boy.run() var girl = createPerson(&apos;炫舞天使&apos;); girl.attack();&lt;/script&gt; 构造函数-原型对象： 因为在原型对象中引用类型的值存在问题，就是一个对象将其更改，则其他对象都会受影响。 字面量形式 拷贝模式： //拷贝一个&lt;script&gt; //-------------------------拷贝创建对象核心代码-------------------------- /*函数的用处：就是将一个json对象 所有属性拷贝给另外一个对象*/ /*source：原始对象*/ /*target：目标对象*/ function extend(target,source) &#123; //遍历对象 for(var i in source)&#123; target[i] = source[i]; &#125; return target; &#125; //游戏随机生成名字 var boy = &#123; name:&apos;郭靖&apos; ,image:&apos;男性头像&apos; ,age:20 ,sex:&apos;男&apos; &#125;; var girl = &#123; name:&apos;黄蓉&apos; ,age:18 ,image:&apos;女性头像&apos; ,sex:&apos;女&apos; &#125;; /*六大神器之一*/ var zuixiake = extend(&#123;&#125;, boy); var huangrong = extend(&#123;&#125;,girl) alert(zuixiake.name); alert(zuixiake.sex); console.log(huangrong.name)&lt;/script&gt;//拷贝多个&lt;script&gt; //extend2实现的功能：extend(target,obj1,obj2,obj3) /*功能：将多个多个json拷贝给目标*/ /*原理：*/ /*首先找到target --arguments[0]*/ function extend () &#123; var key,i = 0,len = arguments.length,target = null,copy; if(len === 0)&#123; return; &#125;else if(len === 1)&#123; target = this; &#125;else&#123; i++; target = arguments[0]; &#125; for(; i &lt; len; i++)&#123; for(key in arguments[i])&#123; copy = arguments[i][key]; target[key] = copy; &#125; &#125; return target; &#125; /*hasOwnProperty*/ function extend2()&#123; for (var p in source) &#123; if (source.hasOwnProperty(p)) &#123; target[p] = source[p]; &#125; &#125; return target; &#125; //游戏随机生成名字 var boy = &#123; name:&apos;无忌&apos; ,image:&apos;男性头像&apos; ,age:20 ,sex:&apos;男&apos; &#125;; //技能名称，等级，伤害值，需要的魔法 var technology = &#123;tname:&apos;亡灵复活&apos;,tlevel:10,tstrength:3000,tmagic:30&#125;; var shenqi = &#123;sname:&apos;霜之哀伤&apos;,slevel:30,sstrength:3000&#125; //当这个人有了穿上盔甲，圣衣，六神合体，戴上魔法戒指之后，自动也拥有一个技能 //第一种用法 var zuixiake = extend(&#123;&#125;, technology,shenqi); zuixiake.name=&apos;醉侠客&apos;; alert(zuixiake.name); alert(zuixiake.tname); alert(zuixiake.sname); //第二种用法 extend(boy,technology,shenqi); alert(boy.name); alert(boy.tname); alert(boy.sname);&lt;/script&gt;//使用封装的框架//第一种用法 醉侠客加入丐帮之后学到的技能var zuixiake = $$.extendMany(&#123;&#125;, gaibang,shaolin);zuixiake.name=&apos;醉侠客&apos;;console.log(zuixiake.name);zuixiake.XL18.attack()zuixiake.DLJGS.attack()//第二种用法 无忌加入丐帮$$.extendMany(boy,gaibang,shaolin);console.log(boy.name);boy.XL18.attack()boy.DLJGS.attack() 用第三方框架 var Person = Class.extend(&#123; init: function(isDancing)&#123; this.dancing = isDancing; &#125;, dance: function()&#123; return this.dancing; &#125;&#125;);其他参考案例 继承Number.__proto__ === Function.prototype // trueBoolean.__proto__ === Function.prototype // trueString.__proto__ === Function.prototype // trueObject.__proto__ === Function.prototype // trueFunction.__proto__ === Function.prototype //true Array.__proto__ === Function.prototype // trueRegExp.__proto__ === Function.prototype // trueError.__proto__ === Function.prototype // trueDate.__proto__ === Function.prototype // true]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js常用代码块]]></title>
    <url>%2F2016%2F01%2F10%2Fjs%2F</url>
    <content type="text"><![CDATA[js常用代码块整理。 事件对象兼容写法document.onclick = function(event) &#123; // 文档中点击 var event = event || window.event; // 兼容性写法 console.log(event.clientY); console.log(event.pageY); console.log(event.screenY);&#125; 一个盒子内的坐标var div = document.getElementsByTagName("div")[0];div.onmousemove = function(event) &#123; var event = event || window.event; var x = event.clientX - this.offsetLeft; var y = event.clientY - this.offsetTop; this.innerHTML = x + "px" + y + "px";&#125; 封装scrollTop Left函数function $(id) &#123; return document.getElementById(id);&#125;function show(obj) &#123; obj.style.display = "block"; &#125;function hide(obj) &#123; obj.style.display = "none"; &#125;function scroll() &#123; if (window.pageYOffset != null) // ie9+ 和其他浏览器 &#123; return &#123; left: window.pageXOffset, top: window.pageYOffset &#125; &#125; else if (document.compatMode == "CSS1Compat") // 声明的了 DTD // 检测是不是怪异模式的浏览器 -- 就是没有 声明&lt;!DOCTYPE html&gt; &#123; return &#123; left: document.documentElement.scrollLeft, top: document.documentElement.scrollTop &#125; &#125; return &#123; // 剩下的肯定是怪异模式的 left: document.body.scrollLeft, top: document.body.scrollTop &#125;&#125;window.onscroll = function() &#123; console.log(scroll().top);&#125; 导航固定写法var nav = $("Q-nav");var navTop = nav.offsetTop; // 得到导航栏距离顶部的距离 168console.log(navTop);window.onscroll = function() &#123; // console.log(nav.offsetTop); if (scroll().top &gt;= navTop) &#123; //alert("到位置了"); nav.className = "nav fixed"; &#125; else &#123; nav.className = "nav"; &#125;&#125; 两边跟随的广告（广告图绝对定位）window.onload = function() &#123; var pic = $("pic"); var leader = 0; var target = 0; var timer = null; // 定时器 var top = pic.offsetTop; // 50 window.onscroll = function() &#123; clearInterval(timer); target = scroll().top + top; // 把最新的 scrolltop 给 target timer = setInterval(function() &#123; leader = leader + (target - leader) / 10; pic.style.top = leader + 'px'; &#125;, 30) &#125;&#125; 返回顶部的小火箭window.onload = function() &#123; var goTop = $(&quot;gotop&quot;); window.onscroll = function() &#123; scroll().top &gt; 0 ? show(goTop) : hide(goTop); // 如果大于0 就显示 否则隐藏 leader = scroll().top; // 把 卷去的头部 给 起始位置 console.log(scroll().top); &#125; var leader = 0, target = 0, timer = null; // leader 起始位置 target 目标位置 goTop.onclick = function() &#123; target = 0; // 点击完毕之后 奔向0 去的 不写也可以 timer = setInterval(function() &#123; leader = leader + (target - leader) / 10; window.scrollTo(0, leader); // 去往页面中的某个位置 if (leader == target) &#123; clearInterval(timer); &#125; &#125;, 20); &#125;&#125; 三个取整函数console.log(Math.ceil(1.01))console.log(Math.ceil(1.9))console.log(Math.ceil(-1.3)) //floor 地板 向下取整console.log(Math.floor(1.01))console.log(Math.floor(1.9))console.log(Math.floor(-1.3)) // 四舍五入console.log(Math.round(1.01))console.log(Math.round(1.5)) 封装可视区域大小函数（窗口宽度）function client() &#123; if (window.innerWidth != null) // ie9 + 最新浏览器 &#123; return &#123; width: window.innerWidth, height: window.innerHeight &#125; &#125; else if (document.compatMode === &quot;CSS1Compat&quot;) // 标准浏览器 &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125; return &#123; // 怪异浏览器 width: document.body.clientWidth, height: document.body.clientHeight &#125;&#125;// document.write(client().width);window.onresize = reSize;function reSize() &#123; var clientWidth = client().width; if (clientWidth &gt; 980) &#123; styleCss.href = &quot;&quot;; &#125; else if (clientWidth &gt; 640) &#123; styleCss.href = &quot;css/pad.css&quot;; &#125; else &#123; styleCss.href = &quot;css/mobile.css&quot;; &#125;&#125;//检测屏幕分辨率document.write(window.screen.width); 阻止冒泡方法var btn = document.getElementById(&quot;btn&quot;);document.onclick = function() &#123; alert(&quot;点击了空白处&quot;)&#125;btn.onclick = function(event) &#123; alert(&quot;点击了按钮&quot;) var event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); // w3c 标准 &#125; else &#123; event.cancelBubble = true; // ie 678 ie浏览器 &#125;&#125; 点击空白隐藏function $(id) &#123; return document.getElementById(id);&#125;var login = document.getElementById(&quot;login&quot;);login.onclick = function(event) &#123; $(&quot;mask&quot;).style.display = &quot;block&quot;; $(&quot;show&quot;).style.display = &quot;block&quot;; document.body.style.overflow = &quot;hidden&quot;; // 不显示滚动条 //取消冒泡 var event = event || window.event; if (event &amp;&amp; event.stopPropagation) &#123; event.stopPropagation(); &#125; else &#123; event.cancelBubble = true; &#125;&#125;document.onclick = function(event) &#123; var event = event || window.event; // alert(event.target.id); // 返回的是点击的某个对象的id 名字 // alert(event.srcElement.id); var targetId = event.target ? event.target.id : event.srcElement.id; // 看明白这个写法 if (targetId != &quot;show&quot;) // 不等于当前点点击的名字 &#123; $(&quot;mask&quot;).style.display = &quot;none&quot;; $(&quot;show&quot;).style.display = &quot;none&quot;; document.body.style.overflow = &quot;visible&quot;; // 显示滚动条 &#125;&#125; 返回元素当前样式var demo = document.getElementById(&quot;demo&quot;);function getStyle(obj, attr) &#123; // 谁的 那个属性 if (obj.currentStyle) // ie 等 &#123; return obj.currentStyle[attr]; // 返回传递过来的某个属性 &#125; else &#123; return window.getComputedStyle(obj, null)[attr]; // w3c 浏览器 &#125;&#125;console.log(getStyle(demo, &quot;width&quot;)); 闭包版tab栏 节流window.onload = function() &#123; //要想多个盒子不相互影响 ，我们可以通过id 给他们分开 //封装tab栏切换函数 function tab(obj) &#123; var target = document.getElementById(obj); var spans = target.getElementsByTagName(&quot;span&quot;); var lis = target.getElementsByTagName(&quot;li&quot;); for (var i = 0; i &lt; spans.length; i++) &#123; // spans[i].index = i; spans[i].onmouseover = function(num) &#123; return function() &#123; for (var j = 0; j &lt; spans.length; j++) &#123; spans[j].className = &quot;&quot;; lis[j].className = &quot;&quot;; &#125; spans[num].className = &quot;current&quot;; lis[num].className = &quot;show&quot;; &#125; &#125;(i); &#125; &#125; tab(&quot;one&quot;); tab(&quot;two&quot;); tab(&quot;three&quot;);&#125; 窗口尺寸改变，触发不那么灵敏 闭包版本var num = 0;var demo = document.getElementById(&quot;demo&quot;)window.onresize = throttle(function() &#123; demo.innerHTML = window.innerWidth || document.documentElement.clientWidth; num++; console.log(num);&#125;, 300);function throttle(fn, delay) &#123; // 闭包 节流 var timer = null; return function() &#123; clearTimeout(timer); timer = setTimeout(fn, delay); &#125;&#125; 运动函数var btn200 = document.getElementById(&quot;btn200&quot;);var btn400 = document.getElementById(&quot;btn400&quot;);var box = document.getElementById(&quot;box&quot;);btn200.onclick = function() &#123; animate(box, &#123; width: 200, top: 100, left: 200, opacity: 40, zIndex: 3 &#125;, function() &#123; alert(&quot;我来了&quot;) &#125;);&#125;btn400.onclick = function() &#123; animate(box, &#123; top: 500 &#125;); &#125; // 多个属性运动框架 添加回调函数function animate(obj, json, fn) &#123; // 给谁 json clearInterval(obj.timer); obj.timer = setInterval(function() &#123; var flag = true; // 用来判断是否停止定时器 一定写到遍历的外面 for (var attr in json) &#123; // attr 属性 json[attr] 值 //开始遍历 json // 计算步长 用 target 位置 减去当前的位置 除以 10 // console.log(attr); var current = 0; if (attr == &quot;opacity&quot;) &#123; current = Math.round(parseInt(getStyle(obj, attr) * 100)) || 0; console.log(current); &#125; else &#123; current = parseInt(getStyle(obj, attr)); // 数值 &#125; // console.log(current); // 目标位置就是 属性值 var step = (json[attr] - current) / 10; // 步长 用目标位置 - 现在的位置 / 10 step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //判断透明度 if (attr == &quot;opacity&quot;) // 判断用户有没有输入 opacity &#123; if (&quot;opacity&quot; in obj.style) // 判断 我们浏览器是否支持opacity &#123; // obj.style.opacity obj.style.opacity = (current + step) / 100; &#125; else &#123; // obj.style.filter = alpha(opacity = 30) obj.style.filter = &quot;alpha(opacity = &quot; + (current + step) * 10 + &quot;)&quot;; &#125; &#125; else if (attr == &quot;zIndex&quot;) &#123; obj.style.zIndex = json[attr]; &#125; else &#123; obj.style[attr] = current + step + &quot;px&quot;; &#125; if (current != json[attr]) // 只要其中一个不满足条件 就不应该停止定时器 这句一定遍历里面 &#123; flag = false; &#125; &#125; if (flag) // 用于判断定时器的条件 &#123; clearInterval(obj.timer); //alert(&quot;ok了&quot;); if (fn) // 很简单 当定时器停止了。 动画就结束了 如果有回调，就应该执行回调 &#123; fn(); // 函数名 + （） 调用函数 执行函数 暂且这样替代 &#125; &#125; &#125;, 30)&#125; 获取元素样式中的某个属性function getStyle(obj, attr) &#123; // 谁的 那个属性 if (obj.currentStyle) // ie 等 &#123; return obj.currentStyle[attr]; // 返回传递过来的某个属性 &#125; else &#123; return window.getComputedStyle(obj, null)[attr]; // w3c 浏览器 &#125;&#125; 全选和反选window.onload = function()&#123; var btns = document.getElementsByTagName(&quot;button&quot;); var inputs = document.getElementById(&quot;bottom&quot;).getElementsByTagName(&quot;input&quot;); /*全选和取消 函数*/ function all(flag)&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked = flag; &#125; &#125; btns[0].onclick = function()&#123; all(true); &#125;; btns[1].onclick = function()&#123; all(false); &#125;; btns[2].onclick = function()&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked == true ? inputs[i].checked = false : inputs[i].checked = true; &#125; &#125;&#125; tab1栏切换window.onload = function()&#123; function tab(obj) &#123; console.log(222); var obj = document.getElementById(obj); var btns = obj.getElementsByTagName(&apos;button&apos;); var lis= obj.getElementsByTagName(&apos;li&apos;); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].index = i; //难点 btns[i].onmouseover = function() &#123; for (var j = 0; j &lt; btns.length; j++) &#123; //让所有的 btn 类名清空 btns[j].className = &quot;&quot;; lis[j].className = &quot;&quot;; // 当前的那个按钮 的添加 类名 this.className = &quot;bg&quot; //先隐藏下面所有的 li盒子 //留下中意的那个 跟点击的序号有关系的 lis[this.index].className = &quot;show&quot;; &#125; &#125; &#125; &#125; tab(&quot;one&quot;); tab(&quot;two&quot;);&#125; 定时器应用function $(id) &#123; return document.getElementById(id);&#125; // id函数function hide(id) &#123; // 隐藏函数 $(id).style.display = &quot;none&quot;;&#125;function show(id) &#123; $(id).style.display = &quot;block&quot;;&#125;setTimeout(closeAd,5000);function closeAd() &#123; hide(&quot;left&quot;); hide(&quot;right&quot;);&#125; 定时器应用&lt;div class=&quot;xiaomi&quot;&gt; &lt;!-- 这里放一个超高的图片，需要进行绝对定位，超出的部分，让父亲隐藏掉。 --&gt; &lt;img src=&quot;mi.png&quot; alt=&quot;&quot; id=&quot;pic&quot;/&gt; &lt;!-- 上下部分触发事件的绝对定位块 --&gt; &lt;span class=&quot;up&quot; id=&quot;picUp&quot;&gt;&lt;/span&gt; &lt;span class=&quot;down&quot; id=&quot;picDown&quot;&gt;&lt;/span&gt;&lt;/div&gt;function $(id) &#123; return document.getElementById(id);&#125;var num = 0; // 控制图片的top值var timer = null; // 定时器名称$(&quot;picUp&quot;).onmouseover = function()&#123; clearInterval(timer); timer = setInterval(function()&#123; num -= 3; //这里的数值都是根据给定的图片高度算出的 num &gt;= -1070 ? $(&quot;pic&quot;).style.top = num + &quot;px&quot; : clearInterval(timer); &#125;,30);&#125;$(&quot;picDown&quot;).onmouseover = function()&#123; clearInterval(timer); timer = setInterval(function()&#123; num+=3; num &lt; 0 ? $(&quot;pic&quot;).style.top = num + &quot;px&quot; : clearInterval(timer); &#125;,30);&#125;$(&quot;picUp&quot;).parentNode.onmouseout = function() &#123; clearInterval(timer);&#125; 无缝滚动var scroll = document.getElementById(&quot;scroll&quot;);var ul = scroll.children[0];var num = 0; //控制左侧值 leftvar timer = null; // 定时器timer = setInterval(autoPlay,20);function autoPlay() &#123; num--; num&lt;=-1200 ? num = 0 : num; ul.style.left = num + &quot;px&quot;;&#125;scroll.onmouseover = function() &#123; // 鼠标经过大盒子 停止定时器 clearInterval(timer);&#125;scroll.onmouseout = function() &#123; timer = setInterval(autoPlay,20); // 开启定时器&#125; 检测字符串长度var txt = &quot;what are you 弄啥咧!好的&quot;; console.log(txt.length); function getStringLength(str) &#123; var len = 0; //存储总长度 var c = 0; // 存储每一个编码 for(var i=0;i&lt;str.length;i++) &#123; c = str.charCodeAt(i); if(c&gt;=0 &amp;&amp; c&lt;=127) &#123; len++; &#125; else &#123; len += 2; &#125; &#125; return len; &#125; console.log(getStringLength(txt)); 封装自己的$函数，快速获取页面元素 //function $(id) &#123;return document.getElementById(id)&#125; //id选择器 function getClass(classname) // 类的写法 &#123; //判断支持否 if(document.getElementsByClassName) &#123; return document.getElementsByClassName(classname); &#125; var arr = []; //用于返回 数组 var dom = document.getElementsByTagName(&quot;*&quot;); for(var i=0;i&lt;dom.length;i++) // 遍历所有的 盒子 &#123; var txtarr = dom[i].className.split(&quot; &quot;); // 分割类名 并且 转换为数组 // [&quot;demo&quot;,&quot;test&quot;]; for(var j=0;j&lt;txtarr.length;j++) // 遍历 通过类名分割的数组 &#123; if(txtarr[j] == classname) &#123; arr.push(dom[i]); // 我们要的是 div &#125; &#125; &#125; return arr; &#125; // $(&quot;#demo&quot;) $(&quot;.one&quot;) $(&quot;div&quot;) //封装自己的$ function $(str) &#123; var s = str.charAt(0); // 一个s 的变量 存放是 符号 # . var ss = str.substr(1); // demo switch(s) &#123; case &quot;#&quot;: return document.getElementById(ss); break; case &quot;.&quot;: return getClass(ss); break; default : return document.getElementsByTagName(str); &#125; &#125;$(&quot;#demo&quot;).style.backgroundColor = &quot;purple&quot;;$(&quot;#last&quot;).style.backgroundColor = &quot;purple&quot;; var test = $(&quot;.one&quot;); for(var i=0;i&lt;test.length;i++) &#123; test[i].style.backgroundColor = &quot;blue&quot;; &#125; 匀速运动与缓动动画//匀速运动var btn = document.getElementById(&quot;btn&quot;);var box = document.getElementById(&quot;bOX&quot;);var num = 0;var timer = null;btn.onclick = function() &#123; timer = setInterval(function()&#123; num++; if(num &gt;=500) &#123; clearInterval(timer); &#125; else &#123; box.style.left = num + &quot;px&quot;; &#125; &#125;,10)&#125;//缓动动画var btn = document.getElementById(&quot;btn&quot;);var box = document.getElementById(&quot;bOX&quot;);var timer = null;var leader = 0;var target = 500;btn.onclick = function() &#123; setInterval(function()&#123; leader = leader + (target - leader )/10; box.style.left = leader + &quot;px&quot;; &#125;,30)&#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据绑定的相关知识]]></title>
    <url>%2F2015%2F12%2F30%2FbindData%2F</url>
    <content type="text"><![CDATA[javascrpt中数据绑定相关内容 字符串相加方式获取到数据通过字符串相加，用element.innerhtml=str即可。 动态创建标签绑定根据不同的交互情况（比如登录状态）命名不同的函数，创建不同的标签，绑定不同的数据（也可用字符串相加模式省的创建标签），使用jQuery更好。 formateString已经封装到框架中，直接调用$$.formateString(str, data) 演示：var user=&#123;name:'马院长XXX',role:'钻石会员XXX'&#125;var span = document.getElementById("span");span.innerHTML = $$.formateString("欢迎#(name) #(role)来到百度世界",user) 模板技术基础用法：//HTML部分：&lt;h1&gt;最新上映电影：&lt;/h1&gt;&lt;div id='mydiv'&gt;&lt;/div&gt;//JS部分&lt;!--模板王者演示--&gt;&lt;script id="arttemplate" type="text/html"&gt; &lt;strong&gt;电影名称：&lt;/strong&gt;&#123;&#123;name&#125;&#125;&lt;br&gt; &lt;strong style='color:red'&gt;导演&lt;/strong&gt;&#123;&#123;lead&#125;&#125;&lt;br&gt; &lt;strong style='color:green'&gt;主演:&lt;/strong&gt;&#123;&#123;role&#125;&#125;&lt;/script&gt;//这是外部引入的js文件，用里面封装好的这两个方法：&lt;script src='js/itcast.js'&gt;&lt;/script&gt;bindTemplate:function (tempalteId,data)&#123;var html = template(tempalteId, data);return html;&#125;&lt;script&gt; //标准json定义-- 必须有标题，必须有双引号 var film = &#123; name: "美人鱼", lead: "周星驰", role: "邓超", &#125;; document.getElementById('mydiv').innerHTML = $$.bindTemplate('arttemplate',film);&lt;/script&gt;还有一种：artTemplate:function (str,data)&#123; var render = template.compile(str); return render(data)&#125;将模板与数据放到一个script内&lt;script&gt; var film= &#123;name:'美人鱼',lead:'周星驰',role:'邓超'&#125; var source = '&lt;strong&gt;&#123;&#123;name&#125;&#125;&lt;/strong&gt;' + '&lt;strong&gt;&#123;&#123;lead&#125;&#125;&lt;/strong&gt;' + '&lt;strong&gt;&#123;&#123;role&#125;&#125;&lt;/strong&gt;' document.getElementById('content').innerHTML = $$.artTemplate(source,film);&lt;/script&gt; replace的用法//将字母a替换成字母A 正确的写法 /g表示匹配所有myString = "javascript is a good script language";console.log('替换全部')console.log(myString.replace(/a/g,"A"));]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax笔记]]></title>
    <url>%2F2015%2F12%2F24%2Fajax%2F</url>
    <content type="text"><![CDATA[ajax使用总结。 ajax使用代码示例原生写法&lt;script&gt; //第一步：创建xhr对象 var xhr = null; if (window.XMLHttpRequest) &#123; //标准浏览器 xhr = new XMLHttpRequest(); &#125; else &#123; //早期的IE浏览器 xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; //第二步：准备发送请求-配置发送请求的一些行为 var url = '05open.php?username=' + encodeURIComponet(username) + '&amp;password=' + password; //var url = '05open.php'; xhr.open('get', url); //第三步：执行发送的动作 //var param = 'username=' + username + '&amp;password=' + password; xhr.send(null); //第四步：指定一些回调函数 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; var data = xhr.responseText; //json // var data = JSON.parse(this.responseText); console.log(data); // var data1 = xhr.responseXML; &#125; &#125;&lt;/script&gt; jQuery写法&lt;script&gt;$.ajax(&#123; type : "get", dataType:"text", data:&#123;cityName:'luoyang'&#125;, url : './05open.php?username=中国&amp;password=123', success : function(data)&#123; console.log(data); &#125;, error: function(e) &#123; console.log(e); &#125;&#125;);&lt;/script&gt; 封装的ajax方法&lt;script&gt; // ajax函数 function ajax(data)&#123; // data参数的配置 //data=&#123;data:"",dataType:"xml/json",type:"get/post"，url:"",asyn:"true/false",success:function()&#123;&#125;,failure:function()&#123;&#125;&#125; //data:&#123;username:123,password:456&#125; //data = 'username=123&amp;password=456'; //第一步：创建xhr对象 var xhr = null; if(window.XMLHttpRequest)&#123;//标准的浏览器 xhr = new XMLHttpRequest(); &#125;else&#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; //第二步：准备发送前的一些配置参数 var type = data.type == 'get'?'get':'post'; var url = ''; if(data.url)&#123; url = data.url; if(type == 'get')&#123; url += "?" + data.data + "&amp;_t="+Math.random(); &#125; &#125; var flag = data.asyn == 'true'?'true':'false'; xhr.open(type,url,flag); //第三步：执行发送的动作 if(type == 'get')&#123; xhr.send(null); &#125;else if(type == 'post')&#123; xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded"); xhr.send(data.data); &#125; //第四步：指定回调函数 xhr.onreadystatechange = function()&#123; if(this.readyState == 4)&#123; if(this.status == 200)&#123; if(typeof data.success == 'function')&#123; var d = data.dataType == 'xml'?xhr.responseXML:xhr.responseText; data.success(d); &#125; &#125;else&#123; if(typeof data.failure == 'function')&#123; data.failure(); &#125; &#125; &#125; &#125; &#125; // 调用方法 var param = &#123; url:'demo.php', type:'get', dataType:'json', success:function(data)&#123; alert(data); &#125; &#125;; ajax(param);&lt;/script&gt; 跨域问题在文档里加一个src标签，将需要的js文件引入就行，这其实和ajax没关系。 原理：在引入的js文件中调用了一个函数，并进行了传参，这个函数就是我们需要在文档里编写的（同名函数），并且接收参数 实例 &lt;script type="text/javascript"&gt; function cb(data)&#123; console.log(data); &#125; //引入后相当于这样：cb(["zhangsan","lisi","zhaoliu"]) &lt;/script&gt; &lt;script type="text/javascript" src="jsonp.php?_jsonp=cb"&gt;&lt;/script&gt; //jsonp.php文件内容 &lt;?php $callback = $_GET['_jsonp']; $arr = array("zhangsan","lisi","zhaoliu"); echo $callback."(".json_encode($arr).")"; ?&gt;**PHP jsonp**&lt;script&gt; $.getJSON("http://www.runoob.com/try/ajax/jsonp.php?jsoncallback=?", function(data) &#123; var html = '&lt;ul&gt;'; for(var i = 0; i &lt; data.length; i++) &#123; html += '&lt;li&gt;' + data[i] + '&lt;/li&gt;'; &#125; html += '&lt;/ul&gt;'; $('#divCustomers').html(html); &#125;);&lt;/script&gt; ajax获取xmlvar data = xhr.responseXML; //data为xml文档即xmlDocvar bs = data.getElementsByTagName('bookstore')[0];var books = bs.getElementsByTagName('book');]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript代码笔记03]]></title>
    <url>%2F2015%2F12%2F18%2Fjsnote03%2F</url>
    <content type="text"><![CDATA[整理的一些javascript代码段，使用原生的js编写 js数据类型转换constructor 属性返回所有 JavaScript 变量的构造函数。 "John".constructor // 返回函数 String() &#123; [native code] &#125;(3.14).constructor // 返回函数 Number() &#123; [native code] &#125;false.constructor // 返回函数 Boolean() &#123; [native code] &#125;[1,2,3,4].constructor // 返回函数 Array() &#123; [native code] &#125;&#123;name:'John', age:34&#125;.constructor // 返回函数 Object() &#123; [native code] &#125;new Date().constructor // 返回函数 Date() &#123; [native code] &#125;function () &#123;&#125;.constructor // 返回函数 Function()&#123; [native code] &#125; 你可以使用 constructor 属性来查看是对象是否为数组 (包含字符串 “Array”):function isArray(myArray) &#123; return myArray.constructor.toString().indexOf("Array") &gt; -1;&#125; 数字转换为字符串 toExponential() 把对象的值转换为指数计数法。 toFixed() 把数字转换为字符串，结果的小数点后有指定位数的数字。 toPrecision() 把数字格式化为指定的长度。 一元运算符 +Operator + 可用于将变量转换为数字：var y = "5"; // y 是一个字符串var x = + y; // x 是一个数字 如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):实例var y = "John"; // y 是一个字符串var x = + y; // x 是一个数字 (NaN) 正则表达式 正则表达式是由一个字符序列形成的搜索模式。 当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。 正则表达式可以是一个简单的字符，或一个更复杂的模式。 正则表达式可用于所有文本搜索和文本替换的操作。 语法格式：var patt = /w3cschool/i 使用字符串方法在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。 search() 方法 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回字符串的起始位置。 replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的字符串。 search() 方法使用正则表达式使用正则表达式搜索 "w3cschool" 字符串，且不区分大小写：var str = "Visit w3cschool";var n = str.search(/w3cschool/i); replace() 方法使用正则表达式使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 w3cschool :var str = "Visit Microsoft!";var res = str.replace(/microsoft/i, "w3cschool"); 使用 RegExp 对象在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。 js错误在下面的例子中，我们故意在 try 块的代码中写了一个错字。catch 块会捕捉到 try 块中的错误，并执行代码来处理它。var txt="";function message()&#123; try &#123; adddlert("Welcome guest!"); &#125; catch(err) &#123; txt="本页有一个错误。\n\n"; txt+="错误描述：" + err.message + "\n\n"; txt+="点击确定继续。\n\n"; alert(txt); &#125;&#125; 本例检测输入变量的值。如果值是错误的，会抛出一个异常（错误）。catch 会捕捉到这个错误，并显示一段自定义的错误消息：function myFunction()&#123; try &#123; var x=document.getElementById("demo").value; if(x=="") throw "值为空"; if(isNaN(x)) throw "不是数字"; if(x &gt; 10) throw "太大"; if(x &lt; 5) throw "太小"; &#125; catch(err) &#123; var y=document.getElementById("mess"); y.innerHTML="错误：" + err + "。"; &#125;&#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript代码笔记02]]></title>
    <url>%2F2015%2F12%2F06%2Fjsnote02%2F</url>
    <content type="text"><![CDATA[整理的一些javascript代码段，使用原生的js编写 仿微博内容发布使用了一些DOM节点的操作以及节点之间的关系。难点：每次发布的内容要位于第一条。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; ul&#123; list-style-type: none;&#125; *&#123;margin:0;padding: 0;&#125; .box &#123; margin: 100px auto; width: 600px; height: auto; border:1px solid #333; padding: 30px 0; &#125; textarea:focus,button:focus &#123; outline: none; &#125; textarea &#123; width: 450px; resize: none; /*防止用户拖动 右下角*/ display: block; margin: 20px auto; &#125; .box li &#123; width: 450px; line-height: 30px; border-bottom:1px dashed #ccc; margin-left: 80px; &#125; .box li a &#123; float: right; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; //获取对象 再次操作对象 var btn = document.getElementsByTagName("button")[0]; var txt = document.getElementsByTagName("textarea")[0]; var ul = document.createElement("ul"); btn.parentNode.appendChild(ul); btn.onclick = function()&#123; if(txt.value == "") &#123; alert("输入不能为空"); return false; &#125; var newli = document.createElement("li"); newli.innerHTML = txt.value + "&lt;a href ='javascript:;'&gt;删除&lt;/a&gt;"; txt.value = ""; var lis = ul.children; if(lis.length == 0) &#123; ul.appendChild(newli); &#125; else &#123; ul.insertBefore(newli,lis[0]); &#125; var as = document.getElementsByTagName("a"); for(var i=0; i&lt;as.length;i++) &#123; as[i].onclick = function()&#123; ul.removeChild(this.parentNode); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt; 微博发布: &lt;br&gt; &lt;textarea name="" id="" cols="30" rows="10"&gt;&lt;/textarea&gt; &lt;button&gt;发布&lt;/button&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定时器应用 简单的定时器进行页面元素的显示隐藏，给页面元素加相应id即可生效 function $(id) &#123; return document.getElementById(id);&#125; // id函数function hide(id) &#123; // 隐藏函数 $(id).style.display = "none";&#125;function show(id) &#123; $(id).style.display = "block";&#125;setTimeout(closeAd,5000);function closeAd() &#123; hide("left"); hide("right");&#125; 鼠标移动到图片上部图片向上滑动，鼠标移动到图片下部图片向下滑动 &lt;div class="xiaomi"&gt; &lt;!-- 这里放一个超高的图片，需要进行绝对定位，超出的部分，让父亲隐藏掉。 --&gt; &lt;img src="mi.png" alt="" id="pic"/&gt; &lt;!-- 上下部分触发事件的绝对定位块 --&gt; &lt;span class="up" id="picUp"&gt;&lt;/span&gt; &lt;span class="down" id="picDown"&gt;&lt;/span&gt;&lt;/div&gt;function $(id) &#123; return document.getElementById(id);&#125;var num = 0; // 控制图片的top值var timer = null; // 定时器名称$("picUp").onmouseover = function()&#123; clearInterval(timer); timer = setInterval(function()&#123; num -= 3; //这里的数值都是根据给定的图片高度算出的 num &gt;= -1070 ? $("pic").style.top = num + "px" : clearInterval(timer); &#125;,30);&#125;$("picDown").onmouseover = function()&#123; clearInterval(timer); timer = setInterval(function()&#123; num+=3; num &lt; 0 ? $("pic").style.top = num + "px" : clearInterval(timer); &#125;,30);&#125;$("picUp").parentNode.onmouseout = function() &#123; clearInterval(timer);&#125; 无缝滚动 var scroll = document.getElementById("scroll"); var ul = scroll.children[0]; var num = 0; //控制左侧值 left var timer = null; // 定时器 timer = setInterval(autoPlay,20); function autoPlay() &#123; num--; num&lt;=-1200 ? num = 0 : num; ul.style.left = num + "px"; &#125; scroll.onmouseover = function() &#123; // 鼠标经过大盒子 停止定时器 clearInterval(timer); &#125; scroll.onmouseout = function() &#123; timer = setInterval(autoPlay,20); // 开启定时器 &#125; 检测字符串长度var txt = "what are you 弄啥咧!好的"; console.log(txt.length); function getStringLength(str) &#123; var len = 0; //存储总长度 var c = 0; // 存储每一个编码 for(var i=0;i&lt;str.length;i++) &#123; c = str.charCodeAt(i); if(c&gt;=0 &amp;&amp; c&lt;=127) &#123; len++; &#125; else &#123; len += 2; &#125; &#125; return len; &#125; console.log(getStringLength(txt)); 封装自己的$函数，快速获取页面元素 //function $(id) &#123;return document.getElementById(id)&#125; //id选择器 function getClass(classname) // 类的写法 &#123; //判断支持否 if(document.getElementsByClassName) &#123; return document.getElementsByClassName(classname); &#125; var arr = []; //用于返回 数组 var dom = document.getElementsByTagName("*"); for(var i=0;i&lt;dom.length;i++) // 遍历所有的 盒子 &#123; var txtarr = dom[i].className.split(" "); // 分割类名 并且 转换为数组 // ["demo","test"]; for(var j=0;j&lt;txtarr.length;j++) // 遍历 通过类名分割的数组 &#123; if(txtarr[j] == classname) &#123; arr.push(dom[i]); // 我们要的是 div &#125; &#125; &#125; return arr; &#125; // $("#demo") $(".one") $("div") //封装自己的$ function $(str) &#123; var s = str.charAt(0); // 一个s 的变量 存放是 符号 # . var ss = str.substr(1); // demo switch(s) &#123; case "#": return document.getElementById(ss); break; case ".": return getClass(ss); break; default : return document.getElementsByTagName(str); &#125; &#125;$("#demo").style.backgroundColor = "purple";$("#last").style.backgroundColor = "purple"; var test = $(".one"); for(var i=0;i&lt;test.length;i++) &#123; test[i].style.backgroundColor = "blue"; &#125; 匀速运动与缓动动画//匀速运动var btn = document.getElementById("btn"); var box = document.getElementById("bOX"); var num = 0; var timer = null; btn.onclick = function() &#123; timer = setInterval(function()&#123; num++; if(num &gt;=500) &#123; clearInterval(timer); &#125; else &#123; box.style.left = num + "px"; &#125; &#125;,10) &#125; //缓动动画 var btn = document.getElementById("btn"); var box = document.getElementById("bOX"); var timer = null; var leader = 0; var target = 500; btn.onclick = function() &#123; setInterval(function()&#123; leader = leader + (target - leader )/10; box.style.left = leader + "px"; &#125;,30) &#125;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript代码笔记01]]></title>
    <url>%2F2015%2F11%2F30%2Fjsnote01%2F</url>
    <content type="text"><![CDATA[整理的一些javascript代码段，使用原生的js编写 全选和反选使用到js入口函数、函数的封装、js事件的用法、for循环遍历数组。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="zh-CN"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;全选和反选&lt;/title&gt; &lt;script&gt; window.onload = function()&#123; var btns = document.getElementsByTagName("button"); var inputs = document.getElementById("bottom").getElementsByTagName("input"); /*全选和取消 函数*/ function all(flag)&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked = flag; &#125; &#125; btns[0].onclick = function()&#123; all(true); &#125;; btns[1].onclick = function()&#123; all(false); &#125;; btns[2].onclick = function()&#123; for(var i=0;i&lt;inputs.length;i++) &#123; inputs[i].checked == true ? inputs[i].checked = false : inputs[i].checked = true; &#125; &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="top"&gt; &lt;button&gt;全选&lt;/button&gt; &lt;button&gt;取消&lt;/button&gt; &lt;button&gt;反选&lt;/button&gt;&lt;/div&gt;&lt;div id="bottom"&gt; &lt;ul&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;li&gt;选项: &lt;input type="checkbox"/&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; tab栏切换编写难点在于排他思想的使用以及给元素添加属性，如果在页面中需要用到多个tab栏，我们就要对每个tab栏外面定义一个id盒子，这些在源码中都注释的有。 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="zh-CN"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;tab栏切换&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; button:focus &#123; outline: none; &#125; button &#123; cursor: pointer; &#125; ul &#123; list-style: none; &#125; .box &#123; width: 400px; margin:100px auto; border:1px solid #ccc; &#125; .bottom li&#123; width:100%; height: 300px; background-color: #f5f5f5; display: none; &#125; .bg&#123; background-color: #333; color: #fff; &#125; .bottom .show &#123; display: block; &#125; &lt;/style&gt; &lt;script&gt; window.onload = function()&#123; function tab(obj) &#123; console.log(222); var obj = document.getElementById(obj); var btns = obj.getElementsByTagName('button'); var lis= obj.getElementsByTagName('li'); for (var i = 0; i &lt; btns.length; i++) &#123; btns[i].index = i; //难点 btns[i].onmouseover = function() &#123; for (var j = 0; j &lt; btns.length; j++) &#123; //让所有的 btn 类名清空 btns[j].className = ""; lis[j].className = ""; // 当前的那个按钮 的添加 类名 this.className = "bg" //先隐藏下面所有的 li盒子 //留下中意的那个 跟点击的序号有关系的 lis[this.index].className = "show"; &#125; &#125; &#125; &#125; tab("one"); tab("two"); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box" id="one"&gt; &lt;div&gt; &lt;button class="bg"&gt;第一个&lt;/button&gt; &lt;button&gt;第二个&lt;/button&gt; &lt;button&gt;第三个&lt;/button&gt; &lt;button&gt;第四个&lt;/button&gt; &lt;button&gt;第五个&lt;/button&gt; &lt;/div&gt; &lt;ul class="bottom"&gt; &lt;li class="show"&gt;1好盒子&lt;/li&gt; &lt;li&gt;2好盒子&lt;/li&gt; &lt;li&gt;3好盒子&lt;/li&gt; &lt;li&gt;4好盒子&lt;/li&gt; &lt;li&gt;5好盒子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="box" id="two"&gt; &lt;div class="top"&gt; &lt;button class="bg"&gt;第一个&lt;/button&gt; &lt;button&gt;第二个&lt;/button&gt; &lt;button&gt;第三个&lt;/button&gt; &lt;button&gt;第四个&lt;/button&gt; &lt;button&gt;第五个&lt;/button&gt; &lt;/div&gt; &lt;ul class="bottom"&gt; &lt;li class="show"&gt;1好盒子&lt;/li&gt; &lt;li&gt;2好盒子&lt;/li&gt; &lt;li&gt;3好盒子&lt;/li&gt; &lt;li&gt;4好盒子&lt;/li&gt; &lt;li&gt;5好盒子&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>js代码段</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何做到jQuery-free？]]></title>
    <url>%2F2015%2F08%2F30%2Fjquery-free%2F</url>
    <content type="text"><![CDATA[概述jQuery是最流行的JavaScript工具库。据统计，目前全世界57.3%的网站使用它。也就是说，10个网站里面，有6个使用jQuery。如果只考察使用工具库的网站，这个比例就会上升到惊人的91.7%。 jQuery如此受欢迎，以至于有被滥用的趋势。许多开发者不管什么样的项目，都一股脑使用jQuery。但是，jQuery本质只是一个中间层，提供一套统一易用的DOM操作接口，消除浏览器之间的差异。多了这一层中间层，操作的性能和效率多多少少会打一些折扣。 2006年，jQuery诞生的时候，主要是为了解决IE6与标准的不兼容问题。如今的情况已经发生了很大的变化。IE的市场份额不断下降，以ECMAScript为基础的JavaScript标准语法，正得到越来越广泛的支持，不同浏览器对标准的支持越来越好、越来越趋同。开发者直接使用JavaScript标准语法，就能同时在各大浏览器运行，不再需要通过jQuery获取兼容性。 另一方面，jQuery臃肿的体积也让人头痛不已。jQuery 2.0的原始大小为235KB，优化后为81KB；如果是支持IE6、7、8的jQuery 1.8.3，原始大小为261KB，优化后为91KB。即使有CDN，浏览器加载这样大小的脚本，也会产生不小的开销。 所以，对于一些不需要支持老式浏览器的小型项目来说，不使用jQuery，直接使用DOM原生接口，可能是更好的选择。开发者有必要了解，jQuery的一些常用操作所对应的DOM写法。而且，理解jQuery背后的原理，会帮助你更好地使用jQuery。要知道有一种极端的说法是，如果你不理解一样东西，就不要使用它。 下面就探讨如何用JavaScript标准语法，取代jQuery的一些主要功能，做到jQuery-free。 选取DOM元素jQuery的核心是通过各种选择器，选中DOM元素，可以用querySelectorAll方法模拟这个功能。 var $ = document.querySelectorAll.bind(document); 这里需要注意的是，querySelectorAll方法返回的是NodeList对象，它很像数组（有数字索引和length属性），但不是数组，不能使用pop、push等数组特有方法。如果有需要，可以考虑将Nodelist对象转为数组。 myList = Array.prototype.slice.call(myNodeList); DOM操作DOM本身就具有很丰富的操作方法，可以取代jQuery提供的操作方法。 获取父元素。 // jQuery写法$("#elementID").parent()// DOM写法document.getElementById("elementID").parentNode 获取下一个同级元素。 // jQuery写法$("#elementID").next()// DOM写法document.getElementById("elementID").nextSibling 尾部追加DOM元素。 // jQuery写法$(parent).append($(child));// DOM写法parent.appendChild(child) 头部插入DOM元素。 // jQuery写法$(parent).prepend($(child));// DOM写法parent.insertBefore(child, parent.childNodes[0]) 生成DOM元素。 // jQuery写法$("&lt;p&gt;")// DOM写法document.createElement("p") 删除DOM元素。 // jQuery写法$(child).remove()// DOM写法child.parentNode.removeChild(child) 清空子元素。 // jQuery写法$("#elementID").empty()// DOM写法var element = document.getElementById("elementID");while(element.firstChild) element.removeChild(element.firstChild); 检查是否有子元素。 // jQuery写法if (!$("#elementID").is(":empty"))&#123;&#125;// DOM写法if (document.getElementById("elementID").hasChildNodes())&#123;&#125; 克隆元素。 // jQuery写法$("#elementID").clone()// DOM写法document.getElementById("elementID").cloned(true) 事件的监听jQuery使用on方法，监听事件和绑定回调函数。 $('button').on('click', function()&#123; ajax( ... );&#125;); 完全可以自己定义on方法，将它指向addEventListener方法。 Element.prototype.on = Element.prototype.addEventListener; 为了使用方便，可以在NodeList对象上也部署这个方法。 NodeList.prototype.on = function (event, fn) &#123; []['forEach'].call(this, function (el) &#123; el.on(event, fn); &#125;); return this;&#125;; 取消事件绑定的off方法，也可以自己定义。 Element.prototype.off = Element.prototype.removeEventListener; 事件的触发jQuery的trigger方法则需要单独部署，相对复杂一些。 Element.prototype.trigger = function (type, data) &#123; var event = document.createEvent('HTMLEvents'); event.initEvent(type, true, true); event.data = data || &#123;&#125;; event.eventName = type; event.target = this; this.dispatchEvent(event); return this;&#125;; 在NodeList对象上也部署这个方法。 NodeList.prototype.trigger = function (event) &#123; []['forEach'].call(this, function (el) &#123; el['trigger'](event); &#125;); return this;&#125;; $(document).readyDOM加载完成，会触发DOMContentLoaded事件，等同于jQuery的$(document).ready方法。 document.addEventListener("DOMContentLoaded", function() &#123; // ...&#125;); 不过，目前的最佳实践，是将JavaScript脚本文件都放在页面底部加载。这样的话，其实$(document).ready方法（可以简写为$(function)）已经不必要了，因为等到运行的时候，DOM对象已经生成了。 attr方法jQuery使用attr方法，读写网页元素的属性。 $("#picture").attr("src", "http://url/to/image") DOM提供getAttribute和setAttribute方法读写元素属性。 imgElement.setAttribute("src", "http://url/to/image") DOM还允许直接读取属性值，写法要简洁许多。 imgElement.src = "http://url/to/image"; 需要注意的是，文本框元素（input）的this.value返回的是输入框中的值，链接元素（a标签）的this.href返回的是绝对URL。如果需要用到这两个网页元素的属性准确值，可以用this.getAttribute(‘value’)和this.getAttibute(‘href’)。 addClass方法jQuery的addClass方法，用于为DOM元素添加一个class。 $('body').addClass('hasJS'); DOM元素本身有一个可读写的className属性，可以用来操作class。 document.body.className = 'hasJS';// ordocument.body.className += ' hasJS'; HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。 document.body.classList.add('hasJS');document.body.classList.remove('hasJS');document.body.classList.toggle('hasJS');document.body.classList.contains('hasJS'); CSSjQuery的css方法，用来设置网页元素的样式。 $(node).css( "color", "red" ); DOM元素有一个style属性，可以直接操作。 element.style.color = "red";// orelement.style.cssText += 'color:red'; 数据储存jQuery对象可以储存数据。 $("body").data("foo", 52); HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。 element.dataset.user = JSON.stringify(user);element.dataset.score = score; AjaxjQuery的ajax方法，用于异步操作。 $.ajax(&#123; type: "POST", url: "some.php", data: &#123; name: "John", location: "Boston" &#125;&#125;).done(function( msg ) &#123; alert( "Data Saved: " + msg );&#125;); 我们自定义一个ajax函数，简单模拟jQuery的ajax方法。 function ajax(url, opts)&#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function()&#123; var completed = 4; if(xhr.readyState === completed)&#123; if(xhr.status === 200)&#123; opts.success(xhr.responseText, xhr); &#125;else&#123; opts.error(xhr.responseText, xhr); &#125; &#125; &#125;; xhr.open(opts.method, url, true); xhr.send(opts.data);&#125; 使用的时候，除了网址，还需要传入一个自己构造的option对象。 ajax('/foo', &#123; method: 'GET', success: function(response)&#123; console.log(response); &#125;, error: function(response)&#123; console.log(response); &#125;&#125;); 动画jQuery的animate方法，用于生成动画效果。 $foo.animate('slow', &#123; x: '+=10px' &#125;) jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。 foo.classList.add('animate') 如果需要对动画使用回调函数，CSS 3也定义了相应的事件。 el.addEventListener("webkitTransitionEnd", transitionEnded);el.addEventListener("transitionend", transitionEnded); 替代方案由于jQuery体积过大，替代方案层出不穷。 其中，最有名的是zepto.js。它的设计目标是以最小的体积，做到最大兼容jQuery的API。它的1.0版的原始大小是55KB，优化后是29KB，gzip压缩后为10KB。 如果不求最大兼容，只希望模拟jQuery的基本功能。那么，min.js优化后只有200字节，而dolla优化后是1.7KB。 此外，jQuery本身也采用模块设计，可以只选择使用自己需要的模块。具体做法参见jQuery的github网站，或者使用专用的Web界面。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery插件开发]]></title>
    <url>%2F2015%2F08%2F20%2Fjquery-plugin%2F</url>
    <content type="text"><![CDATA[所谓“插件”，就是用户自己新增的jQuery实例对象的方法。由于该方法要被所有实例共享，所以只能定义在jQuery构造函数的原型对象（prototype）之上。对于用户来说，把一些常用的操作封装成插件（plugin），使用起来会非常方便。 插件的编写原理本质上，jQuery插件是定义在jQuery构造函数的prototype对象上面的一个方法，这样做就能使得所有jQuery对象的实例都能共享这个方法。因为jQuery构造函数的prototype对象被简写成jQuery.fn对象，所以插件采用下面的方法定义。 jQuery.fn.myPlugin = function() &#123; // Do your awesome plugin stuff here&#125;; 更好的做法是采用下面的写法，这样就能在函数体内自由使用美元符号（$）。 ;(function ($)&#123; $.fn.myPlugin = function ()&#123; // Do your awesome plugin stuff here &#125;;&#125;)(jQuery); 上面代码的最前面有一个分号，这是为了防止多个脚本文件合并时，其他脚本的结尾语句没有添加分号，造成运行时错误。 有时，还可以把顶层对象（window）作为参数输入，这样可以加快代码的执行速度和执行更有效的最小化操作。 ;(function ($, window) &#123; $.fn.myPlugin = function() &#123; // Do your awesome plugin stuff here &#125;;&#125;(jQuery, window)); 需要注意的是，在插件内部，this关键字指的是jQuery对象的实例。而在一般的jQuery回调函数之中，this关键字指的是DOM对象。 (function ($)&#123; $.fn.maxHeight = function ()&#123; var max = 0; // 下面这个this，指的是jQuery对象实例 this.each(function() &#123; // 回调函数内部，this指的是DOM对象 max = Math.max(max, $(this).height()); &#125;); return max; &#125;;&#125;)(jQuery); 上面这个maxHeight插件的作用是，返回一系列DOM对象中高度最高的那个对象的高度。 大多数情况下，插件应该返回jQuery对象，这样可以保持链式操作。 (function ($)&#123; $.fn.greenify = function ()&#123; this.css("color", "green"); return this; &#125;;&#125;)(jQuery);$("a").greenify().addClass("greenified"); 上面代码返回this对象，即jQuery对象实例，所以接下来可以采用链式操作。 对于包含多个jQuery对象的结果集，可以采用each方法，进行处理。 $.fn.myNewPlugin = function() &#123; return this.each(function() &#123; // 处理每个对象 &#125;);&#125;; 插件可以接受一个属性对象参数。 (function ($)&#123; $.fn.tooltip = function (options)&#123; var settings = $.extend( &#123; 'location' : 'top', 'background-color' : 'blue' &#125;, options); return this.each(function ()&#123; // 填入插件代码 &#125;); &#125;;&#125;)(jQuery); 上面代码使用extend方法，为参数对象设置属性的默认值。 侦测环境jQuery逐渐从浏览器环境，变为也可以用于服务器环境。所以，定义插件的时候，最好首先侦测一下运行环境。 if (typeof module === "object" &amp;&amp; typeof module.exports === "object") &#123; // CommonJS版本&#125; else &#123; // 浏览器版本&#125; 实例下面是一个将a元素的href属性添加到网页的插件。 (function($)&#123; $.fn.showLinkLocation = function() &#123; return this.filter('a').append(function()&#123; return ' (' + this.href + ')'; &#125;); &#125;;&#125;(jQuery));// 用法$('a').showLinkLocation(); 从上面的代码可以看到，插件的开发和使用都非常简单。 插件的发布编写插件以后，可以将它发布到jQuery官方网站上。 首先，编写一个插件的信息文件yourPluginName.jquery.json。文件名中的yourPluginName表示你的插件名。 &#123; "name": "plugin_name", "title": "plugin_long_title", "description": "...", "keywords": ["jquery", "plugins"], "version": "0.0.1", "author": &#123; "name": "...", "url": "..." &#125;, "maintainers": [ &#123; "name": "...", "url": "..." &#125; ], "licenses": [ &#123; "type": "MIT", "url": "http://www.opensource.org/licenses/mit-license.php" &#125; ], "bugs": "...", // bugs url "homepage": "...", // homepage url "docs": "...", // docs url "download": "...", // download url "dependencies": &#123; "jquery": "&gt;=1.4" &#125;&#125; 上面是一个插件信息文件的实例。 然后，将代码文件发布到Github，在设置页面点击“Service Hooks/WebHook URLs”选项，填入网址http://plugins.jquery.com/postreceive-hook，再点击“Update Settings”进行保存。 最后，为代码加上版本，push到github，你的插件就会加入jQuery官方插件库。 git tag 0.1.0git push origin --tags 以后，你要发布新版本，就做一个新的tag。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery工具方法]]></title>
    <url>%2F2015%2F08%2F15%2Fjquery-utility%2F</url>
    <content type="text"><![CDATA[jQuery函数库提供了一个jQuery对象（简写为$），这个对象本身是一个构造函数，可以用来生成jQuery对象的实例。有了实例以后，就可以调用许多针对实例的方法，它们定义jQuery.prototype对象上面（简写为$.fn）。 除了实例对象的方法以外，jQuery对象本身还提供一些方法（即直接定义jQuery对象上面），不需要生成实例就能使用。由于这些方法类似“通用工具”的性质，所以我们把它们称为“工具方法”（utilities）。 常用工具方法$.trim$.trim方法用于移除字符串头部和尾部多余的空格。 $.trim(' Hello ') // Hello $.contains$.contains方法返回一个布尔值，表示某个DOM元素（第二个参数）是否为另一个DOM元素（第一个参数）的下级元素。 $.contains(document.documentElement, document.body); // true$.contains(document.body, document.documentElement); // false $.each，$.map$.each方法用于遍历数组和对象，然后返回原始对象。它接受两个参数，分别是数据集合和回调函数。 $.each([ 52, 97 ], function( index, value ) &#123; console.log( index + ": " + value );&#125;);// 0: 52 // 1: 97 var obj = &#123; p1: "hello", p2: "world"&#125;;$.each( obj, function( key, value ) &#123; console.log( key + ": " + value );&#125;);// p1: hello// p2: world 需要注意的，jQuery对象实例也有一个each方法（$.fn.each），两者的作用差不多。 $.map方法也是用来遍历数组和对象，但是会返回一个新对象。 var a = ["a", "b", "c", "d", "e"];a = $.map(a, function (n, i)&#123; return (n.toUpperCase() + i);&#125;);// ["A0", "B1", "C2", "D3", "E4"] $.inArray$.inArray方法返回一个值在数组中的位置（从0开始）。如果该值不在数组中，则返回-1。 var a = [1,2,3,4];$.inArray(4,a) // 3 $.extend$.extend方法用于将多个对象合并进第一个对象。 var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;$.extend(o1,o2);o1.p1 // "c" $.extend的另一种用法是生成一个新对象，用来继承原有对象。这时，它的第一个参数应该是一个空对象。 var o1 = &#123;p1:'a',p2:'b'&#125;;var o2 = &#123;p1:'c'&#125;;var o = $.extend(&#123;&#125;,o1,o2);o// Object &#123;p1: "c", p2: "b"&#125; 默认情况下，extend方法生成的对象是“浅拷贝”，也就是说，如果某个属性是对象或数组，那么只会生成指向这个对象或数组的指针，而不会复制值。如果想要“深拷贝”，可以在extend方法的第一个参数传入布尔值true。 var o1 = &#123;p1:['a','b']&#125;;var o2 = $.extend(&#123;&#125;,o1);var o3 = $.extend(true,&#123;&#125;,o1);o1.p1[0]='c';o2.p1 // ["c", "b"]o3.p1 // ["a", "b"] 上面代码中，o2是浅拷贝，o3是深拷贝。结果，改变原始数组的属性，o2会跟着一起变，而o3不会。 （6）$.proxy $.proxy方法类似于ECMAScript 5的bind方法，可以绑定函数的上下文（也就是this对象）和参数，返回一个新函数。 jQuery.proxy()的主要用处是为回调函数绑定上下文对象。 var o = &#123; type: "object", test: function(event) &#123; console.log(this.type); &#125;&#125;;$("#button") .on("click", o.test) // 无输出 .on("click", $.proxy(o.test, o)) // object 上面的代码中，第一个回调函数没有绑定上下文，所以结果为空，没有任何输出；第二个回调函数将上下文绑定为对象o，结果就为object。 这个例子的另一种等价的写法是： $("#button").on( "click", $.proxy(o, test)) 上面代码的$.proxy(o, test)的意思是，将o的方法test与o绑定。 这个例子表明，proxy方法的写法主要有两种。 jQuery.proxy(function, context)// orjQuery.proxy(context, name) 第一种写法是为函数（function）指定上下文对象（context），第二种写法是指定上下文对象（context）和它的某个方法名（name）。 再看一个例子。正常情况下，下面代码中的this对象指向发生click事件的DOM对象。 $('#myElement').click(function() &#123; $(this).addClass('aNewClass');&#125;); 如果我们想让回调函数延迟运行，使用setTimeout方法，代码就会出错，因为setTimeout使得回调函数在全局环境运行，this将指向全局对象。 $('#myElement').click(function() &#123; setTimeout(function() &#123; $(this).addClass('aNewClass'); &#125;, 1000);&#125;); 上面代码中的this，将指向全局对象window，导致出错。 这时，就可以用proxy方法，将this对象绑定到myElement对象。 $('#myElement').click(function() &#123; setTimeout($.proxy(function() &#123; $(this).addClass('aNewClass'); &#125;, this), 1000);&#125;); $.data，$.removeData$.data方法可以用来在DOM节点上储存数据。 // 存入数据$.data(document.body, "foo", 52 );// 读取数据$.data(document.body, "foo");// 读取所有数据$.data(document.body); 上面代码在网页元素body上储存了一个键值对，键名为“foo”，键值为52。 $.removeData方法用于移除$.data方法所储存的数据。 $.data(div, "test1", "VALUE-1");$.removeData(div, "test1"); $.parseHTML，$.parseJSON，$.parseXML$.parseHTML方法用于将字符串解析为DOM对象。 $.parseJSON方法用于将JSON字符串解析为JavaScript对象，作用与原生的JSON.parse()类似。但是，jQuery没有提供类似JSON.stringify()的方法，即不提供将JavaScript对象转为JSON对象的方法。 $.parseXML方法用于将字符串解析为XML对象。 var html = $.parseHTML("hello, &lt;b&gt;my name is&lt;/b&gt; jQuery.");var obj = $.parseJSON('&#123;"name": "John"&#125;');var xml = "&lt;rss version='2.0'&gt;&lt;channel&gt;&lt;title&gt;RSS Title&lt;/title&gt;&lt;/channel&gt;&lt;/rss&gt;";var xmlDoc = $.parseXML(xml); $.makeArray$.makeArray方法将一个类似数组的对象，转化为真正的数组。 var a = $.makeArray(document.getElementsByTagName("div")); $.merge$.merge方法用于将一个数组（第二个参数）合并到另一个数组（第一个参数）之中。 var a1 = [0,1,2];var a2 = [2,3,4];$.merge(a1, a2);a1// [0, 1, 2, 2, 3, 4] $.now$.now方法返回当前时间距离1970年1月1日00:00:00 UTC对应的毫秒数，等同于(new Date).getTime()。 $.now()// 1388212221489 判断数据类型的方法jQuery提供一系列工具方法，用来判断数据类型，以弥补JavaScript原生的typeof运算符的不足。以下方法对参数进行判断，返回一个布尔值。 jQuery.isArray()：是否为数组。 jQuery.isEmptyObject()：是否为空对象（不含可枚举的属性）。 jQuery.isFunction()：是否为函数。 jQuery.isNumeric()：是否为数值（整数或浮点数）。 jQuery.isPlainObject()：是否为使用“{}”或“new Object”生成的对象，而不是浏览器原生提供的对象。 jQuery.isWindow()：是否为window对象。 jQuery.isXMLDoc()：判断一个DOM节点是否处于XML文档之中。 下面是一些例子。 $.isEmptyObject(&#123;&#125;) // true$.isPlainObject(document.location) // false$.isWindow(window) // true$.isXMLDoc(document.body) // false 除了上面这些方法以外，还有一个$.type方法，可以返回一个变量的数据类型。它的实质是用Object.prototype.toString方法读取对象内部的[[Class]]属性（参见《标准库》的Object对象一节）。 $.type(/test/) // "regexp" Ajax操作$.ajaxjQuery对象上面还定义了Ajax方法（$.ajax()），用来处理Ajax操作。调用该方法后，浏览器就会向服务器发出一个HTTP请求。 $.ajax()的用法主要有两种。 $.ajax(url[, options])$.ajax([options]) 上面代码中的url，指的是服务器网址，options则是一个对象参数，设置Ajax请求的具体参数。 $.ajax(&#123; async: true, url: '/url/to/json', type: 'GET', data : &#123; id : 123 &#125;, dataType: 'json', timeout: 30000, success: successCallback, error: errorCallback, complete: completeCallback, statusCode: &#123; 404: handler404, 500: handler500 &#125;&#125;)function successCallback(json) &#123; $('&lt;h1/&gt;').text(json.title).appendTo('body');&#125;function errorCallback(xhr, status)&#123; console.log('出问题了！');&#125;function completeCallback(xhr, status)&#123; console.log('Ajax请求已结束。');&#125; 上面代码的对象参数有多个属性，含义如下： accepts：将本机所能处理的数据类型，告诉服务器。 async：该项默认为true，如果设为false，则表示发出的是同步请求。 beforeSend：指定发出请求前，所要调用的函数，通常用来对发出的数据进行修改。 cache：该项默认为true，如果设为false，则浏览器不缓存返回服务器返回的数据。注意，浏览器本身就不会缓存POST请求返回的数据，所以即使设为false，也只对HEAD和GET请求有效。 complete：指定当HTTP请求结束时（请求成功或请求失败的回调函数，此时已经运行完毕）的回调函数。不管请求成功或失败，该回调函数都会执行。它的参数为发出请求的原始对象以及返回的状态信息。 contentType：发送到服务器的数据类型。 context：指定一个对象，作为所有Ajax相关的回调函数的this对象。 crossDomain：该属性设为true，将强制向相同域名发送一个跨域请求（比如JSONP）。 data：向服务器发送的数据，如果使用GET方法，此项将转为查询字符串，附在网址的最后。 dataType：向服务器请求的数据类型，可以设为text、html、script、json、jsonp和xml。 error：请求失败时的回调函数，函数参数为发出请求的原始对象以及返回的状态信息。 headers：指定HTTP请求的头信息。 ifModified：如果该属性设为true，则只有当服务器端的内容与上次请求不一样时，才会发出本次请求。 jsonp：指定JSONP请求“callback=?”中的callback的名称。 jsonpCallback: 指定JSONP请求中回调函数的名称。 mimeType：指定HTTP请求的mime type。 password：指定HTTP认证所需要的密码。 statusCode：值为一个对象，为服务器返回的状态码，指定特别的回调函数。 success：请求成功时的回调函数，函数参数为服务器传回的数据、状态信息、发出请求的原始对象。 timeout: 等待的最长毫秒数。如果过了这个时间，请求还没有返回，则自动将请求状态改为失败。 type：向服务器发送信息所使用的HTTP动词，默认为GET，其他动词有POST、PUT、DELETE。 url：服务器端网址。这是唯一必需的一个属性，其他属性都可以省略。 username：指定HTTP认证的用户名。 xhr：指定生成XMLHttpRequest对象时的回调函数。 这些参数之中，url可以独立出来，作为ajax方法的第一个参数。也就是说，上面代码还可以写成下面这样。 $.ajax('/url/to/json',&#123; type: 'GET', dataType: 'json', success: successCallback, error: errorCallback&#125;) 作为向服务器发送的数据，data属性也可以写成一个对象。 $.ajax(&#123; url: '/remote/url', data: &#123; param1: 'value1', param2: 'value2', ... &#125;&#125;);// 相当于$.ajax(&#123; url: '/remote/url?param1=value1&amp;param2=value2...'&#125;&#125;); 简便写法ajax方法还有一些简便写法。 $.get()：发出GET请求。 $.getScript()：读取一个JavaScript脚本文件并执行。 $.getJSON()：发出GET请求，读取一个JSON文件。 $.post()：发出POST请求。 $.fn.load()：读取一个html文件，并将其放入当前元素之中。 一般来说，这些简便方法依次接受三个参数：url、数据、成功时的回调函数。 $.get()，$.post()这两个方法分别对应HTTP的GET方法和POST方法。 $.get('/data/people.html', function(html)&#123; $('#target').html(html);&#125;);$.post('/data/save', &#123;name: 'Rebecca'&#125;, function (resp)&#123; console.log(JSON.parse(resp));&#125;); get方法和post方法的参数相同，第一个参数是服务器网址，该参数是必需的，其他参数都是可选的。第二个参数是发送给服务器的数据，第三个参数是操作成功后的回调函数。 上面的post方法对应的ajax写法如下。 $.ajax(&#123; type: 'POST', url: '/data/save', data: &#123;name: 'Rebecca'&#125;, dataType: 'json', success: function (resp)&#123; console.log(JSON.parse(resp)); &#125;&#125;); $.getJSON()ajax方法的另一个简便写法是getJSON方法。当服务器端返回JSON格式的数据，可以用这个方法代替$.ajax方法。 $.getJSON('url/to/json', &#123;'a': 1&#125;, function(data)&#123; console.log(data);&#125;); 上面的代码等同于下面的写法。 $.ajax(&#123; dataType: "json", url: '/url/to/data', data: &#123;'a': 1&#125;, success: function(data)&#123; console.log(data); &#125;&#125;); $.getScript()$.getScript方法用于从服务器端加载一个脚本文件。 $.getScript('/static/js/myScript.js', function() &#123; functionFromMyScript();&#125;); 上面代码先从服务器加载myScript.js脚本，然后在回调函数中执行该脚本提供的函数。 getScript的回调函数接受三个参数，分别是脚本文件的内容，HTTP响应的状态信息和ajax对象实例。 $.getScript( "ajax/test.js", function (data, textStatus, jqxhr)&#123; console.log( data ); // test.js的内容 console.log( textStatus ); // Success console.log( jqxhr.status ); // 200&#125;); getScript是ajax方法的简便写法，因此返回的是一个deferred对象，可以使用deferred接口。 jQuery.getScript("/path/to/myscript.js") .done(function() &#123; // ... &#125;) .fail(function() &#123; // ...&#125;); $.fn.load()$.fn.load不是jQuery的工具方法，而是定义在jQuery对象实例上的方法，用于获取服务器端的HTML文件，将其放入当前元素。由于该方法也属于ajax操作，所以放在这里一起讲。 $('#newContent').load('/foo.html'); $.fn.load方法还可以指定一个选择器，将远程文件中匹配选择器的部分，放入当前元素，并指定操作完成时的回调函数。 $('#newContent').load('/foo.html #myDiv h1:first', function(html) &#123; console.log('内容更新！');&#125;); 上面代码只加载foo.html中匹配“#myDiv h1:first”的部分，加载完成后会运行指定的回调函数。 $('#main-menu a').click(function(event) &#123; event.preventDefault(); $('#main').load(this.href + ' #main *');&#125;); 上面的代码将指定网页中匹配“#main *”，加载入当前的main元素。星号表示匹配main元素包含的所有子元素，如果不加这个星号，就会加载整个main元素（包括其本身），导致一个main元素中还有另一个main元素。 load方法可以附加一个字符串或对象作为参数，一起向服务器提交。如果是字符串，则采用GET方法提交；如果是对象，则采用POST方法提交。 $( "#feeds" ).load( "feeds.php", &#123; limit: 25 &#125;, function() &#123; console.log( "已经载入" );&#125;); 上面代码将{ limit: 25 }通过POST方法向服务器提交。 load方法的回调函数，可以用来向用户提示操作已经完成。 $('#main-menu a').click(function(event) &#123; event.preventDefault(); $('#main').load(this.href + ' #main *', function(responseText, status) &#123; if (status === 'success') &#123; $('#notification-bar').text('加载成功！'); &#125; else &#123; $('#notification-bar').text('出错了！'); &#125; &#125;);&#125;); Ajax事件jQuery提供以下一些方法，用于指定特定的AJAX事件的回调函数。 .ajaxComplete()：ajax请求完成。 .ajaxError()：ajax请求出错。 .ajaxSend()：ajax请求发出之前。 .ajaxStart()：第一个ajax请求开始发出，即没有还未完成ajax请求。 .ajaxStop()：所有ajax请求完成之后。 .ajaxSuccess()：ajax请求成功之后。 下面是示例。 $('#loading_indicator').ajaxStart(function ()&#123;$(this).show();&#125;).ajaxStop(function ()&#123;$(this).hide();&#125;); 下面是处理Ajax请求出错（返回404或500错误）的例子。 $(document).ajaxError(function (e, xhr, settings, error) &#123; console.log(error);&#125;); 返回值ajax方法返回的是一个deferred对象，可以用then方法为该对象指定回调函数（详细解释参见《deferred对象》一节）。 $.ajax(&#123; url: '/data/people.json', dataType: 'json'&#125;).then(function (resp)&#123; console.log(resp.people);&#125;) JSONP由于浏览器存在“同域限制”，ajax方法只能向当前网页所在的域名发出HTTP请求。但是，通过在当前网页中插入script元素（\&lt;script>），可以向不同的域名发出GET请求，这种变通方法叫做JSONP（JSON with Padding）。 ajax方法可以发出JSONP请求，方法是在对象参数中指定dataType为JSONP。 $.ajax(&#123; url: '/data/search.jsonp', data: &#123;q: 'a'&#125;, dataType: 'jsonp', success: function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;&#125;);) JSONP的通常做法是，在所要请求的URL后面加在回调函数的名称。ajax方法规定，如果所请求的网址以类似“callback=?”的形式结尾，则自动采用JSONP形式。所以，上面的代码还可以写成下面这样。 $.getJSON('/data/search.jsonp?q=a&amp;callback=?', function(resp) &#123; $('#target').html('Results: ' + resp.results.length); &#125;); 文件上传假定网页有一个文件控件。 &lt;input type="file" id="test-input"&gt; 下面就是如何使用Ajax上传文件。 var file = $('#test-input')[0].files[0];var formData = new FormData();formData.append('file', file);$.ajax('myserver/uploads', &#123; method: 'POST', contentType: false, processData: false, data: formData&#125;); 上面代码是将文件作为表单数据发送。除此之外，也可以直接发送文件。 var file = $('#test-input')[0].files[0];$.ajax('myserver/uploads', &#123; method: 'POST', contentType: file.type, processData: false, data: file&#125;);]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery概述]]></title>
    <url>%2F2015%2F08%2F10%2Fjquery-basic%2F</url>
    <content type="text"><![CDATA[据统计，全世界57.5%的网站使用jQuery，在使用JavaScript函数库的网站中，93.0%使用jQuery。它已经成了开发者必须学会的技能。 jQuery的最大优势有两个。首先，它基本是一个DOM操作工具，可以使操作DOM对象变得异常容易。其次，它统一了不同浏览器的API接口，使得代码在所有现代浏览器均能运行，开发者不用担心浏览器之间的差异。 jQuery的加载一般采用下面的写法，在网页中加载jQuery。 &lt;script type="text/javascript" src="//code.jquery.com/jquery-1.11.0.min.js"&gt;&lt;/script&gt;&lt;script&gt;window.jQuery || document.write( '&lt;script src="js/jquery-1.11.0.min.js" type="text/javascript"&gt;&lt;\/script&gt;' );&lt;/script&gt; 上面代码有两点需要注意。一是采用CDN加载。如果CDN加载失败，则退回到本地加载。二是采用协议无关的加载网址（使用双斜线表示），同时支持http协议和https协议。 目前常用的jQuery CDN有以下这些。 Google CDN Microsoft CDN jQuery CDN CDNJS CDN jsDelivr CDN 上面这段代码最好放到网页尾部。如果需要支持IE 6/7/8，就使用jQuery 1.x版，否则使用最新版。 jQuery基础jQuery对象jQuery最重要的概念，就是jQuery对象。它是一个全局对象，可以简写为美元符号$。也就是说，jQuery和$两者是等价的。 在网页中加载jQuery函数库以后，就可以使用jQuery对象了。jQuery的全部方法，都定义在这个对象上面。 var listItems = jQuery('li');// orvar listItems = $('li'); 上面两行代码是等价的，表示选中网页中所有的li元素。 jQuery构造函数jQuery对象本质上是一个构造函数，主要作用是返回jQuery对象的实例。比如，上面代码表面上是选中li元素，实际上是返回对应于li元素的jQuery实例。因为只有这样，才能在DOM对象上使用jQuery提供的各种方法。 $('body').nodeType// undefined$('body') instanceof jQuery// true 上面代码表示，由于jQuery返回的不是DOM对象，所以没有DOM属性nodeType。它返回的是jQuery对象的实例。 jQuery构造函数可以多种参数，返回不同的值。 CSS选择器作为参数jQuery构造函数的参数，主要是CSS选择器，就像上面的那个例子。下面是另外一些CSS选择器的例子。 $("*")$("#lastname")$(".intro")$("h1,div,p")$("p:last")$("tr:even")$("p:first-child")$("p:nth-of-type(2)")$("div + p")$("div:has(p)")$(":empty")$("[title^='Tom']") 本书不讲解CSS选择器，请读者参考有关书籍和jQuery文档。 除了CSS选择器，jQuery还定义了一些自有的选择器，比如contains选择器用来选择包含特定文本的元素。下面是一个例子。 var search = $('#search').val();$('div:not(:contains("' + search + '"))').hide(); 上面代码用来选中包含搜索框输入文本的元素。 DOM对象作为参数jQuery构造函数的参数，还可以是DOM对象。它也会被转为jQuery对象的实例。 $(document.body) instanceof jQuery// true 上面代码中，jQuery的参数不是CSS选择器，而是一个DOM对象，返回的依然是jQuery对象的实例。 如果有多个DOM元素要转为jQuery对象的实例，可以把DOM元素放在一个数组里，输入jQuery构造函数。 $([document.body, document.head]) HTML字符串作为参数如果直接在jQuery构造函数中输入HTML字符串，返回的也是jQuery实例。 $('&lt;li class="greet"&gt;test&lt;/li&gt;') 上面代码从HTML代码生成了一个jQuery实例，它与从CSS选择器生成的jQuery实例完全一样。唯一的区别就是，它对应的DOM结构不属于当前文档。 上面代码也可以写成下面这样。 $( '&lt;li&gt;', &#123; html: 'test', 'class': 'greet'&#125;); 上面代码中，由于class是javaScript的保留字，所以只能放在引号中。 通常来说，上面第二种写法是更好的写法。 $('&lt;input class="form-control" type="hidden" name="foo" value="bar" /&gt;')// 相当于$('&lt;input/&gt;', &#123; 'class': 'form-control', type: 'hidden', name: 'foo', value: 'bar'&#125;)// 或者$('&lt;input/&gt;').addClass('form-control').attr('type', 'hidden').attr('name', 'foo').val('bar') 由于新增的DOM节点不属于当前文档，所以可以用这种写法预加载图片。 $.preloadImages = function () &#123; for (var i = 0; i &lt; arguments.length; i++) &#123; $('&lt;img&gt;').attr('src', arguments[i]); &#125;&#125;;$.preloadImages('img/hover-on.png', 'img/hover-off.png'); 第二个参数默认情况下，jQuery将文档的根元素（html）作为寻找匹配对象的起点。如果要指定某个网页元素（比如某个div元素）作为寻找的起点，可以将它放在jQuery函数的第二个参数。 $('li', someElement); 上面代码表示，只寻找属于someElement对象下属的li元素。someElement可以是jQuery对象的实例，也可以是DOM对象。 jQuery构造函数返回的结果集jQuery的核心思想是“先选中某些网页元素，然后对其进行某种处理”（find something, do something），也就是说，先选择后处理，这是jQuery的基本操作模式。所以，绝大多数jQuery操作都是从选择器开始的，返回一个选中的结果集。 length属性jQuery对象返回的结果集是一个类似数组的对象，包含了所有被选中的网页元素。查看该对象的length属性，可以知道到底选中了多少个结果。 if ( $('li').length === 0 ) &#123; console.log('不含li元素');&#125; 上面代码表示，如果网页没有li元素，则返回对象的length属性等于0。这就是测试有没有选中的标准方法。 所以，如果想知道jQuery有没有选中相应的元素，不能写成下面这样。 if ($('div.foo')) &#123; ... &#125; 因为不管有没有选中，jQuery构造函数总是返回一个实例对象，而对象的布尔值永远是true。使用length属性才是判断有没有选中的正确方法。 if ($('div.foo').length) &#123; ... &#125; 下标运算符jQuery选择器返回的是一个类似数组的对象。但是，使用下标运算符取出的单个对象，并不是jQuery对象的实例，而是一个DOM对象。 $('li')[0] instanceof jQuery // false$('li')[0] instanceof Element // true 上面代码表示，下标运算符取出的是Element节点的实例。所以，通常使用下标运算符将jQuery实例转回DOM对象。 is方法is方法返回一个布尔值，表示选中的结果是否符合某个条件。这个用来验证的条件，可以是CSS选择器，也可以是一个函数，或者DOM元素和jQuery实例。 $('li').is('li') // true$('li').is($('.item'))$('li').is(document.querySelector('li'))$('li').is(function() &#123; return $("strong", this).length === 0;&#125;); get方法jQuery实例的get方法是下标运算符的另一种写法。 $('li').get(0) instanceof Element // true eq方法如果想要在结果集取出一个jQuery对象的实例，不需要取出DOM对象，则使用eq方法，它的参数是实例在结果集中的位置（从0开始）。 $('li').eq(0) instanceof jQuery // true 由于eq方法返回的是jQuery的实例，所以可以在返回结果上使用jQuery实例对象的方法。 each方法，map方法这两个方法用于遍历结果集，对每一个成员进行某种操作。 each方法接受一个函数作为参数，依次处理集合中的每一个元素。 $('li').each(function( index, element) &#123; $(element).prepend( '&lt;em&gt;' + index + ': &lt;/em&gt;' );&#125;);// &lt;li&gt;Hello&lt;/li&gt;// &lt;li&gt;World&lt;/li&gt;// 变为// &lt;li&gt;&lt;em&gt;0: &lt;/em&gt;Hello&lt;/li&gt;// &lt;li&gt;&lt;em&gt;1: &lt;/em&gt;World&lt;/li&gt; 从上面代码可以看出，作为each方法参数的函数，本身有两个参数，第一个是当前元素在集合中的位置，第二个是当前元素对应的DOM对象。 map方法的用法与each方法完全一样，区别在于each方法没有返回值，只是对每一个元素执行某种操作，而map方法返回一个新的jQuery对象。 $("input").map(function (index, element)&#123; return $(this).val();&#125;).get().join(", ") 上面代码表示，将所有input元素依次取出值，然后通过get方法得到一个包含这些值的数组，最后通过数组的join方法返回一个逗号分割的字符串。 内置循环jQuery默认对当前结果集进行循环处理，所以如果直接使用jQuery内置的某种方法，each和map方法是不必要的。 $(".class").addClass("highlight"); 上面代码会执行一个内部循环，对每一个选中的元素进行addClass操作。由于这个原因，对上面操作加上each方法是不必要的。 $(".class").each(function(index,element)&#123; $(element).addClass("highlight");&#125;);// 或者$(".class").each(function()&#123; $(this).addClass("highlight");&#125;); 上面代码的each方法，都是没必要使用的。 由于内置循环的存在，从性能考虑，应该尽量减少不必要的操作步骤。 $(".class").css("color", "green").css("font-size", "16px");// 应该写成$(".class").css(&#123; "color": "green", "font-size": "16px"&#125;); 链式操作jQuery最方便的一点就是，它的大部分方法返回的都是jQuery对象，因此可以链式操作。也就是说，后一个方法可以紧跟着写在前一个方法后面。 $('li').click(function ()&#123; $(this).addClass('clicked');&#125;).find('span').attr( 'title', 'Hover over me' ); $(document).ready()$(document).ready方法接受一个函数作为参数，将该参数作为document对象的DOMContentLoaded事件的回调函数。也就是说，当页面解析完成（即下载完&lt;/html&gt;标签）以后，在所有外部资源（图片、脚本等）完成加载之前，该函数就会立刻运行。 $( document ).ready(function() &#123; console.log( 'ready!' );&#125;); 上面代码表示，一旦页面完成解析，就会运行ready方法指定的函数，在控制台显示“ready!”。 该方法通常作为网页初始化手段使用，jQuery提供了一种简写法，就是直接把回调函数放在jQuery对象中。 $(function() &#123; console.log( 'ready!' );&#125;); 上面代码与前一段代码是等价的。 $.noConflict方法jQuery使用美元符号（$）指代jQuery对象。某些情况下，其他函数库也会用到美元符号，为了避免冲突，$.noConflict方法允许将美元符号与jQuery脱钩。 &lt;script src="other_lib.js"&gt;&lt;/script&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt;$.noConflict();&lt;/script&gt; 上面代码就是$.noConflict方法的一般用法。在加载jQuery之后，立即调用该方法，会使得美元符号还给前面一个函数库。这意味着，其后再调用jQuery，只能写成jQuery.methond的形式，而不能用$.method了。 为了避免冲突，可以考虑从一开始就只使用jQuery代替美元符号。 jQuery实例对象的方法除了上一节提到的is、get、eq方法，jQuery实例还有许多其他方法。 结果集的过滤方法选择器选出一组符合条件的网页元素以后，jQuery提供了许多方法，可以过滤结果集，返回更准确的目标。 first方法，last方法first方法返回结果集的第一个成员，last方法返回结果集的最后一个成员。 $("li").first()$("li").last() next方法，prev方法next方法返回紧邻的下一个同级元素，prev方法返回紧邻的上一个同级元素。 $("li").first().next()$("li").last().prev()$("li").first().next('.item')$("li").last().prev('.item') 如果next方法和prev方法带有参数，表示选择符合该参数的同级元素。 parent方法，parents方法，children方法parent方法返回当前元素的父元素，parents方法返回当前元素的所有上级元素（直到html元素）。 $("p").parent()$("p").parent(".selected")$("p").parents()$("p").parents("div") children方法返回选中元素的所有子元素。 $("div").children()$("div").children(".selected")// 下面的写法结果相同，但是效率较低$('div &gt; *')$('div &gt; .selected') 上面这三个方法都接受一个选择器作为参数。 siblings方法，nextAll方法，prevAll方法siblings方法返回当前元素的所有同级元素。 $('li').first().siblings()$('li').first().siblings('.item') nextAll方法返回当前元素其后的所有同级元素，prevAll方法返回当前元素前面的所有同级元素。 $('li').first().nextAll()$('li').last().prevAll() closest方法，find方法closest方法返回当前元素，以及当前元素的所有上级元素之中，第一个符合条件的元素。find方法返回当前元素的所有符合条件的下级元素。 $('li').closest('div')$('div').find('li') 上面代码中的find方法，选中所有div元素下面的li元素，等同于$(‘li’, ‘div’)。由于这样写缩小了搜索范围，所以要优于$(‘div li’)的写法。 find方法，add方法，addBack方法，end方法add方法用于为结果集添加元素。 $('li').add('p') addBack方法将当前元素加回原始的结果集。 $('li').parent().addBack() end方法用于返回原始的结果集。 $('li').first().end() filter方法，not方法，has方法filter方法用于过滤结果集，它可以接受多种类型的参数，只返回与参数一致的结果。 // 返回符合CSS选择器的结果$('li').filter('.item')// 返回函数返回值为true的结果$("li").filter(function(index) &#123; return index % 2 === 1;&#125;)// 返回符合特定DOM对象的结果$("li").filter(document.getElementById("unique"))// 返回符合特定jQuery实例的结果$("li").filter($("#unique")) not方法的用法与filter方法完全一致，但是返回相反的结果，即过滤掉匹配项。 $('li').not('.item') has方法与filter方法作用相同，但是只过滤出子元素符合条件的元素。 $("li").has("ul") 上面代码返回具有ul子元素的li元素。 DOM相关方法许多方法可以对DOM元素进行处理。 html方法和text方法html方法返回该元素包含的HTML代码，text方法返回该元素包含的文本。 假定网页只含有一个p元素。 &lt;p&gt;&lt;em&gt;Hello World!&lt;/em&gt;&lt;/p&gt; html方法和text方法的返回结果分别如下。 $('p').html()// &lt;em&gt;Hello World!&lt;/em&gt;$('p').text()// Hello World! jQuery的许多方法都是取值器（getter）与赋值器（setter）的合一，即取值和赋值都是同一个方法，不使用参数的时候为取值器，使用参数的时候为赋值器。 上面代码的html方法和text方法都没有参数，就会当作取值器使用，取回结果集的第一个元素所包含的内容。如果对这两个方法提供参数，就是当作赋值器使用，修改结果集所有成员的内容，并返回原来的结果集，以便进行链式操作。 $('p').html('&lt;strong&gt;你好&lt;/strong&gt;')// 网页代码变为&lt;p&gt;&lt;strong&gt;你好&lt;/strong&gt;&lt;/p&gt;$('p').text('你好')// 网页代码变为&lt;p&gt;你好&lt;/p&gt; 下面要讲到的jQuery其他许多方法，都采用这种同一个方法既是取值器又是赋值器的模式。 html方法和text方法还可以接受一个函数作为参数，函数的返回值就是网页元素所要包含的新的代码和文本。这个函数接受两个参数，第一个是网页元素在集合中的位置，第二个参数是网页元素原来的代码或文本。 $('li').html(function (i, v)&#123; return (i + ': ' + v); &#125;)// &lt;li&gt;Hello&lt;/li&gt;// &lt;li&gt;World&lt;/li&gt;// 变为// &lt;li&gt;0: Hello&lt;/li&gt;// &lt;li&gt;1: World&lt;/li&gt; addClass方法，removeClass方法，toggleClass方法addClass方法用于添加一个类，removeClass方法用于移除一个类，toggleClass方法用于折叠一个类（如果无就添加，如果有就移除）。 $('li').addClass('special')$('li').removeClass('special')$('li').toggleClass('special') css方法css方法用于改变CSS设置。 该方法可以作为取值器使用。 $('h1').css('fontSize'); css方法的参数是css属性名。这里需要注意，CSS属性名的CSS写法和DOM写法，两者都可以接受，比如font-size和fontSize都行。 css方法也可以作为赋值器使用。 $('li').css('padding-left', '20px')// 或者$('li').css(&#123; 'padding-left': '20px'&#125;); 上面两种形式都可以用于赋值，jQuery赋值器基本上都是如此。 val方法val方法返回结果集第一个元素的值，或者设置当前结果集所有元素的值。 $('input[type="text"]').val()$('input[type="text"]').val('new value') prop方法，attr方法首先，这里要区分两种属性。 一种是网页元素的属性，比如a元素的href属性、img元素的src属性。这要使用attr方法读写。 // 读取属性值$('textarea').attr(name)//写入属性值$('textarea').attr(name, val) 下面是通过设置a元素的target属性，使得网页上的外部链接在新窗口打开的例子。 $('a[href^="http"]').attr('target', '_blank');$('a[href^="//"]').attr('target', '_blank');$('a[href^="' + window.location.origin + '"]').attr('target', '_self'); 另一种是DOM元素的属性，比如tagName、nodeName、nodeType等等。这要使用prop方法读写。 // 读取属性值$('textarea').prop(name)// 写入属性值$('textarea').prop(name, val) 所以，attr方法和prop方法针对的是不同的属性。在英语中，attr是attribute的缩写，prop是property的缩写，中文很难表达出这种差异。有时，attr方法和prop方法对同一个属性会读到不一样的值。比如，网页上有一个单选框。 &lt;input type="checkbox" checked="checked" /&gt; 对于checked属性，attr方法读到的是checked，prop方法读到的是true。 $(input[type=checkbox]).attr("checked") // "checked"$(input[type=checkbox]).prop("checked") // true 可以看到，attr方法读取的是网页上该属性的值，而prop方法读取的是DOM元素的该属性的值，根据规范，element.checked应该返回一个布尔值。所以，判断单选框是否选中，要使用prop方法。事实上，不管这个单选框是否选中，attr(“checked”)的返回值都是checked。 if ($(elem).prop("checked")) &#123; /*... */ &#125;;// 下面两种方法亦可if ( elem.checked ) &#123; /*...*/ &#125;;if ( $(elem).is(":checked") ) &#123; /*...*/ &#125;; removeProp方法，removeAttr方法removeProp方法移除某个DOM属性，removeAttr方法移除某个HTML属性。 $("a").prop("oldValue",1234).removeProp('oldValue')$('a').removeAttr("title") data方法data方法用于在一个DOM对象上储存数据。 // 储存数据$("body").data("foo", 52);// 读取数据$("body").data("foo"); 该方法可以在DOM节点上储存各种类型的数据。 添加、复制和移动网页元素的方法jQuery方法提供一系列方法，可以改变元素在文档中的位置。 append方法，appendTo方法append方法将参数中的元素插入当前元素的尾部。 $("div").append("&lt;p&gt;World&lt;/p&gt;")// &lt;div&gt;Hello &lt;/div&gt;// 变为// &lt;div&gt;Hello &lt;p&gt;World&lt;/p&gt;&lt;/div&gt; appendTo方法将当前元素插入参数中的元素尾部。 $("&lt;p&gt;World&lt;/p&gt;").appendTo("div") 上面代码返回与前一个例子一样的结果。 prepend方法，prependTo方法prepend方法将参数中的元素，变为当前元素的第一个子元素。 $("p").prepend("Hello ")// &lt;p&gt;World&lt;/p&gt;// 变为// &lt;p&gt;Hello World&lt;/p&gt; 如果prepend方法的参数不是新生成的元素，而是当前页面已存在的元素，则会产生移动元素的效果。 $("p").prepend("strong")// &lt;strong&gt;Hello &lt;/strong&gt;&lt;p&gt;World&lt;/p&gt;// 变为// &lt;p&gt;&lt;strong&gt;Hello &lt;/strong&gt;World&lt;/p&gt; 上面代码运行后，strong元素的位置将发生移动，而不是克隆一个新的strong元素。不过，如果当前结果集包含多个元素，则除了第一个以后，后面的p元素都将插入一个克隆的strong子元素。 prependTo方法将当前元素变为参数中的元素的第一个子元素。 $("&lt;p&gt;&lt;/p&gt;").prependTo("div")// &lt;div&gt;&lt;/div&gt;// 变为// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; after方法，insertAfter方法after方法将参数中的元素插在当前元素后面。 $("div").after("&lt;p&gt;&lt;/p&gt;")// &lt;div&gt;&lt;/div&gt;// 变为// &lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt; insertAfter方法将当前元素插在参数中的元素后面。 $("&lt;p&gt;&lt;/p&gt;").insertAfter("div") 上面代码返回与前一个例子一样的结果。 before方法，insertBefore方法before方法将参数中的元素插在当前元素的前面。 $("div").before("&lt;p&gt;&lt;/p&gt;")// &lt;div&gt;&lt;/div&gt;// 变为// &lt;p&gt;&lt;/p&gt;&lt;div&gt;&lt;/div&gt; insertBefore方法将当前元素插在参数中的元素的前面。 $("&lt;p&gt;&lt;/p&gt;").insertBefore("div") 上面代码返回与前一个例子一样的结果。 wrap方法，wrapAll方法，unwrap方法，wrapInner方法wrap方法将参数中的元素变成当前元素的父元素。 $("p").wrap("&lt;div&gt;&lt;/div&gt;")// &lt;p&gt;&lt;/p&gt;// 变为// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; wrap方法的参数还可以是一个函数。 $("p").wrap(function() &#123; return "&lt;div&gt;&lt;/div&gt;";&#125;) 上面代码返回与前一个例子一样的结果。 wrapAll方法为结果集的所有元素，添加一个共同的父元素。 $("p").wrapAll("&lt;div&gt;&lt;/div&gt;")// &lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;// 变为// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt; unwrap方法移除当前元素的父元素。 $("p").unwrap()// &lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;// 变为// &lt;p&gt;&lt;/p&gt; wrapInner方法为当前元素的所有子元素，添加一个父元素。 $("p").wrapInner('&lt;strong&gt;&lt;/strong&gt;')// &lt;p&gt;Hello&lt;/p&gt;// 变为// &lt;p&gt;&lt;strong&gt;Hello&lt;/strong&gt;&lt;/p&gt; clone方法clone方法克隆当前元素。 var clones = $('li').clone(); 对于那些有id属性的节点，clone方法会连id属性一起克隆。所以，要把克隆的节点插入文档的时候，务必要修改或移除id属性。 remove方法，detach方法，replaceWith方法remove方法移除并返回一个元素，取消该元素上所有事件的绑定。detach方法也是移除并返回一个元素，但是不取消该元素上所有事件的绑定。 $('p').remove()$('p').detach() replaceWith方法用参数中的元素，替换并返回当前元素，取消当前元素的所有事件的绑定。 $('p').replaceWith('&lt;div&gt;&lt;/div&gt;') 动画效果方法jQuery提供一些方法，可以很容易地显示网页动画效果。但是，总体上来说，它们不如CSS动画强大和节省资源，所以应该优先考虑使用CSS动画。 如果将jQuery.fx.off设为true，就可以将所有动画效果关闭，使得网页元素的各种变化一步到位，没有中间过渡的动画效果。 动画效果的简便方法jQuery提供以下一些动画效果方法。 show：显示当前元素。 hide：隐藏当前元素。 toggle：显示或隐藏当前元素。 fadeIn：将当前元素的不透明度（opacity）逐步提升到100%。 fadeOut：将当前元素的不透明度逐步降为0%。 fadeToggle：以逐渐透明或逐渐不透明的方式，折叠显示当前元素。 slideDown：以从上向下滑入的方式显示当前元素。 slideUp：以从下向上滑出的方式隐藏当前元素。 slideToggle：以垂直滑入或滑出的方式，折叠显示当前元素。 上面这些方法可以不带参数调用，也可以接受毫秒或预定义的关键字作为参数。 $('.hidden').show();$('.hidden').show(300);$('.hidden').show('slow'); 上面三行代码分别表示，以默认速度、300毫秒、较慢的速度隐藏一个元素。 jQuery预定义的关键字是在jQuery.fx.speeds对象上面，可以自行改动这些值，或者创造新的值。 jQuery.fx.speeds.fast = 50;jQuery.fx.speeds.slow = 3000;jQuery.fx.speeds.normal = 1000; 上面三行代码重新定义fast、normal、slow关键字对应的毫秒数。 你还可以定义自己的关键字。 jQuery.fx.speeds.blazing = 30;// 调用$('.hidden').show('blazing'); 这些方法还可以接受一个函数，作为第二个参数，表示动画结束后的回调函数。 $('p').fadeOut(300, function() &#123; $(this).remove();&#125;); 上面代码表示，p元素以300毫秒的速度淡出，然后调用回调函数，将其从DOM中移除。 使用按钮控制某个元素折叠显示的代码如下。 // Fade$('.btn').click(function () &#123; $('.element').fadeToggle('slow');&#125;);// Toggle$('.btn').click(function () &#123; $('.element').slideToggle('slow');&#125;); animate方法上面这些动画效果方法，实际上都是animate方法的简便写法。在幕后，jQuery都是统一使用animate方法生成各种动画效果。 $('a.top').click(function (e) &#123; e.preventDefault(); $('html, body').animate(&#123;scrollTop: 0&#125;, 800);&#125;); 上面代码是点击链接，回到页面头部的写法。其中，animate方法接受两个参数，第一个参数是一个对象，表示动画结束时相关CSS属性的值，第二个参数是动画持续的毫秒数。需要注意的是，第一个参数对象的成员名称，必须与CSS属性名称一致，如果CSS属性名称带有连字号，则需要用“骆驼拼写法”改写。 animate方法还可以接受第三个参数，表示动画结束时的回调函数。 $('div').animate(&#123; left: '+=50', // 增加50 opacity: 0.25, fontSize: '12px' &#125;, 300, // 持续时间 function() &#123; // 回调函数 console.log('done!'); &#125;); 上面代码表示，动画结束时，在控制台输出“done！”。 stop方法，delay方法stop方法表示立即停止执行当前的动画。 $("#stop").click(function() &#123; $(".block").stop();&#125;); 上面代码表示，点击按钮后，block元素的动画效果停止。 delay方法接受一个时间参数，表示暂停多少毫秒后继续执行。 $("#foo").slideUp(300).delay(800).fadeIn(400) 上面代码表示，slideUp动画之后，暂停800毫秒，然后继续执行fadeIn动画。 其他方法jQuery还提供一些供特定元素使用的方法。 serialize方法用于将表单元素的值，转为url使用的查询字符串。 $( "form" ).on( "submit", function( event ) &#123; event.preventDefault(); console.log( $( this ).serialize() );&#125;);// single=Single&amp;multiple=Multiple&amp;check=check2&amp;radio=radio1 serializeArray方法用于将表单元素的值转为数组。 $("form").submit(function (event)&#123; console.log($(this).serializeArray()); event.preventDefault();&#125;);// [// &#123;name : 'field1', value : 123&#125;,// &#123;name : 'field2', value : 'hello world'&#125;// ] 事件处理事件绑定的简便方法jQuery提供一系列方法，允许直接为常见事件绑定回调函数。比如，click方法可以为一个元素绑定click事件的回调函数。 $('li').click(function (e)&#123; console.log($(this).text());&#125;); 上面代码为li元素绑定click事件的回调函数，点击后在控制台显示li元素包含的文本。 这样绑定事件的简便方法有如下一些： click keydown keypress keyup mouseover mouseout mouseenter mouseleave scroll focus blur resize hover 如果不带参数调用这些方法，就是触发相应的事件，从而引发回调函数的运行。 $('li').click() 上面代码将触发click事件的回调函数。 需要注意的是，通过这种方法触发回调函数，将不会引发浏览器对该事件的默认行为。比如，对a元素调用click方法，将只触发事先绑定的回调函数，而不会导致浏览器将页面导向href属性指定的网址。 下面是一个捕捉用户按下escape键的函数。 $(document).keyup(function(e) &#123; if (e.keyCode == 27) &#123; $('body').toggleClass('show-nav'); // $('body').removeClass('show-nav'); &#125;&#125;); 上面代码中，用户按下escape键，jQuery就会为body元素添加/去除名为show-nav的class。 hover方法需要特别说明。它接受两个回调函数作为参数，分别代表mouseenter和mouseleave事件的回调函数。 $(selector).hover(handlerIn, handlerOut)// 等同于$(selector).mouseenter(handlerIn).mouseleave(handlerOut) 下面是一个例子，当按钮发生hover事件，添加一个class样式，当hover事件结束时，再取消这个class。 $('.btn').hover(function () &#123; $(this).addClass('hover');&#125;, function () &#123; $(this).removeClass('hover');&#125;); 使用toggleClass可以简化上面的代码。 $('.btn').hover(function () &#123; $(this).toggleClass('hover');&#125;); on方法，trigger方法，off方法除了简便方法，jQuery还提供事件处理的通用方法。 on方法on方法是jQuery事件绑定的统一接口。事件绑定的那些简便方法，其实都是on方法的简写形式。 on方法接受两个参数，第一个是事件名称，第二个是回调函数。 $('li').on('click', function (e)&#123; console.log($(this).text());&#125;); 上面代码为li元素绑定click事件的回调函数。 注意，在回调函数内部，this关键字指的是发生该事件的DOM对象。为了使用jQuery提供的方法，必须将DOM对象转为jQuery对象，因此写成$(this)。 on方法允许一次为多个事件指定同样的回调函数。 $('input[type="text"]').on('focus blur', function ()&#123; console.log('focus or blur');&#125;); 上面代码为文本框的focus和blur事件绑定同一个回调函数。 下面是一个例子，当图片加载失败，使用error事件，替换另一张图片。 $('img').on('error', function () &#123; if(!$(this).hasClass('broken-image')) &#123; $(this).prop('src', 'img/broken.png').addClass('broken-image'); &#125;&#125;); 下面是检查用户是否切换浏览器tab的例子。 $(document).on('visibilitychange', function (e) &#123; if (e.target.visibilityState === "visible") &#123; console.log('Tab is now in view!'); &#125; else if (e.target.visibilityState === "hidden") &#123; console.log('Tab is now hidden!'); &#125;&#125;); on方法还可以为当前元素的某一个子元素，添加回调函数。 $('ul').on('click', 'li', function (e)&#123; console.log(this);&#125;); 上面代码为ul的子元素li绑定click事件的回调函数。采用这种写法时，on方法接受三个参数，子元素选择器作为第二个参数，夹在事件名称和回调函数之间。 这种写法有两个好处。首先，click事件还是在ul元素上触发回调函数，但是会检查event对象的target属性是否为li子元素，如果为true，再调用回调函数。这样就比为li元素一一绑定回调函数，节省了内存空间。其次，这种绑定的回调函数，对于在绑定后生成的li元素依然有效。 on方法还允许向回调函数传入数据。 $("ul" ).on("click", &#123;name: "张三"&#125;, function (event)&#123; console.log(event.data.name);&#125;); 上面代码在发生click事件之后，会通过event对象的data属性，在控制台打印出所传入的数据（即“张三”）。 trigger方法trigger方法用于触发回调函数，它的参数就是事件的名称。 $('li').trigger('click') 上面代码触发li元素的click事件回调函数。与那些简便方法一样，trigger方法只触发回调函数，而不会引发浏览器的默认行为。 off方法off方法用于移除事件的回调函数。 $('li').off('click') 上面代码移除li元素所有的click事件回调函数。 事件的名称空间同一个事件有时绑定了多个回调函数，这时如果想移除其中的一个回调函数，可以采用“名称空间”的方式，即为每一个回调函数指定一个二级事件名，然后再用off方法移除这个二级事件的回调函数。 $('li').on('click.logging', function ()&#123; console.log('click.logging callback removed');&#125;);$('li').off('click.logging'); 上面代码为li元素定义了二级事件click.logging的回调函数，click.logging属于click名称空间，当发生click事件时会触发该回调函数。将click.logging作为off方法的参数，就会移除这个回调函数，但是对其他click事件的回调函数没有影响。 trigger方法也适用带名称空间的事件。 $('li').trigger('click.logging') event对象当回调函数被触发后，它们的参数通常是一个事件对象event。 $(document).on('click', function (e)&#123; // ...&#125;); 上面代码的回调函数的参数e，就代表事件对象event。 event对象有以下属性： type：事件类型，比如click。 which：触发该事件的鼠标按钮或键盘的键。 target：事件发生的初始对象。 data：传入事件对象的数据。 pageX：事件发生时，鼠标位置的水平坐标（相对于页面左上角）。 pageY：事件发生时，鼠标位置的垂直坐标（相对于页面左上角）。 event对象有以下方法： preventDefault：取消浏览器默认行为。 stopPropagation：阻止事件向上层元素传播。 一次性事件one方法指定一次性的回调函数，即这个函数只能运行一次。这对提交表单很有用。 $("#button").one( "click", function() &#123; return false; &#125; ); one方法本质上是回调函数运行一次，即解除对事件的监听。 document.getElementById("#button").addEventListener("click", handler);function handler(e) &#123; e.target.removeEventListener(e.type, arguments.callee); return false;&#125; 上面的代码在点击一次以后，取消了对click事件的监听。如果有特殊需要，可以设定点击2次或3次之后取消监听，这都是可以的。]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs在windows下的安装配置]]></title>
    <url>%2F2015%2F08%2F06%2Fnode-install%2F</url>
    <content type="text"><![CDATA[介绍一下nodejs在windows下的安装及配置 nodejs简介Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 的包管理器 npm，是全球最大的开源库生态系统。 为什么我们要使用nodejsnodejs在服务端与其他语言相比有个很大的优势就是非阻塞IO，专为网络服务而设计，高效的解决输入和输出，nodejs使用事件循环和线程池的方式来解决高并发的问题，但是对于大量的计算，nodejs却并不适合。 nodejs在windows下的安装 nodejs有很多种的安装方式，下面我用一种nvm的方式，来安装nodejs，nvm(nodejs version manager)是nodejs版本管理工具的意思。 安装步骤 首先确保你的网络畅通，还有不被墙，如果需要翻墙，请看：https://github.com/getlantern/lantern 下载nvm包 地址：nvm-windows，我们选择第一个：nvm-noinstall.zip 下载完成后解压到一个地方，比如: C:\dev\nvm 里面的文件列表是这样的：elevate.cmd、elevate.vbs、install.cmd、LICENSE、nvm.exe （备注：windows下要设置显示文件类型的扩展名，这样才能看到上述文件的后缀） 双击 install.cmd 然后会让你输入”压缩文件解压或拷贝到的一个绝对路径” 先不用管它，直接回车，成功后会在C盘的根目录生成一个settings.txt的文本文件，把这个文件剪切到C:\dev\nvm目录中，然后我们把它的内容修改成这样： root: C:\dev\nvm path: C:\dev\nodejs arch: 64 proxy: none 然后我们开始配置环境变量了，因为刚刚点击了install.cmd的文件，那么会在环境变量的系统变量中，生成两个环境变量：NVM_HOME 和 NVM_SYMLINK 我们开始修改这两个变量名的变量值：NVM_HOME的变量值为：C:\dev\nvm； NVM_SYMLINK的变量值为：C:\dev\nodejs 我们还会发现，在Path中也会自动添加上C:\dev\nvm;或者是C:\dev\nodejs，如果有的话，把他们删掉，没有的话更好，我们自己来配置，在Path的最前面输入： %NVM_HOME%;%NVM_SYMLINK%; 打开一个cmd窗口输入命令：nvm v ，那么我们会看到当前nvm的版本信息。然后我们可以安装nodejs了。 继续输入命令：nvm install latest 如果网络畅通，我们会看到正在下载的提示，下载完成后 会让你use那个最新的node版本。 如果你是第一次下载，在use之前，C:\dev目录下是没有nodejs这个文件夹的，在输入比如： nvm use 5.11.0 之后，你会发现，C:\dev目录下多了一个nodejs文件夹，这个文件夹不是单纯的文件夹，它是一个快捷方式，指向了 C:\dev\nvm 里的 v5.11.0 文件夹。 同样的咱们可以下载其他版本的nodejs，这样通过命令:nvm use 版本号 比如：nvm use 5.11.0就可以轻松实现版本切换了。 备注： 如果你的电脑系统是32 位的，那么在下载nodejs版本的时候，一定要指明 32 如： nvm install 5.11.0 32 这样在32位的电脑系统中，才可以使用，默认是64位的。 npm的安装首先 npm是什么？ npm有两层含义，第一是npm这个开源的模块登记和管理系统，也就是这个站点：https://www.npmjs.com。 第二个指的是 nodejs package manager 也就是nodejs的包管理工具。我们主要说的就是这一个。 在每个版本的nodejs中，都会自带npm，为了统一起见，我们安装一个全局的npm工具，这个操作很有必要，因为我们需要安装一些全局的其他包，不会因为切换node版本造成原来下载过的包不可用。 安装步骤 首先我们进入命令模式，输入 npm config set prefix “C:\dev\nvm\npm” 回车，这是在配置npm的全局安装路径，然后在用户文件夹下会生成一个.npmrc的文件，用记事本打开后可以看到如下内容： prefix=C:\dev\nvm\npm 然后继续在命令中输入： npm install npm -g 回车后会发现正在下载npm包，在C:\dev\nvm\npm目录中可以看到下载中的文件，以后我们只要用npm安装包的时候加上 -g 就可以把包安装在我们刚刚配置的全局路径下了。 我们为这个npm配置环境变量： 变量名为：NPM_HOME，变量值为 ：C:\dev\nvm\npm 在Path的最前面添加%NPM_HOME%;，注意了，这个一定要添加在 %NVM_SYMLINK%之前，所以我们直接把它放到Path的最前面。 最后我们新打开一个命令窗口，输入npm -v ,此时我们使用的就是我们统一下载的npm包了。 同样的我们还可以安装cnpm工具，它是中国版的npm镜像库，地址在这里：cnpmjs，也是npm官方的一个拷贝，因为我们和外界有一堵墙隔着，所以用这个国内的比较快，淘宝也弄了一个和npm一样的镜像库，npmtaobao，它和官方的npm每隔10分钟同步一次。安装方法： npm install -g cnpm --registry=http://r.cnpmjs.org 或者用淘宝的npm install -g cnpm --registry=https://registry.npm.taobao.org 安装好了cnpm后，直接执行cnpm install 包名比如：cnpm install bower -g 就可以了。-g只是为了把包安装在全局路径下。如果不全局安装，也可以在当前目录中安装，不用-g就可以了。]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SublimeText安装及常用插件推荐]]></title>
    <url>%2F2015%2F07%2F30%2Fsublime-intro%2F</url>
    <content type="text"><![CDATA[SublimeText可谓是前端工程师的代码编辑神器，用了一定会爱上她。 SublimeText安装官网下载根据自己的电脑系统下载相应的版本。 SublimeText 插件安装安装之前我们需要先安装package control组件。 package control安装在线安装点击此处选择左边SublimeText3栏目下面的代码复制，在SublimeText编辑器中按 ctrl+` 调出console面板，进行粘贴。 手动安装点击Preferences 选择Browse Packages ，打开其上一级文件夹Data并进入Installed Packages文件夹，将下载的Package Control.sublime-package文件复制进去，再重启SublimeText。 插件安装在线安装按下Ctrl+Shift+P调出命令面板，输入install选择Install Package 选项并回车，再输入你要安装的插件名称(例如sublime tmpl)，然后在列表中选中要安装的插件。 安装成功后一般在Perferences-&gt;package settings中可看到，有些插件有可能在列表中搜索不到，你可以选择手动安装。 手动安装进入sublimetext安装包管理器官网，在搜索框里输入你所需要的插件名称。 进入插件的github页面（点击Details下面的github.com），点击右侧的clone or download -&gt; Download ZIP，将下载的压缩包解压后放在Preferences-&gt;Browse Packages（即packages文件夹）里面，并重命名（去掉文件名中的##master），重启Sublimetext3即可安装成功。 SublimeText插件推荐emmet让html css的编写更加迅速。语法参考 ConvertToUTF8文件转码成utf##8 IMESupportsublime中文输入法 Nodejsnode代码提示 AutoFileName快捷输入文件名 Doc​Blockr生成优美注释 jQueryjQ函数提示 Bracket Highlighter可匹配[]， ()， {}， “”， ”， ，高亮标记，便于查看起始和结束标记 LESSLESS高亮插件 JSFormatJavaScript的代码格式化插件 Color Highlighter快捷选取颜色选中还有颜色显示 CSS Comments各种css注释快捷书写 HTML-CSS-JS Prettify格式化上述类型文件 markdownpreview可以预览markdown文件，以及生成HTML页面。 Minifier压缩JS和CSS文件 SideBarEnhancements侧边目录树内容更加丰富 SublimeTmpl新建模板文件 File Header生成文件头，记录更新情况。 以上这些基本上就是前端常用的插件，使用方法可以自行百度(太懒就木有写使用方法0.0)]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>ide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发模板HTML5 Boilerplate]]></title>
    <url>%2F2015%2F07%2F28%2Fh5bp%2F</url>
    <content type="text"><![CDATA[最流行的web开发前端模版HTML5 Boilerplate推荐给大家 HTML5 Boilerplate 帮你构建快速，健壮，并且适应力强的web app或网站。这个小小的源码包集合了100位开发者的经验，你可以将这些经验运用在你的项目中。 Google统计、图标和更多压缩包内包含了 一个干净、移动终端友好的HTML模版；优化过的Google统计代码；触摸屏设备上使用的图标（这个可以替换成你自己的）；还有丰富的文档、技巧、窍门。 Normalize.css 和辅助功能包含了 Normalize.css v1 版本一个先进的、支持HTML5的CSS reset 和基础样式、辅助功能、media queries、打印样式。 jQuery 与 Modernizr自带了两个优秀的Javascript工具库的最新版本： jQuery (默认链接到 Google的CDN, 如果CDN失效，本地文件作为后备) 和Modernizr浏览器特性监测工具库。 高性能提供了一组 Apache 配置参数，帮你提高网站的性能。 点击此处进行下载]]></content>
      <categories>
        <category>前端学习笔记</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
</search>
